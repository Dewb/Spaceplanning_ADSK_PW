<Workspace Version="0.8.0.1233" X="133.465742570006" Y="827.289725922348" zoom="0.155062692168264" Name="Home" RunType="Automatic" RunPeriod="100" HasRunWithoutCrash="True">
  <NamespaceResolutionMap>
    <ClassMap partialName="Point" resolvedName="Autodesk.DesignScript.Geometry.Point" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Rectangle.Points[0]" resolvedName="Autodesk.DesignScript.Geometry.Rectangle" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Rectangle" resolvedName="Autodesk.DesignScript.Geometry.Rectangle" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Point.Z" resolvedName="Autodesk.DesignScript.Geometry.Point" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="List" resolvedName="DSCore.List" assemblyName="DSCoreNodes.dll" />
    <ClassMap partialName="Vector" resolvedName="Autodesk.DesignScript.Geometry.Vector" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Curve" resolvedName="Autodesk.DesignScript.Geometry.Curve" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Curve.reverse" resolvedName="Autodesk.DesignScript.Geometry.Curve" assemblyName="ProtoGeometry.dll" />
  </NamespaceResolutionMap>
  <Elements>
    <DSIronPythonNode.PythonNode guid="1215010b-2f5d-4031-8865-d1c64d5151a7" type="DSIronPythonNode.PythonNode" nickname="Separate Bank Maker" x="4891.3427989191" y="1865.01096534557" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

elevBoxes = IN[0]
buildSections=IN[1]
numElevRow = len(elevBoxes[0])
numRows = len(elevBoxes)


#to fix the sequence of elevators in the elv boxes----------------------------------------------------------------------		
def reverseList():
	global elevBoxes	
	cnt =0
	for i in range(len(elevBoxes)-1):	
		if (i)%2 == 0:
			cnt += 1
			if cnt%2==0:
				str =""
				elevBoxes[i].reverse()
				elevBoxes[i+1].reverse()
#-----------------------------------------------------------------------------------------------------------------------	


#to make one list of input elev lists-----------------------------------------------------------------------------------
def totalElevList():
	newElevBoxes=[]	
	for i in range(len(elevBoxes)):
		elev = elevBoxes[i]
		for j in range(len(elev)):
			newElevBoxes.append(elev[j])
	return newElevBoxes
#-----------------------------------------------------------------------------------------------------------------------	


#to distribute number of elevators per bank based on number elev per row------------------------------------------------
def bankNumbers():
	listElevBoxes=totalElevList()
	totalElevNum = len(listElevBoxes)
	bankNum=[]
	
	perDivision = int(math.floor(totalElevNum/buildSections))
	if (perDivision &gt;= numElevRow): perDivision = numElevRow
	if (perDivision &lt; numElevRow): perDivision = int(numElevRow/2)
	diff = totalElevNum - (perDivision*buildSections)
	
	#perDivision = [numElevRow if perDivision &gt;= numElevRow]
	#perDivision = [numElevRow/2 if perDivision &lt; numElevRow]
	
	if perDivision &gt;=1:
		for i in range(buildSections):
			bankNum.append(perDivision)
		bankNum[-1] += diff
	
	
	#to make all if they all are even numbers
	surplus =0
	for i in range(len(bankNum)):
		if bankNum[i]%2 !=0:
			bankNum[i] -= 1
			surplus	+= 1
	if surplus &gt; 0 : bankNum[-1] += surplus	
	bankNum.sort()
	bankNum.reverse()

	return bankNum
#-----------------------------------------------------------------------------------------------------------------------

#to make separate banks of elevs based on number of building sections---------------------------------------------------
def makePairs():
	str = []
	newElevsList =[]
	for i in range(0,numRows,2): 
		if i == numRows-1:			
			newElevsList.extend(elevBoxes[-1])
			str.append("entered here")
		else:		
			listA = elevBoxes[i]
			listB = elevBoxes[i+1]
			newList = crossLists(listA,listB)
			newElevsList.extend(newList)
			str.append("may be")				
	return newElevsList
#-----------------------------------------------------------------------------------------------------------------------

#to cross two lists togthr and return one list out----------------------------------------------------------------------
def crossLists(listA,listB):
	crossedList = []
	for i in range(len(listA)):
		crossedList.append(listA[i])
		crossedList.append(listB[i])
	return crossedList
#-----------------------------------------------------------------------------------------------------------------------


#to make separate banks of elevs based on number of building sections---------------------------------------------------
def makeBanks():
	#listElevBoxes=totalElevList()
	#totalElevNum = len(listElevBoxes)
	
	listElevBoxes=makePairs()
	totalElevNum = len(listElevBoxes)
	
	elevperBank = bankNumbers()
	elevCount   = 0
	perRowCount = 0
	listBanks=[]
	temp =0	
	for i in range(buildSections):
		elevAtBank =[]
		xVal = elevperBank[i]		
		for j in range(xVal):
			try:
				elevAtBank.append(listElevBoxes[temp+j])
			except:
				print "some error"
			#elevAtBank.append(listElevBoxes[temp+j])
			if ( j == xVal-1): temp = temp + xVal
		listBanks.append(elevAtBank)
	return listBanks,totalElevNum
#------------------------------------------------------------------------------------------------------------------------

#reverseList()

out = makeBanks()
out2 = bankNumbers()
#crossed = makePairs()



#Assign your output to the OUT variable
OUT = out,out2,len(totalElevList())
#OUT = out2</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="7e3fd7a4-701d-4426-aa25-86615b917980" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="TechRoom" x="4014.50112779073" y="1943.80551352391" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="{techRoom[0],techRoom[2]};" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="31bb949a-db78-4b30-9486-d6b50b132395" type="DSIronPythonNode.PythonNode" nickname="Translate Floors" x="2224.75461239864" y="1442.46370322068" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flrList	=	IN[0]
flrHt	=	IN[1]
newflrList = []
for i in range(len(flrList)):
	flr = flrList[i]
	ptA = Point.ByCoordinates(0,0,flrHt)
	ptB	= Point.ByCoordinates(0,0,0)
	vec = Vector.ByTwoPoints(ptA,ptB)
	newflr = Geometry.Translate(flr,vec,flrHt)
	newflrList.append(newflr)

#Assign your output to the OUT variable
OUT = newflrList</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.DoubleSlider guid="2aa2aa0b-051f-40d7-aa9e-5cb0b5ba33a3" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Ratio DimElevator" x="-796.885964931277" y="328.141400378327" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>1.1</System.Double>
      <Range min="0.1" max="3" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSIronPythonNode.PythonNode guid="3719525c-c82d-4453-b8cf-6bb58712191e" type="DSIronPythonNode.PythonNode" nickname="Elevator Dimensions" x="2948.80855856678" y="1781.67497294612" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN
elevArea	=	IN[0]
ratio		=	IN[1]


len			=	math.sqrt(elevArea/ratio)
wid			=	elevArea/len
#Assign your output to the OUT variable
OUT = wid,len
#OUT = len,wid</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="868a7954-8eff-428e-861d-790b11492e06" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="TAG SWITCH" x="-780.767779838044" y="-1337.76441438129" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="A=1;&#xA;B=&quot;EITHER 0 OR 1&quot;;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="eafc1115-3510-4d68-8c8e-7309ce1612f4" type="DSIronPythonNode.PythonNode" nickname="Toilet Arrangement Different&#xD;&#xA;" x="4887.2254838483" y="1406.01765595016" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

restroomRec		=	IN[0]
floorRec		=	IN[1]
marker			=	IN[2]

widthRestrm		=	restroomRec.Width
lengthRestrm	=	restroomRec.Height
pointsRestrm	=	restroomRec.Points

#---------------------------------------------------------------

# 1 = LONGITUDINAL CUT		0 = TRAVERSAL CUT
#make boxes inside--------------------------------------------------------------------------------
def splitRec(rec,f1,tag):
	recPoints	=	rec.Points
	width		=	rec.Width
	length		=	rec.Height
	#make the four edges of the input rectangle
	lineList	=	[]
	for i in range(len(recPoints)):
		if(i== len(recPoints)-1):
			k = 0
		else:
			k = i+1
		ptA		=	recPoints[i]
		ptB		=	recPoints[k]
		lin		=	Line.ByStartPointEndPoint(ptA,ptB)
		lineList.append(lin)
		
	#pick two points on the shorter lines
	len1	=	lineList[0].Length
	len2	=	lineList[1].Length
	if (tag == 1):
		if (len1&lt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
	else:
		if (len1&gt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
		
		
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	outRec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	outRec2	=	Rectangle.ByCornerPoints(stPt2,endPt1,ptOut1,ptOut2)
		
	#return lineShort1,lineShort2,ptOut1,ptOut2,width,length,outRec1,outRec2
	return outRec1,outRec2
	#return lineList
#END OF FUNCTION# --------------------------------------------------------------------------------



#-----------------------------------------------------------------------------------------------------
def findOuterPt():
	restrmPoints	=	restroomRec.Points
	floorPoints		=	floorRec.Points

	selectedLines	=	[]
	selectedPoints	=	[]
	lineStoreList=[]
	lineList	=	[]
	lineStore=0
	for i in range(len(restrmPoints)):
		ptA 		= 	restrmPoints[i]
		#lineList	=	[]
		# iterate to make the 4 lines 
		for j in range(len(floorPoints)):
			ptB 		= 	floorPoints[j]
			lineAB		=	Line.ByStartPointEndPoint(ptA,ptB)
			lineList.append(lineAB)
		prevLine=""
		#lineStore=0
		# iterate to find the shortest line out of the four
		for k in range(len(lineList)):
			currentLine = lineList[k]
			if ( prevLine != ""):
				if ( prevLine.Length &gt; currentLine.Length ): lineStore = currentLine
				else : lineStore = prevLine
			prevLine = currentLine
		lineStoreList.append(lineStore)
	
	prevLen = ""
	indexVal= 0
	for l in range(len(lineStoreList)):
		currentLen	=	lineStoreList[l].Length
		if ( prevLen != ""):
			if ( prevLen &gt; currentLen ): indexVal = l
		prevLen = currentLen
		
	shortLine = lineStoreList[indexVal]
	finalPoint= shortLine.StartPoint
	return finalPoint
#END OF FUNCTION# --------------------------------------------------------------------------------


#decide the proportion of fraction----------------------------------------------------------------
def facDecider(rec,pt):
	points	=	rec.Points
	width	=	rec.Width
	length	=	rec.Height
	line	=	Vector.ByTwoPoints(points[0],pt)
	#line	=	Line.ByStartPointEndPoint(points[0],pt)
	len		=	line.Length
	
	if (width&lt;length):
		shortDist = width
	else:
		shortDist = length
	
	if (len&gt;shortDist):
		fac = 0.8
	else:
		fac = 0.2
	return fac
#END OF FUNCTION# --------------------------------------------------------------------------------

def closerRect(recList,pt):
	lenList=[]
	for i in range(0,len(recList)):	
		rec	=	recList[i]
		lin = 	Line.ByStartPointEndPoint(rec.Center(),pt)
		lenList.append(lin.Length)
	index= ""
	for i in range(0,len(lenList)-1):
		len1 = lenList[i]
		len2 = lenList[i+1]
	if (len1&lt;len2):
		index = 0
	else:
		index = 1
	return recList[index]
		


finalPoint= findOuterPt()

if(marker == 1):
	key1 = 0
	key2 = 1
else:
	key1 = 1
	key2 = 0

recs	=	splitRec(restroomRec,0.5,key1)
closeRec=	closerRect(recs,finalPoint)
fac		=	facDecider(closeRec,finalPoint)
rec2	=	splitRec(closeRec,fac,key2)

#Assign your output to the OUT variable
#OUT = lineStoreList,lineList,restrmPoints,shortLine,finalPoint
OUT = recs[0],rec2#finalPoint"</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="e2654352-d2ab-4547-ba84-d9bd4cae7cfb" type="DSIronPythonNode.PythonNode" nickname="Technical Room Arrangements&#xD;&#xA;" x="4883.10065774794" y="1547.78981955349" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRec		=	IN[0]

#---------------------------------------------------------------



# 1 = LONGITUDINAL CUT		0 = TRAVERSAL CUT
#make boxes inside--------------------------------------------------------------------------------
def splitRec(rec,f1,tag):
	recPoints	=	rec.Points
	width		=	rec.Width
	length		=	rec.Height
	#make the four edges of the input rectangle
	lineList	=	[]
	for i in range(len(recPoints)):
		if(i== len(recPoints)-1):
			k = 0
		else:
			k = i+1
		ptA		=	recPoints[i]
		ptB		=	recPoints[k]
		lin		=	Line.ByStartPointEndPoint(ptA,ptB)
		lineList.append(lin)
		
	#pick two points on the shorter lines
	len1	=	lineList[0].Length
	len2	=	lineList[1].Length
	if (tag == 1):
		if (len1&lt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
	else:
		if (len1&gt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
		
		
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	outRec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	outRec2	=	Rectangle.ByCornerPoints(stPt2,endPt1,ptOut1,ptOut2)
		
	#return lineShort1,lineShort2,ptOut1,ptOut2,width,length,outRec1,outRec2
	return outRec1,outRec2
	#return lineList
#END OF FUNCTION# --------------------------------------------------------------------------------

outList	=	[]
twoLinearRecs	=	splitRec(mainRec,0.38,1)
rec1			=	twoLinearRecs[0]
rec2			=	twoLinearRecs[1]
for i in range(4):
	#fac		=	random.random()
	fac 	=	0.4
	out1 	=	splitRec(rec1,fac,0)
	outList.append(out1)
	rec1	=	out1[1]
	
	out2 	=	splitRec(rec2,fac,0)
	outList.append(out2)
	rec2	=	out2[1]
	


#Assign your output to the OUT variable
#OUT = lineStoreList,lineList,restrmPoints,shortLine,finalPoint
OUT = outList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="d94d7fa2-d56d-4288-a216-c619b46762e3" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Technical Rooms" x="4565.65632174089" y="1611.65781020917" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="Toilet[0];&#xA;Toilet[2];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="ecd46302-783f-4a29-a72b-c026b571474a" type="DSIronPythonNode.PythonNode" nickname="Technical Room Arrangements&#xD;&#xA;" x="4884.1565128963" y="1642.92289780341" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRec		=	IN[0]

#---------------------------------------------------------------



# 1 = LONGITUDINAL CUT		0 = TRAVERSAL CUT
#make boxes inside--------------------------------------------------------------------------------
def splitRec(rec,f1,tag):
	recPoints	=	rec.Points
	width		=	rec.Width
	length		=	rec.Height
	#make the four edges of the input rectangle
	lineList	=	[]
	for i in range(len(recPoints)):
		if(i== len(recPoints)-1):
			k = 0
		else:
			k = i+1
		ptA		=	recPoints[i]
		ptB		=	recPoints[k]
		lin		=	Line.ByStartPointEndPoint(ptA,ptB)
		lineList.append(lin)
		
	#pick two points on the shorter lines
	len1	=	lineList[0].Length
	len2	=	lineList[1].Length
	if (tag == 1):
		if (len1&lt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
	else:
		if (len1&gt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
		
		
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	outRec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	outRec2	=	Rectangle.ByCornerPoints(stPt2,endPt1,ptOut1,ptOut2)
		
	#return lineShort1,lineShort2,ptOut1,ptOut2,width,length,outRec1,outRec2
	return outRec1,outRec2
	#return lineList
#END OF FUNCTION# --------------------------------------------------------------------------------


outList	=	[]
twoLinearRecs	=	splitRec(mainRec,0.60,0)
rec1			=	twoLinearRecs[0]
rec2			=	twoLinearRecs[1]
for i in range(3):
	#fac		=	random.random()
	fac 	=	0.35
	out1 	=	splitRec(rec1,fac,0)
	outList.append(out1)
	rec1	=	out1[1]
	
	out2 	=	splitRec(rec2,fac,0)
	outList.append(out2)
	rec2	=	out2[1]
	
	
	

#Assign your output to the OUT variable
#OUT = lineStoreList,lineList,restrmPoints,shortLine,finalPoint
OUT = outList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="df71274b-f488-4028-9e87-f8d8359aa7be" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Floor Curve" x="4563.78283984553" y="1530.66458767591" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="floorcrv;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="17c365fa-6824-4153-83c1-47c2ffc01510" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Toilets" x="4564.52130935149" y="1447.65862853505" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="Toilet[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="519e821b-1d37-46f0-9e2d-474c06308025" type="DSIronPythonNode.PythonNode" nickname="Technical Rooms + Restrooms" x="4265.09811220925" y="1407.9174616338" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

wrapperRect		=	IN[0]
areaTechnical	=	IN[1]
areaRestrm		=	IN[2]

# incoming rectangle specifications
wrapPts			=	wrapperRect.Points
wrapWidth		=	wrapperRect.Width
wrapLength		=	wrapperRect.Height
#----------------------------------------------------------------------------------------


#totArea			=	areaTechnical + areaRestrm 
totArea			=	wrapWidth * wrapLength
facT			=	areaTechnical / totArea
facR			=	areaRestrm / totArea


def makeThreePiece(width,length,pts,f1,f2):
	if (width &lt; length):
		rec1Length 		=	f1*length
		rec1Width		=	width
		
		rec2Length 		=	f2*length
		rec2Width		=	width
		
		rec3Length 		=	length - rec1Length - rec2Length
		rec3Width		=	width
		
		index			=	1		
	else:
		rec1Length 		=	length
		rec1Width		=	f1*width
		
		rec2Length 		=	length
		rec2Width		=	f2*width
		
		rec3Length 		=	length
		rec3Width		=	width - rec1Width - rec2Width
		
		index			=	3
	
	cs1					= 	CoordinateSystem.ByOrigin(pts[0].X,pts[0].Y,0) 
	
	# to make the 1st rectangle ----------------------------------------------------------------------	
	rec1 				= 	Rectangle.ByWidthHeight(cs1,rec1Width,rec1Length)	
	rec1Vec				= 	Vector.ByTwoPoints(rec1.Points[0],pts[0])
	rec1				=	Geometry.Translate(rec1, rec1Vec)
	rec1Pt				=	rec1.Points	
	cs1					= 	CoordinateSystem.ByOrigin(rec1Pt[0].X,rec1Pt[0].Y,0)
	
	# to make the 2nd rectangle ----------------------------------------------------------------------	
	rec2 				= 	Rectangle.ByWidthHeight(cs1,rec2Width,rec2Length)	
	rec2Vec				= 	Vector.ByTwoPoints(rec2.Points[0],rec1Pt[index])
	rec2				=	Geometry.Translate(rec2, rec2Vec)
	rec2Pt				=	rec2.Points	
	cs1					= 	CoordinateSystem.ByOrigin(rec2Pt[0].X,rec2Pt[0].Y,0)
	
	# to make the 2nd rectangle ----------------------------------------------------------------------	
	rec3 				= 	Rectangle.ByWidthHeight(cs1,rec3Width,rec3Length)	
	rec3Vec				= 	Vector.ByTwoPoints(rec3.Points[0],rec2Pt[index])
	rec3				=	Geometry.Translate(rec3, rec3Vec)
	
	return rec1,rec2,rec3
	#END OF FUNCTION#


recList = makeThreePiece(wrapWidth,wrapLength,wrapPts,0.4,0.2)
#Assign your output to the OUT variable
#OUT = [techRec1,otherRec]
OUT = recList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="3466cc6e-609e-4110-93b0-c477fb202f21" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_Service Module/ Tech rooms" x="4010.27324054212" y="1410.65735154403" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[2];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="6fb2b54b-2df0-4aba-bbf1-6541b826e769" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_RestRooms" x="4009.37375227219" y="1329.4611636215" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="0ecab49a-34a9-4fef-abd9-1b43342c17d8" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Service Core Full Block" x="4010.38846965378" y="1495.78659328374" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[3];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="78ce0e7e-888c-4504-a82b-3a143ce68e00" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Total Elev ( pass + service )" x="4014.19014009444" y="1742.68429408207" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="totalElevs = a[0]+a[1];" ShouldFocus="false" />
    <DSCoreNodesUI.Input.DoubleSlider guid="ac550d14-fe5f-4c02-b394-9c4a8baa43a0" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Lift Lobby Width" x="-796.885964931277" y="261.545594215197" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>2</System.Double>
      <Range min="0.5" max="11" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="3c9da584-a4a5-4e65-bc78-7a785395b657" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Area per Elevator" x="-796.038235735827" y="94.9766058530161" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>4</System.Double>
      <Range min="1" max="100" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <Dynamo.Nodes.CodeBlockNodeModel guid="f4662ef7-4920-491c-a08c-e9eb9912d8a8" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Bank Rectangle Piece" x="4010.11585970546" y="1247.25257080848" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="Bank_Rectangle[0][0];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="7cd45512-ef89-4748-a371-3b9879106126" type="DSIronPythonNode.PythonNode" nickname="Elevators per Bank" x="2957.43826368638" y="1510.23261161112" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


numBanks_Elev		=	IN[0]
elev_List			=	IN[1]

#calc total number of elevators needed ( passenger + service )
totalElev_Num		=	elev_List[0] + elev_List[1]

# int value of per bank elevator
perBank_Elev		=	int(totalElev_Num / numBanks_Elev)
leftElev			=	totalElev_Num - ( perBank_Elev * numBanks_Elev )

#equally add the elevators to each banks
numElevBank_List 	=	[]
for i in range(numBanks_Elev):
	numElevBank_List.append(perBank_Elev)

# add the left over elevators to each banks
index = 0
while (leftElev &gt; 0):
	numElevBank_List[index] += 1
	leftElev				-= 1
	index					+= 1

# check for even number of elevators per bank
num		=	numBanks_Elev-1
for i in range(num):
	if (numElevBank_List[i] % 2 == 1): 
		numElevBank_List[i] 	-= 1
		numElevBank_List[i+1]	+= 1

#final total elev alloted 
totalElev	=	sum(numElevBank_List)

	

	

#Assign your output to the OUT variable
OUT = [numElevBank_List,totalElev,leftElev]</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="0a963c9b-1586-4265-9afa-a81149db1a64" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Lowest Floor Width Length" x="-796.885964931277" y="-90.088629694694" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="width;&#xA;length;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="6b338560-d7b0-4500-b5a8-4f4fabbf061e" type="DSIronPythonNode.PythonNode" nickname="Number of Elevators Needed" x="2950.93440403506" y="1630.73711945091" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

totalBuiltArea 	= 	IN[0]
passArea		=	IN[1]
servArea		=	IN[2]
passElev = math.ceil(totalBuiltArea/passArea)
servElev = math.ceil(totalBuiltArea/servArea)

#make sure elevator counts are even
if (passElev % 2 == 1): passElev += 1
if (servElev % 2 == 1): servElev += 1


#Assign your output to the OUT variable
OUT = [passElev, servElev]</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="eee08eff-9c8c-496b-bbec-e2f98c0879e3" type="DSIronPythonNode.PythonNode" nickname="Total Built Area" x="2224.75461239864" y="1748.24211169579" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floor_Area = IN[0]
totalBuiltArea = sum(floor_Area)


#Assign your output to the OUT variable
OUT = totalBuiltArea</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="644044fb-8de2-498c-a80e-61f00a8304b1" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Tower Base Point" x="-798.507776484547" y="0.522784392926042" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="tower_CenterPoint_Base;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="f685c6ad-e63d-4638-8f0c-4d5409cf4563" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="USER INPUTS" x="-797.184544249637" y="-266.910382684044" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="building_sections = 3;&#xA;area_passElev = 8000;&#xA;area_servElev = 7000;&#xA;restroom_Prop = 0.15;&#xA;techroom_Prop = 0.25;" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="57a39e1e-ddd6-4efd-8688-d715c01567b7" type="Dynamo.Nodes.DSFunction" nickname="GBA - Floor Area" x="2223.98640926679" y="1657.43750068811" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Surface.Area" />
    <Dynamo.Nodes.DSFunction guid="13335fdd-daad-4d4b-81a4-7415b119810a" type="Dynamo.Nodes.DSFunction" nickname="Floor Surface" x="2223.98640926679" y="1556.38972478495" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Surface.ByPatch@Autodesk.DesignScript.Geometry.Curve" />
    <DSIronPythonNode.PythonNode guid="fc863909-cdb2-4d4c-ac70-cdab5f1f9db2" type="DSIronPythonNode.PythonNode" nickname="Join Curves for Each Floor" x="1891.17216640159" y="1690.3987577818" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flr_Curves = IN[0]

num = len(IN[0])-1

joinedCrvList = []
for i in range(num):
	selflrCrv = flr_Curves[i]
	num2 = len(selflrCrv)
	crv_Join = []
	for j in range(num2):
		if (selflrCrv is None):
			break
		crv_Join.append(selflrCrv[j])
	joinedCrvList.append(PolyCurve.ByJoinedCurves(crv_Join))

	

#Assign your output to the OUT variable
OUT = joinedCrvList
#OUT = flr_Curves[3]</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="9888c44e-071c-4dac-8296-fc1e86caef71" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="User Input Floor Heights" x="-780.767779838044" y="-1122.70935858928" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="regularFloorHeight = 4;&#xA;mechanicalFloorHeight = 7;&#xA;mechFloor_Frequency = 18;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="94ab79e8-a180-4b5c-a0d5-39c2d482b0d0" type="DSIronPythonNode.PythonNode" nickname="Generates Floor Plane Heights" x="1265.43178935246" y="1673.15818960436" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

#inputs------------------------------------------------------------
twr_Height = IN[0]
regflr_Ht  = IN[1]
mechflr_Ht = IN[2]
keyflr_Mech= IN[3]
#inputs------------------------------------------------------------

approxNum_Floors  =  twr_Height / regflr_Ht
numberof_MechFloors = math.ceil(approxNum_Floors / keyflr_Mech)
height_Counter = 0
height_List=[]
height = 0


while height&lt;twr_Height:		
	#iterate to add the heights for the regular floors till first mechanical lvl
	for i in range(keyflr_Mech):
		height += regflr_Ht
		height_List.append(height)
		if ((height + mechflr_Ht + 1) &gt; twr_Height): break
				
	if ((height) &gt; twr_Height):	break		
		
	height += mechflr_Ht
	# add the mechanical floor height to the height list
	height_List.append(height)
 




#Assign your output to the OUT variable
OUT = height_List</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="1841d5de-fcb3-4383-b3d2-62e7b2c616d9" type="Dynamo.Nodes.DSFunction" nickname="Geometry.Translate" x="1280.01319635805" y="1530.3671330951" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Geometry.Translate@Autodesk.DesignScript.Geometry.Vector,double" />
    <Dynamo.Nodes.DSFunction guid="0492db29-5a6a-48ac-90d2-f75c87c87420" type="Dynamo.Nodes.DSFunction" nickname="Base Curve Center" x="1536.23906202914" y="1925.92920929681" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Polygon.Center" />
    <Dynamo.Nodes.DSFunction guid="0351702e-293c-4b99-b97a-db41c0312f88" type="Dynamo.Nodes.DSFunction" nickname="Vector.ByTwoPoints" x="1709.26147609906" y="1868.88423380023" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Vector.ByTwoPoints@Autodesk.DesignScript.Geometry.Point,Autodesk.DesignScript.Geometry.Point" />
    <Dynamo.Nodes.DSFunction guid="87bbebfa-dfb4-4e25-af0f-22796d78458c" type="Dynamo.Nodes.DSFunction" nickname="Curve.PointAtParameter" x="1533.38397298776" y="2019.91648775462" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Curve.PointAtParameter@double">
      <PortInfo index="1" default="True" />
    </Dynamo.Nodes.DSFunction>
    <Dynamo.Nodes.CodeBlockNodeModel guid="351c1480-1635-4d4b-b388-cc1dbc2b5207" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Projected Line Specifications" x="-780.767779838044" y="-1000.65857714671" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="-100;&#xA;100;&#xA;0;&#xA;100;&#xA;0.5;" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="bede10e0-df9b-456e-b9c1-3c8bd579ca75" type="Dynamo.Nodes.DSFunction" nickname="Point.ByCoordinates" x="1329.70991838758" y="1987.14832799099" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Point.ByCoordinates@double,double,double">
      <PortInfo index="0" default="True" />
      <PortInfo index="1" default="True" />
      <PortInfo index="2" default="True" />
    </Dynamo.Nodes.DSFunction>
    <Dynamo.Nodes.DSFunction guid="81a0f2da-508b-42b2-8f49-c8e486eb00a9" type="Dynamo.Nodes.DSFunction" nickname="Point.ByCoordinates" x="1328.16139461186" y="1836.587145629" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Point.ByCoordinates@double,double,double">
      <PortInfo index="0" default="True" />
      <PortInfo index="1" default="True" />
      <PortInfo index="2" default="True" />
    </Dynamo.Nodes.DSFunction>
    <Dynamo.Nodes.DSFunction guid="4300f65b-4327-47a7-8fad-d1b6b68af639" type="Dynamo.Nodes.DSFunction" nickname="Projection Line" x="1533.38397298776" y="1807.89485251829" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Line.ByStartPointEndPoint@Autodesk.DesignScript.Geometry.Point,Autodesk.DesignScript.Geometry.Point" />
    <Dynamo.Nodes.DSFunction guid="2c8d025a-aa71-4a05-a811-2f4ab67a59bc" type="Dynamo.Nodes.DSFunction" nickname="Floor Plans" x="1891.17216640159" y="1533.3501996818" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Curve.Project@Autodesk.DesignScript.Geometry.Geometry,Autodesk.DesignScript.Geometry.Vector" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="191b539b-f6ef-44b3-9c4b-277a50a880be" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="List of Curves" x="1525.75865316545" y="1369.0735503499" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="{a,b};" ShouldFocus="false" />
    <DSCoreNodesUI.Input.DoubleSlider guid="5c214bfd-bd00-4a41-8a47-68a419c6b490" type="DSCoreNodesUI.Input.DoubleSlider" nickname="rotation angle" x="-780.767779838044" y="-1404.44799935698" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>35</System.Double>
      <Range min="0" max="90" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <Dynamo.Nodes.DSFunction guid="6f820a01-981b-4a7e-a76e-fe1a62d98c11" type="Dynamo.Nodes.DSFunction" nickname="Translated Curve Center" x="1900.08766445481" y="1154.66511111152" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Polygon.Center" />
    <Dynamo.Nodes.DSFunction guid="c3e371b9-4add-43b6-a538-dfb574d9aa75" type="Dynamo.Nodes.DSFunction" nickname="Top Curve" x="1900.08766445481" y="1244.48240606166" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Geometry.Rotate@Autodesk.DesignScript.Geometry.Point,Autodesk.DesignScript.Geometry.Vector,double">
      <PortInfo index="3" default="True" />
    </Dynamo.Nodes.DSFunction>
    <DSCoreNodesUI.Input.DoubleSlider guid="3d465364-d22c-429a-9bba-4a6a7cd5438f" type="DSCoreNodesUI.Input.DoubleSlider" nickname="height" x="-780.767779838044" y="-1479.86206077068" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>400</System.Double>
      <Range min="1" max="600" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <Dynamo.Nodes.CodeBlockNodeModel guid="c56aeef4-0c0c-42cb-916a-7f17c965c50c" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Vector xyz units" x="-780.767779838044" y="-1239.4288320633" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="0;&#xA;0;&#xA;5;" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="d649c12c-2eed-414e-9284-e60bf8463043" type="Dynamo.Nodes.DSFunction" nickname="Vector.ByCoordinates" x="1524.73696239793" y="1218.85396784155" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Vector.ByCoordinates@double,double,double">
      <PortInfo index="0" default="True" />
      <PortInfo index="1" default="True" />
      <PortInfo index="2" default="True" />
    </Dynamo.Nodes.DSFunction>
    <Dynamo.Nodes.DSFunction guid="49ac0fec-0f03-4167-9c8e-afe6ea4472fd" type="Dynamo.Nodes.DSFunction" nickname="Geometry.Translate" x="1900.08766445481" y="1005.89960731257" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Geometry.Translate@Autodesk.DesignScript.Geometry.Vector,double" />
    <DSCoreNodesUI.Input.DoubleSlider guid="00c9bc5f-de66-45e0-979a-d7686efe103f" type="DSCoreNodesUI.Input.DoubleSlider" nickname="length" x="-780.767779838044" y="-1556.86135974492" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>50</System.Double>
      <Range min="1" max="250" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="9d25d391-50c9-4f8c-8484-531fa64ade08" type="DSCoreNodesUI.Input.DoubleSlider" nickname="width" x="-780.767779838044" y="-1627.73356122819" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>30</System.Double>
      <Range min="1" max="300" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="0c800683-32ce-4713-8728-412bd1bdcdac" type="DSCoreNodesUI.Input.DoubleSlider" nickname="z_orig" x="-780.767779838044" y="-1777.4567923165" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>0</System.Double>
      <Range min="-100" max="100" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="7c51fc59-9cbe-4d7d-8873-d2aadd775f6f" type="DSCoreNodesUI.Input.DoubleSlider" nickname="y_orig" x="-780.767779838044" y="-1850.13122744944" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>0</System.Double>
      <Range min="-100" max="100" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="15b1af56-37b0-4527-b70b-9277bfcef748" type="DSCoreNodesUI.Input.DoubleSlider" nickname="x_orig" x="-780.767779838044" y="-1916.51029109307" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>-40.9</System.Double>
      <Range min="-100" max="100" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSIronPythonNode.PythonNode guid="06023a06-715f-4fd3-90b4-f1c570905900" type="DSIronPythonNode.PythonNode" nickname="CoordinateSystem at Pt" x="1522.89595375637" y="924.088165584429" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

x=IN[0]
y=IN[1]
z=IN[2]

cs = CoordinateSystem.ByOrigin(x,y,z)

#Assign your output to the OUT variable
OUT = cs</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="2958c653-21b8-4497-b7ad-a1fda207a0a4" type="Dynamo.Nodes.DSFunction" nickname="Base Curve" x="1521.73061828622" y="1068.74936486221" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Rectangle.ByWidthHeight@Autodesk.DesignScript.Geometry.CoordinateSystem,double,double">
      <PortInfo index="1" default="True" />
      <PortInfo index="2" default="True" />
    </Dynamo.Nodes.DSFunction>
    <Dynamo.Nodes.DSFunction guid="043ebc1a-c018-4a5a-8146-85aff541e8a3" type="Dynamo.Nodes.DSFunction" nickname="Tower Surface" x="1891.17216640159" y="1444.37609100264" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Surface.ByLoft@Autodesk.DesignScript.Geometry.Curve[]" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="df536c34-da96-4eaa-b92a-696e8d018c16" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Building Sections" x="4019.77200947935" y="1848.63484998274" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="buildSections;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="6d6686be-118d-46d6-a994-4aec80e4691a" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Elevators" x="7937.07073675167" y="-292.291201763268" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0][0];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="ef72918a-b669-447f-a00d-8cfd310acee0" type="DSIronPythonNode.PythonNode" nickname="Key Floor Finder" x="4553.49295664945" y="-167.539675016153" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="7">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

buildSections 	= 	IN[0]
grossBuildArea	=	IN[1]
#grossBuildArea	=	IN[2]
elevPerbankList	=	IN[2]
boundaryFactor	=	IN[3]
servModArea		=	IN[4]
elevArea		=	IN[5]
numFloors		=	IN[6]



#compute target area for each bank of elev serving each building section--------------------------------------------------------------------
def targetAreaCalculator(uba,buildSections):
	#output target area list for each bank of elev for each building section
	tarAreaList = []	
	#make the uba array
	totalBuildArea = 0
	for i in range(len(uba)):
		totalBuildArea += uba[i]		
	# compute the fraction
	frac 	=	totalBuildArea/buildSections
	
	#compute the target areas by iterating
	for i in range(1,buildSections+1):
		tarAreaList.append(frac*i)	
	return tarAreaList
#-------------------------------------------------------------------------------------------------------------------------------------------

#ccompute the key floors where the banks of elevators needs to be dropped-------------------------------------------------------------------
def keyFloorFinder():
	currentFloor = 1 # current floor counter
	#computer bank Area for each bank ( from elev Area )
	bankArea = [x*elevArea for x in elevPerbankList] 
	#bankArea = [10000 for x in elevPerbankList] 
	
	# iterate to find usable Build Area first
	ubaList = []
	for i in range(len(grossBuildArea)):
		ubaList.append(grossBuildArea[i]-servModArea)
	#compute the targetAreaList
	tarAreaList = targetAreaCalculator(ubaList,buildSections)
	
	#make the served areas list and key floor list and set as 0 values
	servedAreaList = [0 for x in range(buildSections)]		
	key = [0 for x in range(buildSections)]
	
	while currentFloor &lt;= len(ubaList)-1:
		#iterate to check if target is reached
		for i in range(buildSections):
			if servedAreaList[i] &lt; tarAreaList[i] and tarAreaList[i] - servedAreaList[i] &gt;= ubaList[currentFloor]*boundaryFactor:
				ubaList[currentFloor] = ubaList[currentFloor] - bankArea[i] 
		#iterate to check if target is reached	
		for i in range(buildSections):
			if servedAreaList[i] &lt; tarAreaList[i] and tarAreaList[i] - servedAreaList[i] &gt;= ubaList[currentFloor]*boundaryFactor:
				# update served areas and the key floors
				servedAreaList[i] = servedAreaList[i] + ubaList[currentFloor] 
				key[i]	=	key[i] + 1		
		#still checking if target has been reached
		for i in range(buildSections):
			if servedAreaList[i] &gt; tarAreaList[i] and servedAreaList[i] - tarAreaList[i] &gt;= ubaList[currentFloor] - ubaList[currentFloor]*boundaryFactor:
				servedAreaList[i] = servedAreaList[i] - ubaList[key[i]]
				ubaList[key[i]] = ubaList[key[i]] + bankArea[i] 
				for j in range(i+1,buildSections):
					servedAreaList[j] = servedAreaList[j] + bankArea[i] 
					key[i] = key[i] - 1
		tarAreaList = targetAreaCalculator(ubaList,buildSections)
		currentFloor += 1
	return [key,servedAreaList,tarAreaList,ubaList]
#-------------------------------------------------------------------------------------------------------------------------------------------
tarAreaList = 	targetAreaCalculator(grossBuildArea,buildSections)
keyFloors	=	keyFloorFinder()

keysTest = keyFloors[0]



count =0
for i in range(len(keysTest)):
	if keysTest[i] ==0: count += 1

if count &gt; len(keysTest)/2:
	for i in range(len(keysTest)):
		keysTest[i] = numFloors

keyFloors[0]	= 	keysTest
	


#Assign your output to the OUT variable
#OUT = keysTest#
OUT = keyFloors</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="e2042bb0-8b22-4aa4-b519-98480ec70f3d" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Gross Building Area" x="4024.33956144716" y="2040.48485237716" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="GBA;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="d61ada97-160e-4cc5-9377-0ea62127d10f" type="DSIronPythonNode.PythonNode" nickname="Feedback Function" x="5385.09438321196" y="4.99744828969867" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

ubaList 			= 	IN[0]
servedAreaList		=	IN[1]
numElevPerBank		=	IN[2]
ecap				=	IN[3]
buildSections		=	IN[4]

#--------------------------------------------------------------------------------------------------------------------

# to compute the efficiency of set elevator layouts------------------------------------------------------------------
def feedBack():
	#totBankCap	= [numElevPerBank[x]*ecap for x in range(buildSections)]
	#make a list of area for building sections
	sections	= [0 for x in range(buildSections)]
	sections[0] = servedAreaList[0] # first building section area
	#isolated building section areas  
	totBankCap = 0
	for i in range(1,buildSections):
		sections[i] = servedAreaList[i] - servedAreaList[i-1]
		# total elevator bank capacity
		totBankCap  +=numElevPerBank[i]*ecap	
	#total UBA
	ubaTotal = 0
	for i in range(len(ubaList)):
		ubaTotal 	+=ubaList[i]
	
	#percentage of uba served by every bank
	percentUBA_Bank	= [0 for x in range(buildSections)]
	#used capacity of the banks
	ucap			= [0 for x in range(buildSections)]
	# added to test errors
	if totBankCap ==0 : totBankCap  =1
	for i in range(buildSections):
		percentUBA_Bank[i] = (sections[i]*100)/ubaTotal
		ucap[i] = (sections[i]*100)/totBankCap
	
	
	return percentUBA_Bank,ucap
	#return ubaTotal,totBankCap
	
#--------------------------------------------------------------------------------------------------------------------	

out = feedBack()

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="1f734656-1cf4-4c79-ac60-f31b460bff82" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Number of Elev Per Bank" x="4083.70258329217" y="-153.820101462784" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="numberElevPerBank[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="2beb0bf4-f5d7-44c8-91f9-a8a1a413d450" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Boundary Factor" x="4091.20639990098" y="-57.0822593532507" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="boundaryFactor = 0.9;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="f4310a55-4c53-4646-8d44-a4f198fa380a" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Key Floors" x="4848.17084732804" y="90.6056531755679" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="keyFloors[0];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="c8373d8a-851e-4e55-ac8b-cff74640b57a" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Served Areas by Banks" x="4843.03139011526" y="-6.76975498565022" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="servedAreas[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="c23e9a7b-225e-40d2-b26d-d9b1be0e3316" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Target Areas for Banks" x="4842.20252231962" y="-96.4498722228672" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="targetAreas[2];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="9669aebe-ed53-47aa-9a1d-bc356d0580bb" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Updated UBA" x="4841.85503625031" y="-185.545338168216" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="updatedUBA[3];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="5ed402a7-b681-4ec5-92c3-4f15602c210e" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Ecap" x="4094.18379835686" y="30.4084545405217" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="ecap= 1000;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="69fbd0c3-ab9b-4c1b-9fe6-824966b589d8" type="DSIronPythonNode.PythonNode" nickname="Extruded Tech Rooms" x="8392.34775398303" y="-583.14828755887" isVisible="true" isUpstreamVisible="false" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floors		=	IN[0]
keyFloors	=	IN[1]
techRooms	=	IN[2]

extruded=[]
keyFloors.reverse()
lastFloor = keyFloors[0]
for i in range(len(techRooms)):
	flr = floors[lastFloor]
	cen = flr.EndPoint
	zVal= cen.Z
	crv = techRooms[i]
	ext = crv.Extrude(zVal)
	extruded.append(ext)

#Assign your output to the OUT variable
OUT = extruded</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="5d65b5cc-e8b5-4ff7-9eb3-6ee300e40102" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Other_Part Service Area" x="4009.4673182157" y="1165.69051032231" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0][1];" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="965529b5-5b27-4c42-941b-b8a8ca5b0c1a" type="Dynamo.Nodes.DSFunction" nickname="Geometry.Intersect" x="4009.82442436841" y="1579.81938934656" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Geometry.Intersect@Autodesk.DesignScript.Geometry.Geometry" />
    <DSIronPythonNode.PythonNode guid="8b49b492-b142-4d57-9a20-7e76fe56402f" type="DSIronPythonNode.PythonNode" nickname="Variable height : Elevators" x="8385.95709653447" y="-255.876663388594" isVisible="true" isUpstreamVisible="false" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floors		=	IN[0]
keyFloors	=	IN[1]
elevList	=	IN[2]

extruded=[]
keyFloors.reverse()
p1		=	Point.ByCoordinates(0,0,0);
p2		=	Point.ByCoordinates(0,0,100);
vec		=	Vector.ByTwoPoints(p1,p2)
for i in range(len(elevList)):
	flr = floors[keyFloors[i]]
	cen = flr.EndPoint
	zVal= cen.Z
	crv = elevList[i]
	geom=[]
	for j in range(len(crv)):
		ext	=	Curve.Extrude(crv[j],vec,zVal)		
		geom.append(ext)		
	extruded.append(geom)

#Assign your output to the OUT variable
OUT = extruded</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="f7ffaa2d-edb3-41ba-8ea0-33db2de8b74c" type="Dynamo.Nodes.DSFunction" nickname="Face.Edges" x="8670.38925741095" y="-431.200107905057" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Face.Edges" />
    <Dynamo.Nodes.DSFunction guid="5639114f-565c-4864-9ab2-5ffbd28b4946" type="Dynamo.Nodes.DSFunction" nickname="Edge.CurveGeometry" x="8897.92348883874" y="-432.150574807957" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Edge.CurveGeometry" />
    <DSIronPythonNode.PythonNode guid="e6088aed-cd01-4cea-b17d-b4d9d9b79fff" type="DSIronPythonNode.PythonNode" nickname="Same Height : Elevators" x="8390.64531342422" y="-407.301547382663" isVisible="false" isUpstreamVisible="false" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floors		=	IN[0]
keyFloors	=	IN[1]
elevList	=	IN[2]

extruded=[]
#keyFloors.reverse()
p1		=	Point.ByCoordinates(0,0,0);
p2		=	Point.ByCoordinates(0,0,100);
vec		=	Vector.ByTwoPoints(p1,p2)
zValList= []
for i in range(len(elevList)):
	flr = floors[keyFloors[i]]
	cen = flr.EndPoint
	zVal= cen.Z
	crv = elevList[i]
	geom=[]
	zValList.append(zVal)
	
mx = max(zValList)
	
for i in range(len(elevList)):
	crv = elevList[i]
	for j in range(len(crv)):
		ext	=	Curve.Extrude(crv[j],vec,mx)		
		geom.append(ext)		
	extruded.append(geom)


#Assign your output to the OUT variable
OUT = extruded</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="fc1df022-d893-4b5d-acd6-fa0152d38f15" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Floors Final" x="7930.80242510199" y="-386.911909627614" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="Floors_Final;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="1a6b4d4c-dc6d-4243-a7c3-1f882a9c95cd" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Total Elevator Expected" x="5378.36648857767" y="-259.502555034061" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="totElev_Expected;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" type="DSIronPythonNode.PythonNode" nickname="Service Core Components" x="3264.95489156627" y="1535.4275095372" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="10">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flr_Width			=	IN[0]
flr_Height			=	IN[1]
twr_Basept			=	IN[2]
num_passElev		=	IN[3][0]
num_servElev		=	IN[3][1]

passElev_Area		=	IN[4]
servElev_Area		=	IN[4]
tag					=	IN[5]
elevWidth			=	IN[6][0]
elevLength			=	IN[6][1]
restroomProp		=	IN[7]
techrmProp			=	IN[8]
liftLobbyWidth		=	IN[9]

cirProp = liftLobbyWidth/1.5
FACTOR = 1
perc = 1.2
#passElev_Area 		*=	FACTOR
#servElev_Area		*=	FACTOR

#globals var, computer area banks, area restrm, area techrms--------------------------------------------------------------------------------------------
area_banks			= servElev_Area*num_servElev/perc + passElev_Area*num_passElev/perc
area_banks			+=cirProp*area_banks # added the circulation area
area_restroom 		= restroomProp*area_banks;								
area_servmodule 	= techrmProp*area_banks;




#computer service core width, length, and serviceCore====================================================================================================
def serviceCoreMaker():		
	#calc total area for service core for the tower
	serviceCore_Area 	= area_banks + area_restroom + area_servmodule;	
	#calc aspect ratio of floor plate
	aspect_Ratio 		= 	flr_Width/flr_Height
	#calc service core length and width
	servCore_Length 	=	math.sqrt(serviceCore_Area/aspect_Ratio)
	servCore_Width		=	serviceCore_Area/servCore_Length
	
	# get the coordinates of center pt
	x,y,z 					= 	twr_Basept.X,twr_Basept.Y,twr_Basept.Z	
	#make the service core rectangle object--------------------------------------------------------------------------------------------------------------1
	cs					= 	CoordinateSystem.ByOrigin(x,y,z)
	serviceCore_Rec 	= 	Rectangle.ByWidthHeight(cs,servCore_Width,servCore_Length)
	coreVertices		=	serviceCore_Rec.Points
	
	#comput elev bank factor--------------------------------------------------------------------
	b_Fac				=	area_banks/serviceCore_Area
	#return serviceCore_Rec,b_Fac,coreVertices,area_banks,area_banks,area_servmodule
	return servCore_Width,servCore_Length,coreVertices,b_Fac,serviceCore_Rec



#function to make boxes based off of width, length and vertices===========================================================================================
def makeBox(width,length,vertices,factor,tag):
	#calculate the shorter of width or height of service core
	if ( tag == 0):
		if (width &lt; length):
			new_Length 		=	length
			new_Width		=	factor*width
			other_Length 	=	length
			other_Width		=	width - new_Width
			index			=	3		
		else:
			new_Width		=	width	
			new_Length		=	factor*length
			other_Width 	=	width
			other_Length	=	length - new_Length
			index			=	2
	else:
		if (width &gt; length):
			new_Length 		=	length
			new_Width		=	factor*width
			other_Length 	=	length
			other_Width		=	width - new_Width
			index			=	3		
		else:
			new_Width		=	width	
			new_Length		=	factor*length
			other_Width 	=	width
			other_Length	=	length - new_Length
			index			=	2		

	
	cs1					= 	CoordinateSystem.ByOrigin(vertices[0].X,vertices[0].Y,0)
	cs2					= 	CoordinateSystem.ByOrigin(vertices[index].X,vertices[index].Y,0)
	# to make the primary rectangle ----------------------------------------------------------------------	
	new_Rec 			= 	Rectangle.ByWidthHeight(cs1,new_Width,new_Length)	
	new_Vec				= 	Vector.ByTwoPoints(new_Rec.Points[0],vertices[0])
	new_Rec				=	Geometry.Translate(new_Rec, new_Vec)
	ptsnew_Rec			=	new_Rec.Points
	# to make the secondary rectangle ----------------------------------------------------------------------	
	other_Rec 			= 	Rectangle.ByWidthHeight(cs2,other_Width,other_Length)	
	other_Vec			= 	Vector.ByTwoPoints(other_Rec.Points[index],vertices[index])
	other_Rec			=	Geometry.Translate(other_Rec, other_Vec)
	ptsother_Rec		=	other_Rec.Points
	
	return [new_Rec,other_Rec]
#============================================================================================================================================================



#make post computations======================================================================================================================================
def coreConfigurator(b_Fac):
	#make the elevator bank rectangle object-----------------------------------------------------1	
	bank_Rec			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)	
	widtry1				=	bank_Rec[0].Width
	lentry1				=	bank_Rec[0].Height
				
	# code to readjust the bank rectangle piece based on the final tech rooms and restroom blocks
	if ( widtry1&lt;lentry1):
		shortEdge		=	widtry1
		marked			=	0	
	else:
		shortEdge		=	lentry1
		marked			=	1
			
	if (elevWidth&lt;elevLength):elevEdge = elevWidth
	else:elevEdge =	elevLength			
	numE				=	int(shortEdge / elevEdge)
	numE				+=	1
		
	newDim				=	numE*elevEdge
	if ( marked ==0): ratio	= widtry1/newDim
	else: ratio	= lentry1/newDim
	b_Fac				=	ratio*b_Fac
	bank_Rec			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)	
	return bank_Rec
	#-------------------------------------------------------------------------------------------------
#============================================================================================================================================================


#OUTPUT VALUES-------------------------------------------------------
vals 				= 	serviceCoreMaker()
servCore_Width		=	vals[0]
servCore_Length		=	vals[1]
coreVertices		=	vals[2]
b_Fac				=	vals[3]
serviceCore_Rec		=	vals[4]
bank_Rec 			= 	coreConfigurator(b_Fac)	

#Assign your output to the OUT variable
OUT = [bank_Rec,area_restroom,area_servmodule,serviceCore_Rec]
#OUT = 0</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="7a52859d-1b63-4175-941c-d818a21ef584" type="DSIronPythonNode.PythonNode" nickname="LATEST : New Elevator Packings" x="4562.27093408153" y="1734.35474169118" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="7">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRec		=	IN[0]
elevWidth	=	IN[1][0]
elevLength	=	IN[1][1]
totElev		=	IN[2]
lobbyWidth	=	IN[3]
servicRec	=	IN[4]
interLine	=	IN[5][0]
maxElevs	=	IN[6]



commonLen	=	interLine.Length
otherLen1	=	0
bankRec 	= 	mainRec
if (commonLen &gt; mainRec.Width-0.005 and commonLen &lt; mainRec.Width+0.005): otherLen1 = mainRec.Height
if (commonLen &gt; mainRec.Height-0.005 and commonLen &lt; mainRec.Height+0.005): otherLen1 = mainRec.Width





#FIRST CALLS **********************************************************************************************************************************FIRST CALLS
#to calc how many sub rectangles the elevbankrect needs to be split-------------------------
def getNumRects():
	#very imp transition@@@@@@@@@@@
	recShort	=	otherLen1
	recLong		=	commonLen	
	elevShort	=	getElevShorterDim(elevWidth,elevLength)[0]
	numRects	=	1	
	approx_numElevs	=	int(math.floor(recLong/elevShort))

	#Added to make total num of Elevs always even
	if approx_numElevs%2 &gt; 0: approx_numElevs += 1
	#-----------------------------------------------		
	elevShort 	=	recLong/approx_numElevs		
	while approx_numElevs &gt; maxElevs:
		numRects += 1
		approx_numElevs = int(approx_numElevs/2	)	
	return numRects
#------------------------------------------------------------------------------------------

#to subdivide given rect to num of rects based on a num------------------------------------
def subDivRect(num):	
	numRects = getNumRects()
	numRects = num
	if numRects &lt; 2 : 
		return "no need to split"
	
	recList = []
	length1 = commonLen
	length2 = otherLen1
	
	dimension = length1/numRects

	startRec = mainRec
	for i in range(numRects):		
		try:
			rec = splitBox(startRec,dimension,length2)
		except:
			recList.append(rec[1])
			return recList			
		recList.append(rec[0])		
		startRec = rec[1]			
	return recList
#------------------------------------------------------------------------------------------

#function to scale rectangles to add in corridors in between elevators-------------------------------------------------------------
def scaledRects(recLists):
	#make new recLists
	newRecs = recLists[:]
	del newRecs[0]
	del newRecs[-1]
	
	endRecs = [recLists[0],recLists[-1]]
	
	outRec=[]
	for rec in newRecs:
		pts = rec.Points
		basePt = pts[0]
		wid = rec.Width
		length = rec.Height
		
		l1 = Line.ByStartPointEndPoint(pts[0],pts[1])
		l2 = Line.ByStartPointEndPoint(pts[0],pts[3])
		
		len1 = l1.Length
		len2 = l2.Length
		fac = 0.75 # hardcoded
		
		#prepare basept, p1 and p2 from Scale1D
		if wid == len1: 
			fromPt = pts[1]
			toPt = l1.PointAtParameter(fac)
			midPt = l1.PointAtParameter(0.5)
		else: 
			fromPt = pts[3]
			toPt = l2.PointAtParameter(fac)
			midPt = l2.PointAtParameter(0.5)
		
		#find the vector to translate the scaled rect		
		pCrv = rec.Scale1D(basePt,fromPt,toPt)
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]
			
		lNew1 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[1])
		lNew2 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[3])
			
		if wid == len1: midPtNew = lNew1.PointAtParameter(0.5)
		else: midPtNew = lNew2.PointAtParameter(0.5)
			
			
		#make the vec for translation
		vec= Vector.ByTwoPoints(midPtNew,midPt)
		pCrv = pCrv.Translate(vec)
		
		#block to make rectangle
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]		
		rec = Rectangle.ByCornerPoints(ptsNew[0],ptsNew[3],ptsNew[2],ptsNew[1])
		outRec.append(rec)
			
		
	#code to work on the first and last rectangles.	
	for i in range(len(endRecs)):
		if (i==0):pass
		rec = endRecs[i]
		
		pts = rec.Points
		basePt = pts[0]
		wid = rec.Width
		length = rec.Height
		
		l1 = Line.ByStartPointEndPoint(pts[0],pts[1])
		l2 = Line.ByStartPointEndPoint(pts[0],pts[3])
		
		len1 = l1.Length
		len2 = l2.Length
		fac = 0.9 # hardcoded
		
		#prepare basept, p1 and p2 from Scale1D
		if wid == len1: 
			fromPt = pts[1]
			toPt = l1.PointAtParameter(fac)
			midPt = l1.PointAtParameter(0.5)
		else: 
			fromPt = pts[3]
			toPt = l2.PointAtParameter(fac)
			midPt = l2.PointAtParameter(0.5)
		
		
		
		#find the vector to translate the scaled rect		
		pCrv = rec.Scale1D(basePt,fromPt,toPt)
		crv = pCrv.Curves()
		if(i&gt;0):
			ptsNew = [x.StartPoint for x in crv]
			
			lNew1 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[1])
			lNew2 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[3])
			
			if wid == len1: midPtNew = lNew1.PointAtParameter(fac/2)
			else: midPtNew = lNew2.PointAtParameter(fac/2)
		
			#make the vec for translation
			vec= Vector.ByTwoPoints(midPtNew,midPt)
			pCrv = pCrv.Translate(vec)

		#block to make rectangle
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]		
		rec = Rectangle.ByCornerPoints(ptsNew[0],ptsNew[3],ptsNew[2],ptsNew[1])
		
		endRecs[i] = rec
		#break	
		
		
	#finally merge all components
	finList=[]		
	finList.extend([endRecs[0]])
	finList.extend(outRec)
	finList.extend([endRecs[-1]])
		
	return finList
#-----------------------------------------------------------------------------------------------------------------------------------
#FIRST CALLS **********************************************************************************************************************************FIRST CALLS

#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------

#get the shorter dimension---------------------------------------------------------------
def getElevShorterDim(width,length):
	if(width&lt;length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge = length
		longEdge  = width
	return shortEdge,longEdge
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------

#====================================================================================================================================================================================
#make rects based on dimension given------------------------------------------------------------------------
def splitBox(rec,dim,length):
	recPts	=	rec.Points
	#make four lines for the input rectangles
	lin0		=	Line.ByStartPointEndPoint(recPts[0],recPts[1])#0
	lin1		=	Line.ByStartPointEndPoint(recPts[1],recPts[2])#1
	lin2 		=	Line.ByStartPointEndPoint(recPts[2],recPts[3])#2
	lin3		=	Line.ByStartPointEndPoint(recPts[3],recPts[0])#3
	# get the first point of first line
	firstPt		=	lin0.StartPoint
	
	# get the length and lines for those edges whose length matches input length
	if lin0.Length &gt;= length-0.005 and lin0.Length &lt;= length+0.005: 
		bigDimension = lin1.Length
		lineShort1 = lin1
		lineShort2 = lin3				
	if lin1.Length &gt;= length-0.005 and lin1.Length &lt;= length+0.005: 
		bigDimension = lin0.Length
		lineShort1 = lin0
		lineShort2 = lin2
	
	#get the points to make the two rectangles
	f1 		=	dim/bigDimension
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	rec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	rec2	=	Rectangle.ByCornerPoints(ptOut1,ptOut2,stPt2,endPt1)
	#get the center points for two rects
	rec1Cen	=	rec1.Center()
	rec2Cen = 	rec2.Center()
	#get the vectors from the first pt
	vec1	=	Vector.ByTwoPoints(firstPt,rec1Cen)
	vec2	=	Vector.ByTwoPoints(firstPt,rec2Cen)
	#compare the length of the vectors to get how far are they from start pt
	vcLen1 	=	vec1.Length
	vcLen2 	=	vec2.Length
	#finally set them as the final ouput rect
	if vcLen1 &lt; vcLen2 :
		outRec1 = 	rec1
		outRec2 = 	rec2
	else:
		outRec1 = 	rec2
		outRec2 = 	rec1	
			
	return outRec1,outRec2
	
	
#main function making the elevator packings------------------------------------------------
def makeElevBox(bkRec,commonLen,otherLen1):
	inpRec = []
	inpRec.append(bkRec)

	elevDims	=	getElevShorterDim(elevWidth,elevLength)
	elevShort	=	elevDims[0]
	elevLong	=	elevDims[1]
	
	longCounter = 	0
	listDims	=	[]
	frstPtList	=	[]
	count		=	0
	
	#very imp transition@@@@@@@@@@@
	recShort	=	otherLen1
	recLong		=	commonLen
		
	numElevs	=	int(math.floor(recLong/elevShort))
	#"""
	#Added to make total num of Elevs always even
	if numElevs%2 &gt; 0: 
		numElevs += 1
		#elevShort = recLong/numElevs
	#-----------------------------------------------

	elevShort 	=	recLong/numElevs	
	areaElev 	=	elevShort*commonLen

	
	
	cap = 5		
	#BLOCK TO MAKE LIST OF DIMENSIONS TO PREPARE ELEV ROWS AND LOBBY PLACEMENTS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	#loop till you catch up with the dimension longitudinally
	while (cap&gt;0):
		longCounter += elevLong
		if (longCounter &gt; recShort): # recShort replaced by otherLen   +++ longCounter &gt; recShort-0.005 and longCounter &lt; recShort+0.005
			break
		listDims.append(elevLong)
		if (count%2 ==0):
			longCounter += lobbyWidth	
			if (longCounter &gt; recShort):# recShort replaced by otherLen
				break
			listDims.append(lobbyWidth)			
		count		+= 1
	ct = 0
	lobbies = 0
	# test to check whole length added
	for i in range(len(listDims)):
		ct += listDims[i]
		if (listDims[i] == lobbyWidth):
			lobbies += 1
	#if lobbies == 0: lobbies =1
	#get the left over space
	leftOver =  recShort - ct
	perBayAdd=  leftOver/lobbies
	perBayAdd+=	0.002
	
	# distribute it to the lift lobbies
	if (perBayAdd &gt; 0):
		for i in range(len(listDims)):
			if (listDims[i] == lobbyWidth):
				listDims[i] += perBayAdd + 0.002
	
	#added to make sure the total dimension not exceeding
	if sum(listDims)&gt;otherLen1:
		extra = sum(listDims)-otherLen1
		listDims[-1] -= extra
	
	recLists = []
	stRec	 = bkRec

	index1 = 0
	index2 = 1
	longDim = getShorterDim(servicRec)[1]
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	
	str =""
	prnList=[]
	#BLOCK TO MAKE ELEVATOR ROWS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	for i in range(len(listDims)-1):		
		try:
			rec = splitBox(stRec,listDims[i],commonLen)		
			prnList.append("DID IT")
		except:
			#nRec = stRec.Reverse
			#rec = splitBox(nRec,listDims[i],commonLen)	
			str =  "Not Done"
			prnList.append("FAILED")
			#continue
		recLists.append(rec[0])
		#frstPtList.append(rec[2])
		stRec = rec[1]
		if (i==len(listDims)-2): 
			recLists.append(rec[1])
			prnList.append("LAST CASE")
			#break
	
	#make the list of elevator row first
	elevRowLists = []
	copRecLists =  []
	str = "dont know"
	strN= ""
	for i in range(len(recLists)):
		if i ==0: dimA = listDims[i+1]		
		#if dimA != listDims[i]: copRecLists.append(recLists[i])		

		if i != 0 and dimA !=listDims[i-1] and i == len(recLists)-1 : 
			pass
		elif dimA != listDims[i]: copRecLists.append(recLists[i])
			
		#copRecLists = list(recLists[i] if dimA == listDims[i]:)
	
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	
	#BLOCK TO PLACE ELEVATOR BOXES IN THE ROWS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	str2 = ""
	recElevs=[]
	recElevsRow=[]
	for i in range(len(copRecLists)):
		stRec = copRecLists[i]
		elevRow=[]
		shorter = getShorterDim(stRec)[0]
		for j in range(int(numElevs)-1):		
			try:
				rec = splitBox(stRec,elevShort+0.0002,shorter)				
			except:
				#continue
				stt = ""
			stRec = rec[1]
			elevRow.append(rec[0])
			if j==int(numElevs)-2: 
				elevRow.append(rec[1])
			
			#frstPtList.append(rec[2])
			recElevs.append(rec)
			str2 =  " all added" 
		recElevsRow.append(elevRow)
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	totalElev = [len(x) for x in recElevsRow]
	sumtotalElev = sum(totalElev)
	#return recLists,listDims,recDims[0],copRecLists,recElevs,len(recElevs)
	return recElevsRow


def mainCode():
	numRc = getNumRects()
	if numRc &gt;=2:
		aRects = subDivRect(getNumRects())
		subRects = scaledRects(aRects)
	else:
		subRects = [mainRec]

	outL = []
	strList=[]
	for i in range(numRc):
		
		bankRec = subRects[i]
		comLen = interLine.Length/numRc
		
		# set commonLength and otherLength
		if (comLen == bankRec.Width): 
			otrLen = bankRec.Height
		elif (comLen == bankRec.Height): 
			otrLen = bankRec.Width
		elif (bankRec.Width&lt;bankRec.Height):
			comLen = bankRec.Width
			otrLen = bankRec.Height
		else:
			comLen = bankRec.Height
			otrLen = bankRec.Width
				
		out = makeElevBox(bankRec,comLen,otrLen)
		outL.append(out)
	return outL
	

#aRects = subDivRect(getNumRects())
#outL = scaledRects(aRects)
outL = mainCode()
#Assign your output to the OUT variable
#OUT = out,numRc,subRects,bankRec
OUT = outL
</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="bec4aee5-3a30-4c24-999d-f9f353df762d" type="DSIronPythonNode.PythonNode" nickname="OneList" x="4888.6422308473" y="1741.16208970263" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

listElevs = IN[0]
interLine = IN[1]





#make one list of the whole elev sublists---------------------------------
def oneList():
	return [z for x in listElevs for y in x for z in y]
#-------------------------------------------------------------------------


#to get the sorted elevs based on distance from closest point to the intersect line---------------------------------------------------------------------
def newSortElevs():
	sortedRect=[]
	avgRecList=[]
	recList = oneList()
	closePtList =[]	
	distList = []
	for i in range(len(recList)):
		recPt = recList[i].Center()		
		closePt = Geometry.ClosestPointTo(interLine[0],recList[i])
		closePtList.append(closePt)
		dist = Line.ByStartPointEndPoint(closePt,recPt).Length
		distList.append(dist)
	
	copyRecList = recList[:]
	sortedDistList = distList[:]
	sortedDistList.sort()
	
	for i in range(len(recList)):
		sortDis = sortedDistList[i]
		for j in range(len(copyRecList)):
			if sortDis == distList[j]:
				found = copyRecList[j]
				del copyRecList[j]
				del distList[j]
				break
		sortedRect.append(found)
	#return distList,sortedDistList,recList,sortedRect,copyRecList
	return sortedRect
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#calc number of elev per row---------------------------------------------------------------------------------------------------------------------------------
def numElevsperRow():
	for i in range(len(listElevs)):
		x = len(listElevs)
		y = len(listElevs[0][0])
		val = x*y
		break
	return val
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#make one list into lists as per rows of elev----------------------------------------------------------------------------------------------------------------
def makeListRow():
	numElevsRow = numElevsperRow()
	sortedElevList = newSortElevs()
	
	#create list of elevators who are combined together per row.
	num = int(len(oneList())/numElevsRow)
	megaList=[]	
	for i in range(num):
		x = i*numElevsRow
		alist = []
		for j in range(x,x+numElevsRow):			
			alist.append(sortedElevList[j])
		megaList.append(alist)
	return megaList
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#sort the rows based on the start point of instersect line--------------------------------------------------------------------------------------------------
def sortSecondRun():
	rowElevList = makeListRow()
	stPoint = interLine[0].PointAtParameter(0)

	# get the distance list for each row
	fullDistance=[]
	for i in range(len(rowElevList)):
		recList = rowElevList[i]
		disList=[]		
		for j in range(len(recList)):
			rec = recList[j]
			dist = Line.ByStartPointEndPoint(stPoint,rec.Center()).Length
			disList.append(dist)
		fullDistance.append(disList)
	
	
	#sort the distance list
	sortedDistList = fullDistance[:]
	copyElevs = rowElevList[:]
	for i in range(len(sortedDistList)):
		sortedDistList[i] = fullDistance[i][:]
		copyElevs[i] = rowElevList[i][:]
		sortedDistList[i].sort()
	
	#make the new recLists sorted
	for i in range(len(rowElevList)):
		recList = rowElevList[i]
		sortList = sortedDistList[i]
		distList1 = fullDistance[i]
				
		for j in range(len(sortList)):
			rec = recList[j]
			sortdis = sortList[j]
			newRec=[]
			for k in range(len(sortList)):
				if float(sortdis) == float(distList1[k]):
					rowElevList[i][j] = copyElevs[i][k]					
					break
	rev = []
	for i in range(len(rowElevList)):
		rev.append(rowElevList[-i])
	#return fullDistance,rowElevList,distList1,sortedDistList
	return rowElevList
#-----------------------------------------------------------------------------------------------------------------------------------------------------------


#Assign your output to the OUT variable
#OUT = oneList(),out,makePts(),scaleVals(),newSortElevs(),numElevsperRow(),sortSecondRun()
OUT = sortSecondRun()</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="50ffe0eb-eeb0-4540-90ba-2b6f88b31d2e" type="DSIronPythonNode.PythonNode" nickname="Final Num Elevators" x="5383.93453480988" y="-145.841961997254" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

rectList = IN[0]

x = len(rectList)*len(rectList[0])


#Assign your output to the OUT variable
OUT = x</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="734c4bd1-79dd-41fa-94f6-e7853f1a881d" type="DSCoreNodesUI.Input.IntegerSlider" nickname="Max Elevators" x="-796.318013712032" y="400.265118407746" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>5</System.Int32>
      <Range min="2" max="33" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <Dynamo.Nodes.DSFunction guid="332db295-1b29-4933-9aac-9a412a0b81e6" type="Dynamo.Nodes.DSFunction" nickname="List.Count" x="7938.50576892997" y="-481.344916872279" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.List.Count@var[]..[]" />
    <Dynamo.Nodes.DSFunction guid="14e09fad-698e-4292-89b6-9941d7862d78" type="Dynamo.Nodes.DSFunction" nickname="CSV.WriteToFile" x="10131.0032750502" y="-364.789926208602" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.IO.CSV.WriteToFile@string,var[][]" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="d5245f2f-c0b0-4ea7-b8f4-5f2cb77f448e" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="File Location" x="9700.89207734891" y="-388.698145056784" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a={&quot;c:\write_Elevators.csv&quot;};" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="3dbf6543-eae7-48b0-9ef2-9073edb58861" type="DSIronPythonNode.PythonNode" nickname="PointFinder" x="9696.52554458841" y="-293.292003703125" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

vertexList = IN[0]
tupleList = []
for i in range(len(vertexList)):
	ver = vertexList[i]
	for j in range(len(vertexList[i])):
		ver2 = ver[j]
		for k in range(len(ver2)):
			tup = (ver2[k].PointGeometry.X,ver2[k].PointGeometry.Y,ver2[k].PointGeometry.Z)
			tupleList.append(tup)


		


#Assign your output to the OUT variable
OUT = tupleList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="5cc01002-4f78-47d5-8f54-af496dcb6cf7" type="Dynamo.Nodes.DSFunction" nickname="Face.Vertices" x="8667.89953124464" y="-339.798009860657" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Face.Vertices" />
    <Dynamo.Nodes.DSFunction guid="82a78431-e853-4bf9-8bc8-eb19694c9184" type="Dynamo.Nodes.DSFunction" nickname="Face.Vertices" x="8668.50064319371" y="-524.510223685607" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Face.Vertices" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="be8d5938-96b4-48da-b5c9-dad8ac28d520" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="File Location" x="9700.90002282811" y="-485.369588573515" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a={&quot;c:\write_ServiceModule.csv&quot;};" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="06a1487f-2d65-420b-b543-cae85229585e" type="DSIronPythonNode.PythonNode" nickname="PointFinder" x="9703.10302978751" y="-573.135269692135" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

vertexList = IN[0]
tupleList = []
for i in range(len(vertexList)):
	ver = vertexList[i]
	for j in range(len(vertexList[i])):
		tup = (ver[j].PointGeometry.X,ver[j].PointGeometry.Y,ver[j].PointGeometry.Z)
		tupleList.append(tup)


		


#Assign your output to the OUT variable
OUT = tupleList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="5cb555d1-d237-4710-8da6-b56108d83415" type="Dynamo.Nodes.DSFunction" nickname="CSV.WriteToFile" x="10130.9191686881" y="-487.981482902192" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.IO.CSV.WriteToFile@string,var[][]" />
    <DSIronPythonNode.PythonNode guid="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" type="DSIronPythonNode.PythonNode" nickname="Irregular Shape Maker" x="1438.33469258346" y="-3674.27373219374" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


x = IN[0]
y = IN[1]
lenX = IN[2]
lenY = IN[3]
type = int(IN[4])

pt = Point.ByCoordinates(x,y,0)

#find the closest point from a point-------------------------------------------------------------------------------------	
def closestPoint(ptA,ptList):
	shortLen	=	100000000000000 # set as a really high value
	index		=	0
	for i in range(len(ptList)):
		vec				= 	Vector.ByTwoPoints(ptA,ptList[i])
		vecLen			=	vec.Length
		if ( vecLen &lt; shortLen ):
			shortLen	=	vecLen
			index		=	i
	# returns the closest point to ptA from the list
	return ptList[index]
#------------------------------------------------------------------------------------------------------------------------

#function which makes l shaped profile-----------------------------------------------------------------------------------
def shapeMaker():
	linList = []
	ptList = []
	
	ptX = Point.ByCoordinates(200000,0,0)
	ptY = Point.ByCoordinates(0,200000,0)
	
	xvec = Vector.ByTwoPoints(pt,ptX)
	yvec = Vector.ByTwoPoints(pt,ptY)
	xvecN = xvec.Reverse()
	yvecN = yvec.Reverse()
	a = int(lenX/2)
	b = int(lenY/3)
	len = [lenX,a,b,lenY-a,lenX-b,lenY]
	dir = [0,0,1,0,1,1]
	point = pt
	ptList.append(point)
	for i in range(6):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon = Polygon.ByPoints(ptList)
	polyCenter = polygon.Center()
	closePt = closestPoint(polyCenter,ptList)
	return polygon,closePt
#---------------------------------------------------------------------------------------------------------------------------


def typeListMaker():
	if type == 1:		
		len = [lenX,lenY,lenX,lenY]
		dir = [0,0,1,1]
		sides = 4		
	if type == 2:
		a = int(lenX/2)		
		b = int(lenY/3)			
		len = [lenX,a,b,lenY-a,lenX-b,lenY]
		dir = [0,0,1,0,1,1]
		sides = 6
	if type == 3:		
		a1 = int(lenX/3)
		a2 = int(lenX/4)
		b = int(lenY/2)	
		len = [lenX,lenY,a1,b,a2,b,lenX-a1-a2,lenY]
		dir = [0,0,1,1,1,0,1,1]
		sides = 8
	if type == 4:
		len = [lenX,lenY,lenX,lenY]
		dir = [0,0,1,1]
		sides = 4	
	return len,dir,sides


#function which makes l shaped profile-----------------------------------------------------------------------------------
def shapeGenerator():
	linList = []
	ptList = []
	
	ptX = Point.ByCoordinates(200000,0,0)
	ptY = Point.ByCoordinates(0,200000,0)
	
	xvec = Vector.ByTwoPoints(pt,ptX)
	yvec = Vector.ByTwoPoints(pt,ptY)
	xvecN = xvec.Reverse()
	yvecN = yvec.Reverse()
	a = int(lenX/2)
	b = int(lenY/3)
	
	#len = [lenX,a,b,lenY-a,lenX-b,lenY]
	#dir = [0,0,1,0,1,1]
	#sides = 6
	 
	len = typeListMaker()[0]
	dir = typeListMaker()[1]
	sides = typeListMaker()[2]
	
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon = Polygon.ByPoints(ptList)
	polyCenter = polygon.Center()
	closePt = closestPoint(polyCenter,ptList)
	return polygon,closePt
#---------------------------------------------------------------------------------------------------------------------------



#function which makes  shaped profile---------------------------------------------------------------------------------------
def shapeGenType4():
	linList = []
	ptList = []
	
	ptX = Point.ByCoordinates(200000,0,0)
	ptY = Point.ByCoordinates(0,200000,0)
	
	xvec = Vector.ByTwoPoints(pt,ptX)
	yvec = Vector.ByTwoPoints(pt,ptY)
	xvecN = xvec.Reverse()
	yvecN = yvec.Reverse()
		
	 
	len = typeListMaker()[0]
	dir = typeListMaker()[1]
	sides = typeListMaker()[2]
	
	#1st outer polygon===============================================================
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon = Polygon.ByPoints(ptList)
	polyCenter = polygon.Center()
	closePt = closestPoint(polyCenter,ptList)
	#================================================================================
	a = lenX/1.8
	b = lenY/2.2
	len[0] = len[0] - a
	len[1] = len[1] - b
	len[2] = len[0]
	len[3] = len[1]
	
	linList = []
	ptList = []
	#inner polygon====================================================================
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon2 = Polygon.ByPoints(ptList)
	ptN = Point.ByCoordinates(pt.X+(a/2),pt.Y+(b/2))
	vecShift = Vector.ByTwoPoints(pt,ptN)
	polygon2 = polygon2.Translate(vecShift)
	#polyCenter = polygon.Center()
	#closePt = closestPoint(polyCenter,ptList)
	#================================================================================
	
	
	return [polygon,polygon2],closePt
#---------------------------------------------------------------------------------------------------------------------------


if type == 4: out = shapeGenType4()
else : out = shapeGenerator()

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="efff3d6a-f606-4582-82d1-85905dbdfcc6" type="DSCoreNodesUI.Input.IntegerSlider" nickname="LENX" x="-764.378955303969" y="-2634.192179044" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>77</System.Int32>
      <Range min="10" max="200" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSCoreNodesUI.Input.IntegerSlider guid="1d2ad207-efcd-4346-bc18-d610842890e4" type="DSCoreNodesUI.Input.IntegerSlider" nickname="LENY" x="-765.604267706489" y="-2575.27992096117" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>133</System.Int32>
      <Range min="10" max="200" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSCoreNodesUI.Input.IntegerSlider guid="7e591d2d-15b4-48f4-b9aa-178882d70914" type="DSCoreNodesUI.Input.IntegerSlider" nickname="TYPE" x="-765.766064330959" y="-2513.05563257136" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>4</System.Int32>
      <Range min="1" max="4" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSIronPythonNode.PythonNode guid="0357663c-1e1b-4eaa-a210-c4bff030a4ea" type="DSIronPythonNode.PythonNode" nickname="Box Maker" x="1848.50265887217" y="-3676.81344911727" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

polygon = IN[0][0]
closPt = IN[0][1]
type = IN[1]
if type!=4:
	polyPts = polygon.Points

#finds the opposite point to the closest point-------------------------------------------------
def oppPointFinder(poly,closPt):
	polyPts = poly.Points
	for i in range(len(polyPts)):
		if closPt == polyPts[i]:
			oppPt = polyPts[i-3]
			index = i
			break	
	return oppPt,index
#---------------------------------------------------------------------------------------------


#find the closest point from a point-------------------------------------------------------------------------------------	
def closestPoint(ptA,ptList):
	shortLen	=	100000000000000 # set as a really high value
	index		=	0
	for i in range(len(ptList)):
		vec				= 	Vector.ByTwoPoints(ptA,ptList[i])
		vecLen			=	vec.Length
		if ( vecLen &lt; shortLen ):
			shortLen	=	vecLen
			index		=	i
	# returns the closest point to ptA from the list
	return ptList[index]
#------------------------------------------------------------------------------------------------------------------------




#func to split the type3 polygon to regular rect and l shape rect-----------------------------
def multiRecMaker():
	oppPt = oppPointFinder(polygon,closPt)[0]
	id = oppPointFinder(polygon,closPt)[1]-3
	siz = len(polyPts)
	
	lin = Line.ByStartPointEndPoint(closPt,polyPts[id+4])
	lin = lin.Extend(300,lin.StartPoint)
	
	crvsPoly = polygon.Curves()
	for crvs in crvsPoly:		
		pt = Geometry.Intersect(lin,crvs)
		if pt != None:
			break
	ptListA = [polyPts[0],pt[0],polyPts[id+4],polyPts[id+5]]
	ptListB = [pt[0],polyPts[id-1],polyPts[id],polyPts[id+1],polyPts[id+2],polyPts[id+3]]
	polyA = Polygon.ByPoints(ptListA)	
	polyB = Polygon.ByPoints(ptListB)
	polyNew = recMakers(polyB)
	#return lin,oppPt,polyPts[id],crvsPoly,pt,polyA,polyB
	return polyA,polyNew[0],polyNew[1]
#----------------------------------------------------------------------------------------------	
	
	
def recFromType4():
	poly1 = polygon[0]
	poly2 = polygon[1]
	polyPts1 = poly1.Points
	polyPts2 = poly2.Points
	pt=[]
	
	lin1 = Line.ByStartPointEndPoint(polyPts2[0],polyPts2[1])
	lin1 = lin1.Extend(300,lin1.StartPoint)
	lin1 = lin1.Extend(300,lin1.EndPoint)
	
	lin2 = Line.ByStartPointEndPoint(polyPts2[2],polyPts2[3])
	lin2 = lin2.Extend(300,lin2.StartPoint)
	lin2 = lin2.Extend(300,lin2.EndPoint)
	
	crvsPoly1 = poly1.Curves()
	for crvs in crvsPoly1:
		ptInt = Geometry.Intersect(lin1,crvs)
		if len(ptInt) == 0:	continue
		else: pt.append(ptInt[0])
		
	ptList1 = [pt[0],pt[1],polyPts1[0],polyPts1[1]]
	polyA = Polygon.ByPoints(ptList1)	
	for crvs in crvsPoly1:		
		ptInt = Geometry.Intersect(lin2,crvs)
		if len(ptInt) == 0:	continue
		else: pt.append(ptInt[0])	
		
	ptList2 = [pt[3],pt[2],polyPts1[2],polyPts1[3]]
	polyB = Polygon.ByPoints(ptList2)
	
	ptList3 = [pt[2],pt[0],polyPts2[1],polyPts2[2]]
	polyC = Polygon.ByPoints(ptList3)
	
	ptList4 = [pt[3],pt[1],polyPts2[0],polyPts2[3]]
	polyD = Polygon.ByPoints(ptList4)
	return polyA,polyB,polyC,polyD
	
	
	
	
#func to convert polygon to a rectangle---------------------------------------------------
def polytoRect(poly):
	crvs = poly.Curves()
	polyPts = poly.Points
	polyCen = poly.Center()
	wid = Line.ByStartPointEndPoint(polyPts[0],polyPts[1]).Length
	ht = Line.ByStartPointEndPoint(polyPts[0],polyPts[3]).Length
	
	cs = CoordinateSystem.ByOrigin(polyCen)
	#rec = Rectangle.ByWidthHeight(cs,wid,ht)
	
	ptList=[]
	for i in range(len(crvs)-1):
		pt = crvs[i].StartPoint
		ptList.append(pt)	
	rec = Rectangle.ByCornerPoints(ptList)
	return rec
#-----------------------------------------------------------------------------------------

#makes two polygons for two places in the l shape---------------------------------------------
def recMakers(poly):
	#poly = multiRecMaker()[1]
	polyPts = poly.Points
	polyCen = poly.Center()
	
	closPt = closestPoint(polyCen,polyPts)
	 
	oppPt = oppPointFinder(poly,closPt)[0]
	id = oppPointFinder(poly,closPt)[1]-3
	line1 = Line.ByStartPointEndPoint(polyPts[id],polyPts[id+1])
	line2 = Line.ByStartPointEndPoint(polyPts[id-1],polyPts[id-2])
	dist = line2.Length	
	ptNew = line1.PointAtParameter(dist/line1.Length)
	
	ptListA = [polyPts[id],polyPts[id-1],polyPts[id-2],ptNew]
	ptListB = [ptNew,polyPts[id-3],polyPts[id-4],polyPts[id-5]]
	
	polyA = Polygon.ByPoints(ptListA)
	polyB = Polygon.ByPoints(ptListB)
	
	return polyA,polyB
#---------------------------------------------------------------------------------------------

if type==1: out = [polygon]
if type==2: out = recMakers(polygon)
if type==3: out = multiRecMaker()
if type==4: out = recFromType4()

recListFinal = [polytoRect(out[i]) for i in range(len(out)) ]
#Assign your output to the OUT variable
OUT = recListFinal
#OUT = recMakers()</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="3bc257be-1916-44f1-840a-1914121fe58f" type="DSCoreNodesUI.Input.IntegerSlider" nickname="X" x="-762.460477758639" y="-2765.55225600155" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>100</System.Int32>
      <Range min="50" max="200" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSCoreNodesUI.Input.IntegerSlider guid="42e2e29c-e839-421e-94cc-e8f46549e6f9" type="DSCoreNodesUI.Input.IntegerSlider" nickname="Y" x="-762.025840996459" y="-2701.83906243534" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>-164</System.Int32>
      <Range min="-200" max="-75" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSIronPythonNode.PythonNode guid="32c69937-d64e-4dcf-990e-4b3cb429fba4" type="DSIronPythonNode.PythonNode" nickname="Core Placer" x="2072.57302798983" y="-3750.52424567723" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type = IN[1]
inputLen = IN[2]
coreDim = IN[3]

#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	points = 	rec.Points
	diagDist = Line.ByStartPointEndPoint(points[0],points[2]).Length
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge,diagDist
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------


#makes the core rectangle based on number of req it has---------------------------------------------------------------------------------------
def makeCoreBox(rec,numCore,wid,ht,longEdge):
	coreList=[]
	cen = rec.Center()
	pts = rec.Points
	#when just need to place one core
	if numCore ==1:
		cs = CoordinateSystem.ByOrigin(cen)
		coreRec= Rectangle.ByWidthHeight(cs,wid,ht)
		coreList.append(coreRec)
	#when more than one core needs to be placed
	else:
		len1 = Line.ByStartPointEndPoint(pts[0],pts[1]).Length
		len2 = Line.ByStartPointEndPoint(pts[0],pts[3]).Length
		#find the longer edge and that line
		if len1 == longEdge:
			lin = Line.ByStartPointEndPoint(pts[0],pts[1])
		else:
			lin = Line.ByStartPointEndPoint(pts[0],pts[3])			
		linCen = lin.PointAtParameter(0.5)
		vec = Vector.ByTwoPoints(linCen,cen)
		linNew = lin.Translate(vec)
		#divide the line to get the points to place core		
		linNewLen = linNew.Length
		perDist = linNewLen/(numCore+1)
		ptPlaceList = []
		#prepare the pointlist
		for i in range(numCore):
			pt = linNew.PointAtDistance((i+1)*perDist)
			ptPlaceList.append(pt)
		#add the core rectangles on the points
		for i in range(numCore):
			cs = CoordinateSystem.ByOrigin(ptPlaceList[i])
			coreRec= Rectangle.ByWidthHeight(cs,wid,ht)
			coreList.append(coreRec)			
	return coreList
#---------------------------------------------------------------------------------------------------------------------------------------------

# function which places core boxes into the empty boxes----------------------------------------------------------------------------------------
def placeCoreBox(boxList):		
	shortEdgeList=[]
	longEdgeList=[]
	recList=[]
	ptCoreList=[]
	allCores=[]
	lenMeasure = inputLen
	wid = coreDim
	ht = coreDim
	for i in range(len(boxList)):
		rec = boxList[i]
		recList.append(rec)
		shortEdge = getShorterDim(rec)[0]
		longEdge = getShorterDim(rec)[1]
		diagDist = getShorterDim(rec)[2]
		if longEdge &gt; lenMeasure :
			numCore = int(math.ceil(longEdge/lenMeasure))	
			ptCoreList.append(numCore)
		else :
			numCore=1		
			ptCore = rec.Center()
			ptCoreList.append(ptCore)
		coreRecs = makeCoreBox(rec,numCore,wid,ht,longEdge)
		shortEdgeList.append(shortEdge)
		longEdgeList.append(longEdge)
		allCores.append(coreRecs)
	#return shortEdgeList,longEdgeList,recList,ptCoreList,allCores
	return allCores
#----------------------------------------------------------------------------------------------------------------------------------------------



out = placeCoreBox(emptyBox)
#Assign your output to the OUT variable
OUT = out
#OUT = polytoRect(emptyBox[0])</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="c767726c-a463-42f3-a084-b1c9411764b2" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Geometry Base Block" x="1846.04257279248" y="-3559.51274625738" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="fd117d31-8e65-4d23-9a95-094818c41d5e" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Floor Plan Heights" x="1465.98105424209" y="-3482.4845653265" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="b0172315-2e4b-4b5f-afd6-742508a24840" type="DSIronPythonNode.PythonNode" nickname="Floor Maker" x="2072.74395978032" y="-3574.77801189309" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

recList=IN[0]
floorHeights = IN[1]

#makes variable length floor height list-------------------------------------------------------------------------------------------
def variableFloorHeight(flrHtList):
	newFlrHtList = []
	for i in range(len(recList)):
		y = len(flrHtList)
		x = y/2
		a = int(random.uniform(x,y))
		flrTest = flrHtList[:a]
		newFlrHtList.append(flrTest)
	return newFlrHtList
#----------------------------------------------------------------------------------------------------------------------------------




#makes floors translate to given height list---------------------------------------------------------------------------------------
def floorTranslator(recList,flrHtList):
	newRecList = []
	ptA = Point.ByCoordinates(0,0,0)
	ptB = Point.ByCoordinates(0,0,100)
	vec = Vector.ByTwoPoints(ptA,ptB)
	for i in range(len(recList)):
		rec = recList[i]
		recNList=[]
		flrHeights = flrHtList[i]
		for j in range(len(flrHeights)):
			dist = flrHeights[j]
			newRec = rec.Translate(vec,dist)
			recNList.append(newRec)
		newRecList.append(recNList)
	return newRecList
#---------------------------------------------------------------------------------------------------------------------------------


flrNewHeights = variableFloorHeight(floorHeights)
out = floorTranslator(recList,flrNewHeights)

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="f9198390-fd0d-4551-a8b4-75754f686032" type="DSCoreNodesUI.Input.IntegerSlider" nickname="Random Height Generator" x="1682.88733837178" y="-3469.59624392746" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>31</System.Int32>
      <Range min="0" max="100" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <Dynamo.Nodes.DSFunction guid="af947995-a8ab-4eec-93f9-fc6c56ab9069" type="Dynamo.Nodes.DSFunction" nickname="Floor Surface" x="2071.32435240308" y="-3424.86238039989" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Surface.ByPatch@Autodesk.DesignScript.Geometry.Curve" />
    <DSIronPythonNode.PythonNode guid="c26787a5-8996-430f-bf36-58c23ae8114f" type="DSIronPythonNode.PythonNode" nickname="Core Extrusions" x="2075.64349082977" y="-3865.21348737076" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

coreRecList = IN[0]
flrSrfList = IN[1]



#to make volumes extruded to set heights--------------------------------------------------------
def coreExtruder(coreRecs):
	zValList=[]
	coreVolList = []
	testList = []
	for i in range(len(flrSrfList)):
		frlSrfL = flrSrfList[i]
		point = frlSrfL[-1].PointAtParameter(0.5)
		zVal = point.Z
		testList.append(frlSrfL[-1])
		zValList.append(zVal)
		#zValList.append(point)
	
	for i in range(len(coreRecs)):
		recL = coreRecs[i]
		recVols = []
		ext = zValList[i]+5
		for j in range(len(recL)):
			rec = recL[j]
			recExt = rec.Extrude(ext)
			recVols.append(recExt)
		coreVolList.append(recVols)
	
	return coreVolList,testList
#-----------------------------------------------------------------------------------------------
out = coreExtruder(coreRecList)
#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="a450c4e3-9c4c-40f1-9e07-ca41c64d6197" type="DSCoreNodesUI.Input.IntegerSlider" nickname="CORE FREQ" x="-765.892035854969" y="-2304.01441546006" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>41</System.Int32>
      <Range min="10" max="250" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSCoreNodesUI.Input.IntegerSlider guid="b99a7612-7f68-46bc-a6c5-12ecfc77cb88" type="DSCoreNodesUI.Input.IntegerSlider" nickname="CORE DIMENSION" x="-770.541905681179" y="-2223.9289132272" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Int32>15</System.Int32>
      <Range min="5" max="25" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <Dynamo.Nodes.CodeBlockNodeModel guid="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Core Dimension" x="-769.929348999879" y="-2154.31915833962" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="(a+b)/15;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="1612be2e-2aea-4340-8229-12ae72ca4ac0" type="DSIronPythonNode.PythonNode" nickname="BuiltArea Blocks" x="2956.91796220664" y="-3539.46311206466" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floor_AreaSrf = IN[0]
totalAREA=[]
for i in range(len(floor_AreaSrf)):
	floor_Area = floor_AreaSrf[i]
	totalBuiltArea = sum(floor_Area)
	totalAREA.append(totalBuiltArea)



#Assign your output to the OUT variable
OUT = totalAREA,sum(totalAREA)</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="ed23a153-1f8a-4f82-8d8f-3ba531d6ba90" type="Dynamo.Nodes.DSFunction" nickname="GBA - Floor Area" x="2955.73672457785" y="-3648.72011066749" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Surface.Area" />
    <DSIronPythonNode.PythonNode guid="07a599e5-558f-4934-9cae-8527bb18e24c" type="DSIronPythonNode.PythonNode" nickname="BasePoint Maker" x="2955.69984710402" y="-3747.18612968301" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN
rectList = IN[0]

ptList= [x.Center() for x in rectList]
#Assign your output to the OUT variable
OUT = ptList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="fd6d25bd-d88d-4cf4-8782-f542af194703" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="BaseFloor Assets" x="2954.46670766903" y="-3830.87427393483" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="{a.Width,a.Height};" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="301c3934-46ff-4655-92a3-f9a47ae50ae3" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Elev Points" x="8897.59191794708" y="-340.123494997467" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a.PointGeometry;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="a239fc6e-d882-484b-9cb4-4bd033383935" type="DSIronPythonNode.PythonNode" nickname="Service Core Components" x="3295.91124579496" y="-3683.93172238167" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="11">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flr_WidthList		=	IN[0]
flr_HeightList		=	IN[1]
twr_BaseptList		=	IN[2]
num_passElev		=	IN[3][0]
num_servElev		=	IN[3][1]

passElev_Area		=	IN[4]
servElev_Area		=	IN[4]
tag					=	IN[5]
elevWidth			=	IN[6][0]
elevLength			=	IN[6][1]
restroomProp		=	IN[7]
techrmProp			=	IN[8]
liftLobbyWidth		=	IN[9]
corePtList			=	IN[10]




#compute service core width, length, and serviceCore====================================================================================================
def serviceCoreMaker(ptL):
	global area_banks, area_restroom,area_servmodule
	#calc total area for service core for the tower
	serviceCore_Area 	= area_banks + area_restroom + area_servmodule;
	serviceCore_Area	= serviceCore_Area/len(ptL)
	area_banks			= area_banks/len(ptL)
	area_restroom		= area_restroom/len(ptL)
	area_servmodule		= area_servmodule/len(ptL)
	
	servCore_WidthL = []
	servCore_LengthL = []
	coreVerticesL = []
	b_FacL =[]
	serviceCore_RecL = []
	for i in range(len(ptL)):
		pt = ptL[i]			
		#calc aspect ratio of floor plate
		aspect_Ratio 		= 	flr_Width/flr_Height
		
		#adjust aspectratio
		if aspect_Ratio &lt; 0.65 : aspect_Ratio = 0.75
		if aspect_Ratio &gt; 1.3 : aspect_Ratio = 1.2
		#calc service core length and width
		servCore_Length 	=	math.sqrt(serviceCore_Area/aspect_Ratio)
		servCore_Width		=	serviceCore_Area/servCore_Length	
		
		servCore_Width		=	math.sqrt(serviceCore_Area/aspect_Ratio)
		servCore_Length 	=	serviceCore_Area/servCore_Width	
		
		"""LATER MAKE AN ORIENT FUNCTION
		if len(ptL) == 1:
			#flipped width and length
			tm = servCore_Length
			servCore_Length = servCore_Width  
			servCore_Width = tm
		"""
		# get the coordinates of center pt
		x,y,z 					= 	pt.X,pt.Y,pt.Z	
		#make the service core rectangle object--------------------------------------------------------------------------------------------------------------1
		cs					= 	CoordinateSystem.ByOrigin(x,y,z)
		serviceCore_Rec 	= 	Rectangle.ByWidthHeight(cs,servCore_Width,servCore_Length)
		coreVertices		=	serviceCore_Rec.Points
		servCore_WidthL.append(servCore_Width)
		servCore_LengthL.append(servCore_Length)
		coreVerticesL.append(coreVertices)
		serviceCore_RecL.append(serviceCore_Rec)
	#comput elev bank factor--------------------------------------------------------------------
	b_Fac				=	area_banks/serviceCore_Area
	#return serviceCore_Rec,b_Fac,coreVertices,area_banks,area_banks,area_servmodule
	return servCore_WidthL,servCore_LengthL,coreVerticesL,b_Fac,serviceCore_RecL



#function to make boxes based off of width, length and vertices===========================================================================================
def makeBox(widthL,lengthL,verticesL,factor,tag):
	new_RecL=[]
	other_RecL=[]
	for i in range(len(widthL)):
		width = widthL[i]
		length = lengthL[i]
		vertices = verticesL[i]
		
		#calculate the shorter of width or height of service core
		if ( tag == 0):
			if (width &lt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2
		else:
			if (width &gt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2		
	
		
		cs1					= 	CoordinateSystem.ByOrigin(vertices[0].X,vertices[0].Y,0)
		cs2					= 	CoordinateSystem.ByOrigin(vertices[index].X,vertices[index].Y,0)
		# to make the primary rectangle ----------------------------------------------------------------------	
		new_Rec 			= 	Rectangle.ByWidthHeight(cs1,new_Width,new_Length)	
		new_Vec				= 	Vector.ByTwoPoints(new_Rec.Points[0],vertices[0])
		new_Rec				=	Geometry.Translate(new_Rec, new_Vec)
		ptsnew_Rec			=	new_Rec.Points
		# to make the secondary rectangle ----------------------------------------------------------------------	
		other_Rec 			= 	Rectangle.ByWidthHeight(cs2,other_Width,other_Length)	
		other_Vec			= 	Vector.ByTwoPoints(other_Rec.Points[index],vertices[index])
		other_Rec			=	Geometry.Translate(other_Rec, other_Vec)
		ptsother_Rec		=	other_Rec.Points
		
		new_RecL.append(new_Rec)
		other_RecL.append(other_Rec)
	
	return [new_RecL,other_RecL]
#============================================================================================================================================================



#make post computations======================================================================================================================================
def coreConfigurator(b_Fac):
	#make the elevator bank rectangle object-----------------------------------------------------1	
	bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
	bank_RecLNew = []
	for i in range(len(bank_RecL)):
		bank_Rec = 	bank_RecL[i]
		widtry1				=	bank_Rec[0].Width
		lentry1				=	bank_Rec[0].Height
				
		# code to readjust the bank rectangle piece based on the final tech rooms and restroom blocks
		if ( widtry1&lt;lentry1):
			shortEdge		=	widtry1
			marked			=	0	
		else:
			shortEdge		=	lentry1
			marked			=	1
				
		if (elevWidth&lt;elevLength):elevEdge = elevWidth
		else:elevEdge =	elevLength			
		numE				=	int(shortEdge / elevEdge)
		numE				+=	1
			
		newDim				=	numE*elevEdge
		if ( marked ==0): ratio	= widtry1/newDim
		else: ratio	= lentry1/newDim
		b_Fac				=	ratio*b_Fac
		#bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
		
	return bank_RecL
	#-------------------------------------------------------------------------------------------------
#============================================================================================================================================================


#iterate through all the blocks and output lists for each---------------------------------------------
outList=[]
bankRecList= []
otherRecList=[]
areaRestrmList=[]
areaServModList=[]
servCoreList=[]

perc = 1.1

for i in range(len(twr_BaseptList)):

	flr_Width  = flr_WidthList[i]
	flr_Height = flr_HeightList[i]
	twr_Basept = twr_BaseptList[i]
	corePts	   = corePtList[i]
	
	#globals var, computer area banks, area restrm, area techrms--------------------------------------------------------------------------------------------
	cirProp = liftLobbyWidth/1.5
	
	area_banks			= servElev_Area*num_servElev[i]/perc + passElev_Area*num_passElev[i]/perc
	area_banks			+=cirProp*area_banks # added the circulation area
	area_restroom 		= restroomProp*area_banks								
	area_servmodule 	= techrmProp*area_banks
	
	
	#OUTPUT VALUES-------------------------------------------------------
	vals 				= 	serviceCoreMaker(corePts)
	servCore_Width		=	vals[0]
	servCore_Length		=	vals[1]
	coreVertices		=	vals[2]
	b_Fac				=	vals[3]
	serviceCore_Rec		=	vals[4]
	bank_Rec 			= 	coreConfigurator(b_Fac)	
	
	bankRecList.append(bank_Rec[0])
	otherRecList.append(bank_Rec[1])
	areaRestrmList.append(area_restroom)
	areaServModList.append(area_servmodule)
	servCoreList.append(serviceCore_Rec)
	
	

out = bankRecList,otherRecList,areaRestrmList,areaServModList,servCoreList


#Assign your output to the OUT variable
OUT = out
#OUT = flr_WidthList,flr_HeightList
</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="b8e89c2f-2fc9-4a6d-bd8a-60ce7d74db11" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Block Width Height" x="3238.23124205615" y="-3839.664945871" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="width[0];&#xA;height[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="879012ae-02b6-4b1e-b2b1-20d0cfab7683" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Total Built Area" x="2955.09498822347" y="-3436.70006433044" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0];&#xA;a[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="8d4d07be-682a-42eb-af22-21e2671b1bef" type="DSIronPythonNode.PythonNode" nickname="Number of Elevators Needed" x="2952.89560294398" y="-3332.20588469827" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

totalBuiltAreaL	= 	IN[0]
passArea		=	IN[1]
servArea		=	IN[2]

passElevList=[]
servElevList=[]
for i in range(len(totalBuiltAreaL)):
	totalBuiltArea = totalBuiltAreaL[i]
	passElev = math.ceil(totalBuiltArea/passArea)
	servElev = math.ceil(totalBuiltArea/servArea)
	
	#make sure elevator counts are even
	if (passElev % 2 == 1): passElev += 1
	if (servElev % 2 == 1): servElev += 1
	
	passElevList.append(passElev)
	servElevList.append(servElev)




#Assign your output to the OUT variable
OUT = [passElevList, servElevList]</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="275be690-5a3f-485b-80f7-ac8d19efe42d" type="DSIronPythonNode.PythonNode" nickname="Core Placer Points" x="2141.59436767394" y="-3333.08488081339" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type = IN[1]
inputLen = IN[2]
coreDim = IN[3]

#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	points = 	rec.Points
	diagDist = Line.ByStartPointEndPoint(points[0],points[2]).Length
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge,diagDist
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------


#makes the core rectangle based on number of req it has---------------------------------------------------------------------------------------
def makeCoreBox(rec,numCore,wid,ht,longEdge):
	coreList=[]
	cen = rec.Center()
	pts = rec.Points
	ptPlaceList = []
	#when just need to place one core
	if numCore ==1:
		cs = CoordinateSystem.ByOrigin(cen)
		coreRec= Rectangle.ByWidthHeight(cs,wid,ht)
		coreList.append(coreRec)
		ptPlaceList.append(cen)
	#when more than one core needs to be placed
	else:
		len1 = Line.ByStartPointEndPoint(pts[0],pts[1]).Length
		len2 = Line.ByStartPointEndPoint(pts[0],pts[3]).Length
		#find the longer edge and that line
		if len1 == longEdge:
			lin = Line.ByStartPointEndPoint(pts[0],pts[1])
		else:
			lin = Line.ByStartPointEndPoint(pts[0],pts[3])			
		linCen = lin.PointAtParameter(0.5)
		vec = Vector.ByTwoPoints(linCen,cen)
		linNew = lin.Translate(vec)
		#divide the line to get the points to place core		
		linNewLen = linNew.Length
		perDist = linNewLen/(numCore+1)
		
		#prepare the pointlist
		for i in range(numCore):
			pt = linNew.PointAtDistance((i+1)*perDist)
			ptPlaceList.append(pt)
	return ptPlaceList
#---------------------------------------------------------------------------------------------------------------------------------------------

# function which places core boxes into the empty boxes----------------------------------------------------------------------------------------
def placeCoreBox(boxList):		
	allCores=[]
	lenMeasure = inputLen
	wid = coreDim
	ht = coreDim
	for i in range(len(boxList)):
		rec = boxList[i]
		shortEdge = getShorterDim(rec)[0]
		longEdge = getShorterDim(rec)[1]
		diagDist = getShorterDim(rec)[2]
		if longEdge &gt; lenMeasure :
			numCore = int(math.ceil(longEdge/lenMeasure))	
		else :
			numCore=1
		coreRecs = makeCoreBox(rec,numCore,wid,ht,longEdge)
		allCores.append(coreRecs)
	return allCores
#----------------------------------------------------------------------------------------------------------------------------------------------



out = placeCoreBox(emptyBox)
#Assign your output to the OUT variable
OUT = out
#OUT = polytoRect(emptyBox[0])</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="45748629-e625-430b-b33a-b2c437d57dbb" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_RestRooms" x="3671.52431666365" y="-3279.747996221" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[2];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="a7e9f424-9740-4d40-afd1-1f4aae322780" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Other_Part Service Area" x="3623.35795936332" y="-3458.07152139952" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="f4269aaf-9384-40ee-8269-b0836ca82d71" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_Service Module/ Tech rooms" x="3562.47309366605" y="-3736.32553623476" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[3];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="59322da8-84c2-4652-aaed-b6043c40610e" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Service Core Full Block" x="3635.63960406833" y="-3542.38454570494" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[4];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="7816939f-d2e5-4c40-8099-0ed64d83d87c" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Bank Rectangle Piece" x="3491.77619211627" y="-3363.62888582487" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="Bank_Rectangle[0];" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="ef4e036a-4c6e-4d4d-97bb-9e7da30a4a59" type="Dynamo.Nodes.DSFunction" nickname="Geometry.Intersect" x="3592.4470876405" y="-3650.94012288443" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Geometry.Intersect@Autodesk.DesignScript.Geometry.Geometry" />
    <DSIronPythonNode.PythonNode guid="599e3168-7c24-413f-8b77-44a84794b0ab" type="DSIronPythonNode.PythonNode" nickname="LATEST : New Elevator Packings" x="4864.85604409327" y="-3561.67331132076" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="7">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRecL	=	IN[0]
elevWidth	=	IN[1][0]
elevLength	=	IN[1][1]
totElev		=	IN[2]
lobbyWidth	=	IN[3]
servicRecL	=	IN[4]
interLineL	=	IN[5]
maxElevs	=	IN[6]





#FIRST CALLS **********************************************************************************************************************************FIRST CALLS
#to calc how many sub rectangles the elevbankrect needs to be split-------------------------
def getNumRects():
	#very imp transition@@@@@@@@@@@
	recShort	=	otherLen1
	recLong		=	commonLen	
	elevShort	=	getElevShorterDim(elevWidth,elevLength)[0]
	numRects	=	1	
	approx_numElevs	=	int(math.floor(recLong/elevShort))

	#Added to make total num of Elevs always even
	if approx_numElevs%2 &gt; 0: approx_numElevs += 1
	#-----------------------------------------------		
	elevShort 	=	recLong/approx_numElevs		
	while approx_numElevs &gt; maxElevs:
		numRects += 1
		approx_numElevs = int(approx_numElevs/2)	
	return int(numRects)
#------------------------------------------------------------------------------------------num,mainRec



#to subdivide given rect to num of rects based on a num------------------------------------
def subDivRect(num,mainRec):	
	numRects = getNumRects()
	numRects = num
	if numRects &lt; 2 : 
		return "no need to split"
	
	recList = []
	length1 = commonLen
	length2 = otherLen1
	
	dimension = length1/numRects

	startRec = mainRec
	for i in range(numRects):		
		try:
			rec = splitBox(startRec,dimension,length2)
		except:
			recList.append(rec[1])
			return recList			
		recList.append(rec[0])		
		startRec = rec[1]			
	return recList
#------------------------------------------------------------------------------------------



#function to scale rectangles to add in corridors in between elevators-------------------------------------------------------------
def scaledRects(recLists):
	#make new recLists
	newRecs = recLists[:]
	del newRecs[0]
	del newRecs[-1]
	
	
	endRecs = [recLists[0],recLists[-1]]
	
	outRec=[]
	for rec in newRecs:
		pts = rec.Points
		basePt = pts[0]
		wid = rec.Width
		length = rec.Height
		
		l1 = Line.ByStartPointEndPoint(pts[0],pts[1])
		l2 = Line.ByStartPointEndPoint(pts[0],pts[3])
		
		len1 = l1.Length
		len2 = l2.Length
		fac = 0.75 # hardcoded
		
		#prepare basept, p1 and p2 from Scale1D
		if wid == len1: 
			fromPt = pts[1]
			toPt = l1.PointAtParameter(fac)
			midPt = l1.PointAtParameter(0.5)
		else: 
			fromPt = pts[3]
			toPt = l2.PointAtParameter(fac)
			midPt = l2.PointAtParameter(0.5)
		
		#find the vector to translate the scaled rect		
		pCrv = rec.Scale1D(basePt,fromPt,toPt)
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]
			
		lNew1 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[1])
		lNew2 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[3])
			
		if wid == len1: midPtNew = lNew1.PointAtParameter(0.5)
		else: midPtNew = lNew2.PointAtParameter(0.5)
			
			
		#make the vec for translation
		vec= Vector.ByTwoPoints(midPtNew,midPt)
		pCrv = pCrv.Translate(vec)
		
		#block to make rectangle
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]		
		rec = Rectangle.ByCornerPoints(ptsNew[0],ptsNew[3],ptsNew[2],ptsNew[1])
		outRec.append(rec)
			
		
	#code to work on the first and last rectangles.	
	for i in range(len(endRecs)):
		if (i==0):pass
		rec = endRecs[i]
		
		pts = rec.Points
		basePt = pts[0]
		wid = rec.Width
		length = rec.Height
		
		l1 = Line.ByStartPointEndPoint(pts[0],pts[1])
		l2 = Line.ByStartPointEndPoint(pts[0],pts[3])
		
		len1 = l1.Length
		len2 = l2.Length
		fac = 0.9 # hardcoded
		
		#prepare basept, p1 and p2 from Scale1D
		if wid == len1: 
			fromPt = pts[1]
			toPt = l1.PointAtParameter(fac)
			midPt = l1.PointAtParameter(0.5)
		else: 
			fromPt = pts[3]
			toPt = l2.PointAtParameter(fac)
			midPt = l2.PointAtParameter(0.5)
		
		
		
		#find the vector to translate the scaled rect		
		pCrv = rec.Scale1D(basePt,fromPt,toPt)
		crv = pCrv.Curves()
		if(i&gt;0):
			ptsNew = [x.StartPoint for x in crv]
			
			lNew1 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[1])
			lNew2 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[3])
			
			if wid == len1: midPtNew = lNew1.PointAtParameter(fac/2)
			else: midPtNew = lNew2.PointAtParameter(fac/2)
		
			#make the vec for translation
			vec= Vector.ByTwoPoints(midPtNew,midPt)
			pCrv = pCrv.Translate(vec)

		#block to make rectangle
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]		
		rec = Rectangle.ByCornerPoints(ptsNew[0],ptsNew[3],ptsNew[2],ptsNew[1])
		
		endRecs[i] = rec
		#break	
		
		
	#finally merge all components
	finList=[]		
	finList.extend([endRecs[0]])
	finList.extend(outRec)
	finList.extend([endRecs[-1]])
		
	return finList
#-----------------------------------------------------------------------------------------------------------------------------------
#FIRST CALLS **********************************************************************************************************************************FIRST CALLS

#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------

#get the shorter dimension---------------------------------------------------------------
def getElevShorterDim(width,length):
	if(width&lt;length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge = length
		longEdge  = width
	return shortEdge,longEdge
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------

#====================================================================================================================================================================================
#make rects based on dimension given------------------------------------------------------------------------
def splitBox(rec,dim,length):
	recPts	=	rec.Points
	#make four lines for the input rectangles
	lin0		=	Line.ByStartPointEndPoint(recPts[0],recPts[1])#0
	lin1		=	Line.ByStartPointEndPoint(recPts[1],recPts[2])#1
	lin2 		=	Line.ByStartPointEndPoint(recPts[2],recPts[3])#2
	lin3		=	Line.ByStartPointEndPoint(recPts[3],recPts[0])#3
	# get the first point of first line
	firstPt		=	lin0.StartPoint
	
	# get the length and lines for those edges whose length matches input length
	if lin0.Length &gt;= length-0.005 and lin0.Length &lt;= length+0.005: 
		bigDimension = lin1.Length
		lineShort1 = lin1
		lineShort2 = lin3				
	if lin1.Length &gt;= length-0.005 and lin1.Length &lt;= length+0.005: 
		bigDimension = lin0.Length
		lineShort1 = lin0
		lineShort2 = lin2
	
	#get the points to make the two rectangles
	f1 		=	dim/bigDimension
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	rec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	rec2	=	Rectangle.ByCornerPoints(ptOut1,ptOut2,stPt2,endPt1)
	#get the center points for two rects
	rec1Cen	=	rec1.Center()
	rec2Cen = 	rec2.Center()
	#get the vectors from the first pt
	vec1	=	Vector.ByTwoPoints(firstPt,rec1Cen)
	vec2	=	Vector.ByTwoPoints(firstPt,rec2Cen)
	#compare the length of the vectors to get how far are they from start pt
	vcLen1 	=	vec1.Length
	vcLen2 	=	vec2.Length
	#finally set them as the final ouput rect
	if vcLen1 &lt; vcLen2 :
		outRec1 = 	rec1
		outRec2 = 	rec2
	else:
		outRec1 = 	rec2
		outRec2 = 	rec1	
			
	return outRec1,outRec2
#---------------------------------------------------------------------------------------------------------------	
	
#main function making the elevator packings------------------------------------------------
def makeElevBox(bkRec,commonLen,otherLen1):
	inpRec = []
	inpRec.append(bkRec)

	elevDims	=	getElevShorterDim(elevWidth,elevLength)
	elevShort	=	elevDims[0]
	elevLong	=	elevDims[1]
	
	longCounter = 	0
	listDims	=	[]
	frstPtList	=	[]
	count		=	0
	
	#very imp transition@@@@@@@@@@@
	recShort	=	otherLen1
	recLong		=	commonLen
		
	numElevs	=	int(math.floor(recLong/elevShort))
	#"""
	#Added to make total num of Elevs always even
	if numElevs%2 &gt; 0: 
		numElevs += 1
		#elevShort = recLong/numElevs
	#-----------------------------------------------

	elevShort 	=	recLong/numElevs	
	areaElev 	=	elevShort*commonLen

	
	
	cap = 5		
	#BLOCK TO MAKE LIST OF DIMENSIONS TO PREPARE ELEV ROWS AND LOBBY PLACEMENTS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	#loop till you catch up with the dimension longitudinally
	while (cap&gt;0):
		longCounter += elevLong
		if (longCounter &gt; recShort): # recShort replaced by otherLen   +++ longCounter &gt; recShort-0.005 and longCounter &lt; recShort+0.005
			break
		listDims.append(elevLong)
		if (count%2 ==0):
			longCounter += lobbyWidth	
			if (longCounter &gt; recShort):# recShort replaced by otherLen
				break
			listDims.append(lobbyWidth)			
		count		+= 1
	ct = 0
	lobbies = 0
	# test to check whole length added
	for i in range(len(listDims)):
		ct += listDims[i]
		if (listDims[i] == lobbyWidth):
			lobbies += 1
	#if lobbies == 0: lobbies =1
	#get the left over space
	leftOver =  recShort - ct
	perBayAdd=  leftOver/lobbies
	perBayAdd+=	0.002
	
	# distribute it to the lift lobbies
	if (perBayAdd &gt; 0):
		for i in range(len(listDims)):
			if (listDims[i] == lobbyWidth):
				listDims[i] += perBayAdd + 0.002
	
	#added to make sure the total dimension not exceeding
	if sum(listDims)&gt;otherLen1:
		extra = sum(listDims)-otherLen1
		listDims[-1] -= extra
	
	recLists = []
	stRec	 = bkRec

	index1 = 0
	index2 = 1
	longDim = getShorterDim(servicRec)[1]
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	
	str =""
	prnList=[]
	#BLOCK TO MAKE ELEVATOR ROWS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	for i in range(len(listDims)-1):		
		try:
			rec = splitBox(stRec,listDims[i],commonLen)		
			prnList.append("DID IT")
		except:
			#nRec = stRec.Reverse
			#rec = splitBox(nRec,listDims[i],commonLen)	
			str =  "Not Done"
			prnList.append("FAILED")
			#continue
		recLists.append(rec[0])
		#frstPtList.append(rec[2])
		stRec = rec[1]
		if (i==len(listDims)-2): 
			recLists.append(rec[1])
			prnList.append("LAST CASE")
			#break
	
	#make the list of elevator row first
	elevRowLists = []
	copRecLists =  []
	str = "dont know"
	strN= ""
	for i in range(len(recLists)):
		if i ==0: dimA = listDims[i+1]		
		#if dimA != listDims[i]: copRecLists.append(recLists[i])		

		if i != 0 and dimA !=listDims[i-1] and i == len(recLists)-1 : 
			pass
		elif dimA != listDims[i]: copRecLists.append(recLists[i])
			
		#copRecLists = list(recLists[i] if dimA == listDims[i]:)
	
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	
	#BLOCK TO PLACE ELEVATOR BOXES IN THE ROWS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	str2 = ""
	recElevs=[]
	recElevsRow=[]
	for i in range(len(copRecLists)):
		stRec = copRecLists[i]
		elevRow=[]
		shorter = getShorterDim(stRec)[0]
		for j in range(int(numElevs)-1):		
			try:
				rec = splitBox(stRec,elevShort+0.0002,shorter)				
			except:
				#continue
				stt = ""
			stRec = rec[1]
			elevRow.append(rec[0])
			if j==int(numElevs)-2: 
				elevRow.append(rec[1])
			
			#frstPtList.append(rec[2])
			recElevs.append(rec)
			str2 =  " all added" 
		recElevsRow.append(elevRow)
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	totalElev = [len(x) for x in recElevsRow]
	sumtotalElev = sum(totalElev)
	#return recLists,listDims,recDims[0],copRecLists,recElevs,len(recElevs)
	return recElevsRow


def mainCode(mainRec):
	numRc = getNumRects()
	if numRc &gt;=2:
		aRects = subDivRect(getNumRects(),mainRec)
		subRects = scaledRects(aRects)
	else:
		subRects = [mainRec]
	outL = []
	strList=[]
	for i in range(numRc):
		
		bankRec = subRects[i]
		comLen = interLine.Length/numRc
		
		# set commonLength and otherLength
		if (comLen == bankRec.Width): 
			otrLen = bankRec.Height
		elif (comLen == bankRec.Height): 
			otrLen = bankRec.Width
		elif (bankRec.Width&lt;bankRec.Height):
			comLen = bankRec.Width
			otrLen = bankRec.Height
		else:
			comLen = bankRec.Height
			otrLen = bankRec.Width
				
		out = makeElevBox(bankRec,comLen,otrLen)
		outL.append(out)
	return outL
	
#function to see rectangle size ---------------------------------------------------------------------------------------------
def sizeChecker(rec,dim):
	wid = rec.Width
	ht = rec.Height	
	if wid &lt; dim or ht &lt; dim:
		return False
	else: return True
#----------------------------------------------------------------------------------------------------------------------------

"""
mainRecL	=	IN[0]
elevWidthL	=	IN[1][0]
elevLengthL	=	IN[1][1]
totElevL	=	IN[2]
lobbyWidth	=	IN[3]
servicRecL	=	IN[4]
interLineL	=	IN[5][0]
maxElevs	=	IN[6]

"""

outF=[]
interLine  = interLineL[0]
testLen=[]
for i in range(len(mainRecL)):
	#1st Block lev handling each rect block
	coreInside = mainRecL[i]
	#outF.append(len(coreInside))
	interLine  = interLineL[i][0][0]
	
	"""
	if len(coreInside) &lt;1:
		out ="More Than One Cores , Cant Handle"
		#pass
	else:
	"""
	out1=[]
	for j in range(len(coreInside)):
		interLine  = interLineL[i][j][0]
		commonLen	=	float(interLine.Length)
		otherLen1	=	0
		mainRec 	= 	coreInside[j]
		bankRec 	= 	mainRec
		servicRec 	=	servicRecL[i][j]
			
		#if sizeChecker(mainRec,8) == False: break
			
		if (commonLen &gt; mainRec.Width-0.005 and commonLen &lt; mainRec.Width+0.005): otherLen1 = float(mainRec.Height)
		if (commonLen &gt; mainRec.Height-0.005 and commonLen &lt; mainRec.Height+0.005): otherLen1 = float(mainRec.Width)
		out = mainCode(mainRec)
		testLen.append(otherLen1)
		out1.append(out)
	outF.append(out1)
		

		
	










#Assign your output to the OUT variable
#OUT = out,numRc,subRects,bankRec
OUT = outF
</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="d150f1bb-500e-42b9-ad82-a7c3b4a1c3d5" type="DSIronPythonNode.PythonNode" nickname="Total Elevs Per Block" x="3179.96043290675" y="-3252.40118267272" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


elevLists = IN[0]

num = len(elevLists)
finLists=[]
for i in range(num):
	finLists.append(sum(elevLists[i]))


	

#Assign your output to the OUT variable
OUT = finLists</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="c155fb81-334d-4ca4-baa0-c63442677f68" type="Dynamo.Nodes.DSFunction" nickname="List.Transpose" x="3176.77509320184" y="-3337.36780899089" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.List.Transpose@var[]..[]" />
    <DSIronPythonNode.PythonNode guid="903120c6-a2bc-4a7f-9324-f0befe0d91a7" type="DSIronPythonNode.PythonNode" nickname="Technical Rooms + Restrooms" x="3883.75225468099" y="-3431.97045713374" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

wrapperRectL		=	IN[0]
areaTechnicalL		=	IN[1]
areaRestrmL			=	IN[2]


def makeThreePiece(width,length,pts,f1,f2):
	if (width &lt; length):
		rec1Length 		=	f1*length
		rec1Width		=	width
		
		rec2Length 		=	f2*length
		rec2Width		=	width
		
		rec3Length 		=	length - rec1Length - rec2Length
		rec3Width		=	width
		
		index			=	1		
	else:
		rec1Length 		=	length
		rec1Width		=	f1*width
		
		rec2Length 		=	length
		rec2Width		=	f2*width
		
		rec3Length 		=	length
		rec3Width		=	width - rec1Width - rec2Width
		
		index			=	3
	
	cs1					= 	CoordinateSystem.ByOrigin(pts[0].X,pts[0].Y,0) 
	
	# to make the 1st rectangle ----------------------------------------------------------------------	
	rec1 				= 	Rectangle.ByWidthHeight(cs1,rec1Width,rec1Length)	
	rec1Vec				= 	Vector.ByTwoPoints(rec1.Points[0],pts[0])
	rec1				=	Geometry.Translate(rec1, rec1Vec)
	rec1Pt				=	rec1.Points	
	cs1					= 	CoordinateSystem.ByOrigin(rec1Pt[0].X,rec1Pt[0].Y,0)
	
	# to make the 2nd rectangle ----------------------------------------------------------------------	
	rec2 				= 	Rectangle.ByWidthHeight(cs1,rec2Width,rec2Length)	
	rec2Vec				= 	Vector.ByTwoPoints(rec2.Points[0],rec1Pt[index])
	rec2				=	Geometry.Translate(rec2, rec2Vec)
	rec2Pt				=	rec2.Points	
	cs1					= 	CoordinateSystem.ByOrigin(rec2Pt[0].X,rec2Pt[0].Y,0)
	
	# to make the 2nd rectangle ----------------------------------------------------------------------	
	rec3 				= 	Rectangle.ByWidthHeight(cs1,rec3Width,rec3Length)	
	rec3Vec				= 	Vector.ByTwoPoints(rec3.Points[0],rec2Pt[index])
	rec3				=	Geometry.Translate(rec3, rec3Vec)
	
	return rec1,rec2,rec3
#END OF FUNCTION#-------------------------------------------------------------------------------------

#main function called and executed----------------------------------------------------------------------
def mainCode():
	outT1 = []
	outT2 = []
	outR = []
	for i in range(len(wrapperRectL)):
		# incoming rectangle specifications
		wrapR = wrapperRectL[i]
		recListTech1=[]
		recListTech2=[]
		recListRest=[]
		for j in range(len(wrapR)):
			wrapPts			=	wrapR[j].Points
			wrapWidth		=	wrapR[j].Width
			wrapLength		=	wrapR[j].Height
			#----------------------------------------------------------------------------------------
				
			#totArea			=	areaTechnical + areaRestrm 
			totArea			=	wrapWidth * wrapLength
			facT			=	areaTechnicalL[i][j] / totArea
			facR			=	areaRestrmL[i][j] / totArea
			
			recListTech1.append(makeThreePiece(wrapWidth,wrapLength,wrapPts,0.4,0.2)[0])
			recListTech2.append(makeThreePiece(wrapWidth,wrapLength,wrapPts,0.4,0.2)[2])
			
			recListRest.append(makeThreePiece(wrapWidth,wrapLength,wrapPts,0.4,0.2)[1])
		outT1.append(recListTech1)
		outR.append(recListRest)
		outT2.append(recListTech2)
	return outT1,outR,outT2
#-------------------------------------------------------------------------------------------------------

#Assign your output to the OUT variable
#OUT = [techRec1,otherRec]
OUT = mainCode()</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="88d9fd1f-c501-4b1a-9092-bd3d72fcc76a" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Technical Rooms" x="4864.18666723583" y="-3657.96376674126" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="Toilet[0];&#xA;Toilet[2];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="1fee66bf-756f-47be-81bc-059d7b7b49b2" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Floor Curve" x="4856.55856325768" y="-3752.30411730129" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="floorcrv;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="30c768a4-1f41-4c2c-bcb6-cf020b9dc548" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Toilets" x="4854.70493953354" y="-3847.68406948974" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="Toilet[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="5fd5f97b-8669-4122-b0e9-61bf955b422a" type="DSIronPythonNode.PythonNode" nickname="Toilet Arrangement Different&#xD;&#xA;" x="5246.36469212245" y="-3855.18492227143" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

restroomRecList		=	IN[0]
floorRecList		=	IN[1]
marker				=	IN[2]



#---------------------------------------------------------------

# 1 = LONGITUDINAL CUT		0 = TRAVERSAL CUT
#make boxes inside--------------------------------------------------------------------------------
def splitRec(rec,f1,tag):
	recPoints	=	rec.Points
	width		=	rec.Width
	length		=	rec.Height
	#make the four edges of the input rectangle
	lineList	=	[]
	for i in range(len(recPoints)):
		if(i== len(recPoints)-1):
			k = 0
		else:
			k = i+1
		ptA		=	recPoints[i]
		ptB		=	recPoints[k]
		lin		=	Line.ByStartPointEndPoint(ptA,ptB)
		lineList.append(lin)
		
	#pick two points on the shorter lines
	len1	=	lineList[0].Length
	len2	=	lineList[1].Length
	if (tag == 1):
		if (len1&lt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
	else:
		if (len1&gt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
		
		
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	outRec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	outRec2	=	Rectangle.ByCornerPoints(stPt2,endPt1,ptOut1,ptOut2)
		
	#return lineShort1,lineShort2,ptOut1,ptOut2,width,length,outRec1,outRec2
	return outRec1,outRec2
	#return lineList
#END OF FUNCTION# --------------------------------------------------------------------------------


#-----------------------------------------------------------------------------------------------------
def findOuterPt():
	restrmPoints	=	restroomRec.Points
	floorPoints		=	floorRec.Points

	selectedLines	=	[]
	selectedPoints	=	[]
	lineStoreList=[]
	lineList	=	[]
	lineStore=0
	for i in range(len(restrmPoints)):
		ptA 		= 	restrmPoints[i]
		# iterate to make the 4 lines 
		for j in range(len(floorPoints)):
			ptB 		= 	floorPoints[j]
			lineAB		=	Line.ByStartPointEndPoint(ptA,ptB)
			lineList.append(lineAB)
		prevLine=""
		# iterate to find the shortest line out of the four
		for k in range(len(lineList)):
			currentLine = lineList[k]
			if ( prevLine != ""):
				if ( prevLine.Length &gt; currentLine.Length ): lineStore = currentLine
				else : lineStore = prevLine
			prevLine = currentLine
		lineStoreList.append(lineStore)
	
	prevLen = ""
	indexVal= 0
	for l in range(len(lineStoreList)):
		currentLen	=	lineStoreList[l].Length
		if ( prevLen != ""):
			if ( prevLen &gt; currentLen ): indexVal = l
		prevLen = currentLen
		
	shortLine = lineStoreList[indexVal]
	finalPoint= shortLine.StartPoint
	return finalPoint
#END OF FUNCTION# --------------------------------------------------------------------------------


#decide the proportion of fraction----------------------------------------------------------------
def facDecider(rec,pt):
	points	=	rec.Points
	width	=	rec.Width
	length	=	rec.Height
	line	=	Vector.ByTwoPoints(points[0],pt)
	#line	=	Line.ByStartPointEndPoint(points[0],pt)
	len		=	line.Length
	
	if (width&lt;length):
		shortDist = width
	else:
		shortDist = length
	
	if (len&gt;shortDist):
		fac = 0.8
	else:
		fac = 0.2
	return fac
#END OF FUNCTION# --------------------------------------------------------------------------------

def closerRect(recList,pt):
	lenList=[]
	for i in range(0,len(recList)):	
		rec	=	recList[i]
		lin = 	Line.ByStartPointEndPoint(rec.Center(),pt)
		lenList.append(lin.Length)
	index= ""
	for i in range(0,len(lenList)-1):
		len1 = lenList[i]
		len2 = lenList[i+1]
	if (len1&lt;len2):
		index = 0
	else:
		index = 1
	return recList[index]
	
	
"""	
restroomRecList		=	IN[0]
floorRecList		=	IN[1]
markerList			=	IN[2]
"""
rec1List=[]
rec2List=[]
for i in range(len(restroomRecList)):
	restRmL = restroomRecList[i]
	rec1L=[]
	rec2L=[]
	floorRec = floorRecList[i]
	for j in range(len(restRmL)):
		restroomRec = restRmL[j]
		widthRestrm		=	restroomRec.Width
		lengthRestrm	=	restroomRec.Height
		pointsRestrm	=	restroomRec.Points
		
		finalPoint= findOuterPt()		
		if(marker == 1):
			key1 = 0
			key2 = 1
		else:
			key1 = 1
			key2 = 0
				
		recs	=	splitRec(restroomRec,0.5,key1)
		closeRec=	closerRect(recs,finalPoint)
		fac		=	facDecider(closeRec,finalPoint)
		rec2	=	splitRec(closeRec,fac,key2)
		rec1L.append(recs[0])
		rec2L.append(rec2)
	rec1List.append(rec1L)
	rec2List.append(rec2L)
#Assign your output to the OUT variable
#OUT = lineStoreList,lineList,restrmPoints,shortLine,finalPoint
OUT = rec1List,rec2List</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="95479b69-5cbb-4336-80ba-37d5fce71073" type="DSIronPythonNode.PythonNode" nickname="Technical Room Arrangements&#xD;&#xA;" x="5246.36469212245" y="-3714.76166387596" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRecList		=	IN[0]

#---------------------------------------------------------------



# 1 = LONGITUDINAL CUT		0 = TRAVERSAL CUT
#make boxes inside--------------------------------------------------------------------------------
def splitRec(rec,f1,tag):
	recPoints	=	rec.Points
	width		=	rec.Width
	length		=	rec.Height
	#make the four edges of the input rectangle
	lineList	=	[]
	for i in range(len(recPoints)):
		if(i== len(recPoints)-1):
			k = 0
		else:
			k = i+1
		ptA		=	recPoints[i]
		ptB		=	recPoints[k]
		lin		=	Line.ByStartPointEndPoint(ptA,ptB)
		lineList.append(lin)
		
	#pick two points on the shorter lines
	len1	=	lineList[0].Length
	len2	=	lineList[1].Length
	if (tag == 1):
		if (len1&lt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
	else:
		if (len1&gt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
		
		
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	outRec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	outRec2	=	Rectangle.ByCornerPoints(stPt2,endPt1,ptOut1,ptOut2)
		
	#return lineShort1,lineShort2,ptOut1,ptOut2,width,length,outRec1,outRec2
	return outRec1,outRec2
	#return lineList
#END OF FUNCTION# --------------------------------------------------------------------------------


finalList=[]
for i in range(len(mainRecList)):
	mainRecL = mainRecList[i]
	getList = []
	for j in range(len(mainRecL)):
		mainRec 		= 	mainRecL[j]
		outList			=	[]
		twoLinearRecs	=	splitRec(mainRec,0.60,0)
		rec1			=	twoLinearRecs[0]
		rec2			=	twoLinearRecs[1]
		for k in range(3):
			#fac		=	random.random()
			fac 	=	0.35
			out1 	=	splitRec(rec1,fac,0)
			outList.append(out1)
			rec1	=	out1[1]			
			out2 	=	splitRec(rec2,fac,0)
			outList.append(out2)
			rec2	=	out2[1]		
		getList.append(outList)
	finalList.append(getList)
	
	

#Assign your output to the OUT variable
#OUT = lineStoreList,lineList,restrmPoints,shortLine,finalPoint
OUT = finalList</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="3df664c4-cf2c-421b-98a3-30ffd488bb28" type="DSIronPythonNode.PythonNode" nickname="Area Generator RestRoom + TechRoom" x="3877.11250522572" y="-3762.02012174335" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

otherRecList = IN[0]
restRmAreaL  = IN[1]
techRmAreaL  = IN[2]



#proportion generator for restrm Area and Techroom Area---------------------------------------------------
def propGenerator():
	propTechL=[]
	propRestL = []
	for i in range(len(otherRecList)):
		techArea = techRmAreaL[i]
		restrmArea = restRmAreaL[i]
		propTechArea = techArea/(techArea+restrmArea)
		propRestArea = 1-propTechArea
		propTechL.append(propTechArea)
		propRestL.append(propRestArea)
	return propTechL,propRestL
#---------------------------------------------------------------------------------------------------------

#main Code called and run---------------------------------------------------------------------------------
def mainCode():
	areaRestrmList=[]
	areaTechrmList=[]
	propL = propGenerator()
	for i in range(len(otherRecList)):
		otherRecL = otherRecList[i]	
		propTech = propL[0][i]	
		propRest = propL[1][i]
		restAreaL = []
		techAreaL = []
		for j in range(len(otherRecL)):
			rec = otherRecL[j]
			recArea = rec.Width * rec.Height
			techArea = propTech * recArea
			restArea = propRest * recArea
			techAreaL.append(techArea)
			restAreaL.append(restArea)
		areaTechrmList.append(techAreaL)
		areaRestrmList.append(restAreaL)			

	return areaTechrmList, areaRestrmList
#--------------------------------------------------------------------------------------------------------


out = mainCode()
#Assign your output to the OUT variable
#OUT = [areaTechrmList, areaRestrmList]
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="a1707fe3-b13a-42d3-a492-795cdce17ff9" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_RestRooms_Final" x="3878.80736544356" y="-3619.33366820715" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="ef11afca-5d65-4104-bd81-ec44bc36f7ad" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_Tech rooms_Final" x="3879.99424861774" y="-3532.4906546921" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="5b67df9a-e802-4711-8978-af5ea57cf54a" type="DSIronPythonNode.PythonNode" nickname="Technical Room Arrangements&#xD;&#xA;" x="5246.36469212245" y="-3624.12082739738" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRecList		=	IN[0]

#---------------------------------------------------------------
# 1 = LONGITUDINAL CUT		0 = TRAVERSAL CUT
#make boxes inside--------------------------------------------------------------------------------
def splitRec(rec,f1,tag):
	recPoints	=	rec.Points
	width		=	rec.Width
	length		=	rec.Height
	#make the four edges of the input rectangle
	lineList	=	[]
	for i in range(len(recPoints)):
		if(i== len(recPoints)-1):
			k = 0
		else:
			k = i+1
		ptA		=	recPoints[i]
		ptB		=	recPoints[k]
		lin		=	Line.ByStartPointEndPoint(ptA,ptB)
		lineList.append(lin)
		
	#pick two points on the shorter lines
	len1	=	lineList[0].Length
	len2	=	lineList[1].Length
	if (tag == 1):
		if (len1&lt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
	else:
		if (len1&gt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
		
		
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	outRec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	outRec2	=	Rectangle.ByCornerPoints(stPt2,endPt1,ptOut1,ptOut2)
		
	#return lineShort1,lineShort2,ptOut1,ptOut2,width,length,outRec1,outRec2
	return outRec1,outRec2
	#return lineList
#END OF FUNCTION# --------------------------------------------------------------------------------

finalList=[]
for i in range(len(mainRecList)):
	mainRecL = mainRecList[i]
	getList = []
	for j in range(len(mainRecL)):
		mainRec 		= 	mainRecL[j]
		outList	=	[]
		twoLinearRecs	=	splitRec(mainRec,0.38,1)
		rec1			=	twoLinearRecs[0]
		rec2			=	twoLinearRecs[1]
		for k in range(4):
			#fac		=	random.random()
			fac 	=	0.35
			out1 	=	splitRec(rec1,fac,0)
			outList.append(out1)
			rec1	=	out1[1]			
			out2 	=	splitRec(rec2,fac,0)
			outList.append(out2)
			rec2	=	out2[1]		
		getList.append(outList)
	finalList.append(getList)
	
	

#Assign your output to the OUT variable
#OUT = lineStoreList,lineList,restrmPoints,shortLine,finalPoint
OUT = finalList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="f904476b-4d4d-4cdf-a2c5-22f70188e33f" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Number of Elev Per Bank" x="4080.07610044412" y="-1745.56378389554" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="numberElevPerBank[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="1c8deb62-9bdb-4bdf-9df2-e136d59b3ea8" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Boundary Factor" x="4081.44643560596" y="-1658.06802699921" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="boundaryFactor = 0.9;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" type="DSIronPythonNode.PythonNode" nickname="Key Floor Finder" x="4657.09750401172" y="-1875.89880755231" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="7">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

buildSectionsList 	= 	IN[0]
grossBuildAreaList	=	IN[1]
elevPerbankListL	=	IN[2]
boundaryFactor		=	IN[3]
servModAreaList		=	IN[4]
elevArea			=	IN[5]
numFloorsList		=	IN[6]



#compute target area for each bank of elev serving each building section--------------------------------------------------------------------
def targetAreaCalculator(uba,buildSections):
	#output target area list for each bank of elev for each building section
	tarAreaList = []	
	#make the uba array
	totalBuildArea = 0
	for i in range(len(uba)):
		totalBuildArea += uba[i]		
	# compute the fraction
	frac 	=	totalBuildArea/buildSections
	
	#compute the target areas by iterating
	for i in range(1,buildSections+1):
		tarAreaList.append(frac*i)	
	return tarAreaList
#-------------------------------------------------------------------------------------------------------------------------------------------

#ccompute the key floors where the banks of elevators needs to be dropped-------------------------------------------------------------------
def keyFloorFinder():
	currentFloor = 1 # current floor counter
	#computer bank Area for each bank ( from elev Area )
	bankArea = [x*elevArea for x in elevPerbankList] 
	#bankArea = [10000 for x in elevPerbankList] 
	
	# iterate to find usable Build Area first
	ubaList = []
	for i in range(len(grossBuildArea)):
		ubaList.append(grossBuildArea[i]-servModArea)
	#compute the targetAreaList
	tarAreaList = targetAreaCalculator(ubaList,buildSections)
	
	#make the served areas list and key floor list and set as 0 values
	servedAreaList = [0 for x in range(buildSections)]		
	key = [0 for x in range(buildSections)]
	
	while currentFloor &lt;= len(ubaList)-1:
		#iterate to check if target is reached
		for i in range(buildSections):
			if servedAreaList[i] &lt; tarAreaList[i] and tarAreaList[i] - servedAreaList[i] &gt;= ubaList[currentFloor]*boundaryFactor:
				ubaList[currentFloor] = ubaList[currentFloor] - bankArea[i] 
		#iterate to check if target is reached	
		for i in range(buildSections):
			if servedAreaList[i] &lt; tarAreaList[i] and tarAreaList[i] - servedAreaList[i] &gt;= ubaList[currentFloor]*boundaryFactor:
				# update served areas and the key floors
				servedAreaList[i] = servedAreaList[i] + ubaList[currentFloor] 
				key[i]	=	key[i] + 1		
		#still checking if target has been reached
		for i in range(buildSections):
			if servedAreaList[i] &gt; tarAreaList[i] and servedAreaList[i] - tarAreaList[i] &gt;= ubaList[currentFloor] - ubaList[currentFloor]*boundaryFactor:
				servedAreaList[i] = servedAreaList[i] - ubaList[key[i]]
				ubaList[key[i]] = ubaList[key[i]] + bankArea[i] 
				for j in range(i+1,buildSections):
					servedAreaList[j] = servedAreaList[j] + bankArea[i] 
					key[i] = key[i] - 1
		tarAreaList = targetAreaCalculator(ubaList,buildSections)
		currentFloor += 1
	return [key,servedAreaList,tarAreaList,ubaList]
#-------------------------------------------------------------------------------------------------------------------------------------------



finalOut =[]
for i in range(len(grossBuildAreaList)):
	grossBuildArea = grossBuildAreaList[i]
	buildSections = buildSectionsList[i]
	elevL = elevPerbankListL[i]
	servModAreaL = servModAreaList[i]
	keyF=[]
	for j in range(len(servModAreaL)):
		elevPerbankList = elevL[j]		
		servModArea = servModAreaL[j]
		tarAreaList = 	targetAreaCalculator(grossBuildArea,buildSections)
		keyFloors	=	keyFloorFinder()
		
		keysTest = keyFloors[0]
		
		count =0
		for i in range(len(keysTest)):
			if keysTest[i] ==0: count += 1
		if count &gt; len(keysTest)/2:
			for i in range(len(keysTest)):
				keysTest[i] = numFloors
		
		keyFloors[0]	= 	keysTest
		keyF.append(keyFloors)
	finalOut.append(keyF)
		
		

#Assign your output to the OUT variable
#OUT = keysTest#
OUT = finalOut</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="10cebea5-de1b-4aaa-bc6e-3cb4bf87b46f" type="DSIronPythonNode.PythonNode" nickname="OneList" x="5247.60962140272" y="-3535.63115098162" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

listElevsList = IN[0]
interLineList = IN[1]





#make one list of the whole elev sublists---------------------------------
def oneList():
	return [z for x in listElevs for y in x for z in y]
#-------------------------------------------------------------------------


#to get the sorted elevs based on distance from closest point to the intersect line---------------------------------------------------------------------
def newSortElevs():
	sortedRect=[]
	avgRecList=[]
	recList = oneList()
	closePtList =[]	
	distList = []
	for i in range(len(recList)):
		recPt = recList[i].Center()		
		closePt = Geometry.ClosestPointTo(interLine[0],recList[i])
		closePtList.append(closePt)
		dist = Line.ByStartPointEndPoint(closePt,recPt).Length
		distList.append(dist)
	
	copyRecList = recList[:]
	sortedDistList = distList[:]
	sortedDistList.sort()
	
	for i in range(len(recList)):
		sortDis = sortedDistList[i]
		for j in range(len(copyRecList)):
			if sortDis == distList[j]:
				found = copyRecList[j]
				del copyRecList[j]
				del distList[j]
				break
		sortedRect.append(found)
	#return distList,sortedDistList,recList,sortedRect,copyRecList
	return sortedRect
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#calc number of elev per row---------------------------------------------------------------------------------------------------------------------------------
def numElevsperRow():
	for i in range(len(listElevs)):
		x = len(listElevs)
		y = len(listElevs[0][0])
		val = x*y
		break
	return val
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#make one list into lists as per rows of elev----------------------------------------------------------------------------------------------------------------
def makeListRow():
	numElevsRow = numElevsperRow()
	sortedElevList = newSortElevs()
	
	#create list of elevators who are combined together per row.
	num = int(len(oneList())/numElevsRow)
	megaList=[]	
	for i in range(num):
		x = i*numElevsRow
		alist = []
		for j in range(x,x+numElevsRow):			
			alist.append(sortedElevList[j])
		megaList.append(alist)
	return megaList
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#sort the rows based on the start point of instersect line--------------------------------------------------------------------------------------------------
def sortSecondRun():
	rowElevList = makeListRow()
	stPoint = interLine[0].PointAtParameter(0)

	# get the distance list for each row
	fullDistance=[]
	for i in range(len(rowElevList)):
		recList = rowElevList[i]
		disList=[]		
		for j in range(len(recList)):
			rec = recList[j]
			dist = Line.ByStartPointEndPoint(stPoint,rec.Center()).Length
			disList.append(dist)
		fullDistance.append(disList)
	
	
	#sort the distance list
	sortedDistList = fullDistance[:]
	copyElevs = rowElevList[:]
	for i in range(len(sortedDistList)):
		sortedDistList[i] = fullDistance[i][:]
		copyElevs[i] = rowElevList[i][:]
		sortedDistList[i].sort()
	
	#make the new recLists sorted
	for i in range(len(rowElevList)):
		recList = rowElevList[i]
		sortList = sortedDistList[i]
		distList1 = fullDistance[i]
				
		for j in range(len(sortList)):
			rec = recList[j]
			sortdis = sortList[j]
			newRec=[]
			for k in range(len(sortList)):
				if float(sortdis) == float(distList1[k]):
					rowElevList[i][j] = copyElevs[i][k]					
					break
	rev = []
	for i in range(len(rowElevList)):
		rev.append(rowElevList[-i])
	#return fullDistance,rowElevList,distList1,sortedDistList
	return rowElevList
#-----------------------------------------------------------------------------------------------------------------------------------------------------------




"""
listElevsList = IN[0]
interLineList = IN[1]
"""



fin = []
for i in range(len(listElevsList)):
	listElevL = listElevsList[i]
	interLineL = interLineList[i]
	newL=[]
	for j in range(len(listElevL)):
		listElevs = listElevL[j]
		interLine = interLineL[j]
		result = sortSecondRun()
		newL.append(result)
	fin.append(newL)
















#Assign your output to the OUT variable
#OUT = oneList(),out,makePts(),scaleVals(),newSortElevs(),numElevsperRow(),sortSecondRun()
#OUT = sortSecondRun()
OUT = fin</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="d8b40901-d208-4b8b-82ef-878ddaddfd63" type="DSIronPythonNode.PythonNode" nickname="Separate Bank Maker" x="5248.0635211407" y="-3420.1126928431" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

elevBoxesList = IN[0]
buildSectionsList=IN[1]





#to fix the sequence of elevators in the elv boxes----------------------------------------------------------------------		
def reverseList():
	global elevBoxes	
	cnt =0
	for i in range(len(elevBoxes)-1):	
		if (i)%2 == 0:
			cnt += 1
			if cnt%2==0:
				str =""
				elevBoxes[i].reverse()
				elevBoxes[i+1].reverse()
#-----------------------------------------------------------------------------------------------------------------------	


#to make one list of input elev lists-----------------------------------------------------------------------------------
def totalElevList():
	newElevBoxes=[]	
	for i in range(len(elevBoxes)):
		elev = elevBoxes[i]
		for j in range(len(elev)):
			newElevBoxes.append(elev[j])
	return newElevBoxes
#-----------------------------------------------------------------------------------------------------------------------	


#to distribute number of elevators per bank based on number elev per row------------------------------------------------
def bankNumbers():
	listElevBoxes=totalElevList()
	totalElevNum = len(listElevBoxes)
	bankNum=[]
	
	perDivision = int(math.floor(totalElevNum/buildSections))
	if (perDivision &gt;= numElevRow): perDivision = numElevRow
	if (perDivision &lt; numElevRow): perDivision = int(numElevRow/2)
	diff = totalElevNum - (perDivision*buildSections)
	
	#perDivision = [numElevRow if perDivision &gt;= numElevRow]
	#perDivision = [numElevRow/2 if perDivision &lt; numElevRow]
	
	if perDivision &gt;=1:
		for i in range(buildSections):
			bankNum.append(perDivision)
		bankNum[-1] += diff
	
	
	#to make all if they all are even numbers
	surplus =0
	for i in range(len(bankNum)):
		if bankNum[i]%2 !=0:
			bankNum[i] -= 1
			surplus	+= 1
	if surplus &gt; 0 : bankNum[-1] += surplus	
	bankNum.sort()
	bankNum.reverse()

	return bankNum
#-----------------------------------------------------------------------------------------------------------------------

#to make separate banks of elevs based on number of building sections---------------------------------------------------
def makePairs():
	str = []
	newElevsList =[]
	for i in range(0,numRows,2): 
		if i == numRows-1:			
			newElevsList.extend(elevBoxes[-1])
			str.append("entered here")
		else:		
			listA = elevBoxes[i]
			listB = elevBoxes[i+1]
			newList = crossLists(listA,listB)
			newElevsList.extend(newList)
			str.append("may be")				
	return newElevsList
#-----------------------------------------------------------------------------------------------------------------------

#to cross two lists togthr and return one list out----------------------------------------------------------------------
def crossLists(listA,listB):
	crossedList = []
	for i in range(len(listA)):
		crossedList.append(listA[i])
		crossedList.append(listB[i])
	return crossedList
#-----------------------------------------------------------------------------------------------------------------------


#to make separate banks of elevs based on number of building sections---------------------------------------------------
def makeBanks():
	#listElevBoxes=totalElevList()
	#totalElevNum = len(listElevBoxes)
	
	listElevBoxes=makePairs()
	totalElevNum = len(listElevBoxes)
	
	elevperBank = bankNumbers()
	elevCount   = 0
	perRowCount = 0
	listBanks=[]
	temp =0	
	for i in range(buildSections):
		elevAtBank =[]
		xVal = elevperBank[i]		
		for j in range(xVal):
			try:
				elevAtBank.append(listElevBoxes[temp+j])
			except:
				print "some error"
			#elevAtBank.append(listElevBoxes[temp+j])
			if ( j == xVal-1): temp = temp + xVal
		listBanks.append(elevAtBank)
	return listBanks
#------------------------------------------------------------------------------------------------------------------------

"""
elevBoxesList = IN[0]
buildSectionsList=IN[1]
"""

outN1=[]
outN2=[]
outTots=[]
for i in range(len(elevBoxesList)):
	elevBoxesL= elevBoxesList[i]
	buildSections = buildSectionsList[i]
	getL1=[]
	getL2=[]
	sum=0
	for j in range(len(elevBoxesL)):
		elevBoxes = elevBoxesL[j]
		numElevRow = len(elevBoxes[0])
		numRows = len(elevBoxes)
		#reverseList()
		out = makeBanks()
		out2 = bankNumbers()
		#crossed = makePairs()
		getL1.append(out)
		getL2.append(out2)
		sum += len(totalElevList())
	outN1.append(getL1)
	outN2.append(getL2)
	outTots.append(sum)



#Assign your output to the OUT variable
OUT = outN1,outN2,outTots
#OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="dd5e0569-228b-47de-8b41-3c3e9992047d" type="DSIronPythonNode.PythonNode" nickname="Building sections per Volume" x="4080.81678016193" y="-1958.24373743592" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

spaceList = IN[0]
buildSec = IN[1]

buildSecs = []
for i in range(len(spaceList)):
	buildSecs.append(buildSec)
	

#Assign your output to the OUT variable
OUT = buildSecs</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="d9724031-75f6-41ef-a06d-5621d7a95c02" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="BuildSections" x="4085.64380788714" y="-2046.5798954517" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="buildSections = 3;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="5ea270e8-1be9-42b0-8915-a7af312a821a" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Elevators" x="7917.14775452517" y="-1149.9719251057" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="cf10eef3-cebf-4e5a-9b61-513006e72f2f" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="GBA" x="4078.57327558719" y="-1838.91417906439" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="grossBuildingArea;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="453022bb-860d-4177-82ce-88a7dcea4e91" type="DSIronPythonNode.PythonNode" nickname="Num Floors Each Block" x="4083.45971663218" y="-1570.44392182129" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flrList = IN[0]

out=[]
for i in range(len(flrList)):
	out.append(flrList[i].Count)


#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="0942b713-d985-4d61-a2d0-788908152b66" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Target Areas for Banks" x="5086.51771084312" y="-1882.06994672967" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="targetAreas[2];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="0b7f5ad5-a16d-4c3c-a42a-b482fd9378fe" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Updated UBA" x="5089.40798395103" y="-1780.29573586535" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="updatedUBA[3];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="407b1006-41a4-4600-b34e-baead4cfb0e7" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Served Areas by Banks" x="5088.87767873414" y="-1682.73700704693" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="servedAreas[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="73e95364-e73a-4337-9543-03a6a09286f9" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Ecap" x="4916.88324478303" y="-1782.57170008308" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="ecap= 1000;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="843c144f-6497-4e21-a4f6-a300e266a735" type="DSIronPythonNode.PythonNode" nickname="Feedback Function" x="5520.68280659308" y="-1643.87595164743" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

ubaListList 			= 	IN[0]
servedAreaListList		=	IN[1]
numElevPerBankList		=	IN[2]
ecap					=	IN[3]
buildSectionsList		=	IN[4]

#--------------------------------------------------------------------------------------------------------------------

# to compute the efficiency of set elevator layouts------------------------------------------------------------------
def feedBack():
	#make a list of area for building sections
	sections	= [0 for x in range(buildSections)]
	sections[0] = servedAreaList[0] # first building section area
	#isolated building section areas  
	totBankCap = 0
	for i in range(1,buildSections):
		sections[i] = servedAreaList[i] - servedAreaList[i-1]
		# total elevator bank capacity
		totBankCap  +=numElevPerBank[i]*ecap	
	#total UBA
	ubaTotal = 0
	for i in range(len(ubaList)):
		ubaTotal 	+=ubaList[i]
	
	#percentage of uba served by every bank
	percentUBA_Bank	= [0 for x in range(buildSections)]
	#used capacity of the banks
	ucap			= [0 for x in range(buildSections)]
	# added to test errors
	if totBankCap ==0 : totBankCap  =1
	for i in range(buildSections):
		percentUBA_Bank[i] = (sections[i]*100)/ubaTotal
		ucap[i] = (sections[i]*100)/totBankCap
	
	return percentUBA_Bank,ucap	
#--------------------------------------------------------------------------------------------------------------------	

"""
ubaListList 			= 	IN[0]
servedAreaListList		=	IN[1]
numElevPerBankList		=	IN[2]
ecap					=	IN[3]
buildSectionsList		=	IN[4]
"""
outF=[]
for i in range(len(ubaListList)):
	ubaL = ubaListList[i]
	buildSections = buildSectionsList[i]
	
	for j in range(len(ubaL)):
		ubaList = ubaL [j]
		servedAreaList = servedAreaListList[i][j]
		numElevPerBank = numElevPerBankList[i][j]		
		out = feedBack()
	outF.append(out)






#Assign your output to the OUT variable
OUT = outF</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="5d1b39b1-969d-4a26-a874-69696f624dd9" type="DSIronPythonNode.PythonNode" nickname="Final Num Elevators" x="5521.2182592939" y="-1808.11699710078" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

rectListList = IN[0]

finX = []

for i in range(len(rectListList)):# big blocks
	rectL = rectListList[i]
	x=0
	for j in range(len(rectL)):# num cores
		rec = rectL[j]
		x += len(rec[0])*len(rec)
	finX.append(x)

#Assign your output to the OUT variable
OUT = finX</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="80296a7c-3afc-47b9-b874-99ce710d86ee" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Key Floors" x="7918.42640884319" y="-1242.70559453997" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="keyFloors[0];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="65236426-c712-41c1-ab44-e91adffb856b" type="DSIronPythonNode.PythonNode" nickname="Key OutputGenerator" x="4907.73061714685" y="-1871.88164197629" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

keyList = IN[0]



#[key,servedAreaList,tarAreaList,ubaList]
finKeyList=[]
finServedAreaList = []
fintarAreaList = []
finubaList = []
for i in range(len(keyList)):
	keyL = keyList[i]
	finKeyL=[]
	finServedAreaL= []
	fintarAreaL = []
	finubaL = []
	for j in range(len(keyL)):
		key = keyL[j]
		finKeyL.append(key[0])
		finServedAreaL.append(key[1])
		fintarAreaL.append(key[2])
		finubaL.append(key[3])
	finKeyList.append(finKeyL)
	finServedAreaList.append(finServedAreaL)
	fintarAreaList.append(fintarAreaL)
	finubaList.append(finubaL)

out = finKeyList,finServedAreaList,fintarAreaList,finubaList
#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="fd242a9f-8214-48ad-9997-38fe4d82afe3" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Total Elevator Expected" x="5519.53767214468" y="-1958.28028235596" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="totElev_Expected;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="4847187c-ff80-484b-a041-d51d04c3e7cd" type="DSIronPythonNode.PythonNode" nickname="Variable height : Elevators" x="8763.05109654319" y="-1310.32493659352" isVisible="false" isUpstreamVisible="false" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floorsList		=	IN[0]
keyFloorsList	=	IN[1]
elevListList	=	IN[2]

def elevExtruder():
	extruded=[]
	keyFloors.reverse()
	p1		=	Point.ByCoordinates(0,0,0);
	p2		=	Point.ByCoordinates(0,0,100);
	vec		=	Vector.ByTwoPoints(p1,p2)
	for i in range(len(elevList)):
		flr = floors[keyFloors[i]]
		cen = flr.EndPoint
		zVal= cen.Z
		crv = elevList[i]
		geom=[]
		for j in range(len(crv)):
			ext	=	Curve.Extrude(crv[j],vec,zVal)		
			geom.append(ext)		
		extruded.append(geom)
	return extruded

finExt=[]
for i in range(len(elevListList)):
	floors = floorsList[i]	
	keyFloors = keyFloorsList[i]
	elevList = elevListList[i]
	extL=[]
	for j in range(len(elevList)):	
		keyFloors = keyFloorsList[i][j]
		elevList = elevListList[i][j]	
		ext = elevExtruder()
		extL.append(ext)
	finExt.append(extL)


#Assign your output to the OUT variable
OUT = finExt#finExt</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="79dde83d-39a3-4872-8118-5d8dc6101d79" type="Dynamo.Nodes.DSFunction" nickname="Face.Edges" x="9211.06315515421" y="-1354.31922923443" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Face.Edges" />
    <Dynamo.Nodes.DSFunction guid="6f53f637-8b26-4ad8-90a4-46e425884827" type="Dynamo.Nodes.DSFunction" nickname="Face.Vertices" x="9208.57342898791" y="-1262.91713119003" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Face.Vertices" />
    <Dynamo.Nodes.DSFunction guid="3b808e33-a864-4165-8669-fa53ecabe992" type="Dynamo.Nodes.DSFunction" nickname="Face.Vertices" x="9209.99427099931" y="-1447.62934501498" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Face.Vertices" />
    <Dynamo.Nodes.DSFunction guid="cf70bfbe-73be-410f-817f-f88ee98a5214" type="Dynamo.Nodes.DSFunction" nickname="Edge.CurveGeometry" x="9444.87353164331" y="-1383.51234891333" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Edge.CurveGeometry" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="327e7612-b223-493a-aedc-18d7691b3fd2" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Elev Points" x="9443.49593657471" y="-1290.43924492595" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a.PointGeometry;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="2bcf5d36-551b-40f4-a482-ef5eeb9bc5d0" type="DSIronPythonNode.PythonNode" nickname="PointFinder" x="9698.60479392191" y="-1198.26479960656" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

vertexList = IN[0]
tupleList = []
for i in range(len(vertexList)):
	ver = vertexList[i]
	for j in range(len(vertexList[i])):
		ver2 = ver[j]
		for k in range(len(ver2)):
			tup = (ver2[k].PointGeometry.X,ver2[k].PointGeometry.Y,ver2[k].PointGeometry.Z)
			tupleList.append(tup)


		


#Assign your output to the OUT variable
OUT = tupleList</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="2943aea0-09ee-49c4-9584-6a8876dbbb7e" type="DSIronPythonNode.PythonNode" nickname="PointFinder" x="9705.18227912101" y="-1478.10806559557" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

vertexList = IN[0]
tupleList = []
for i in range(len(vertexList)):
	ver = vertexList[i]
	for j in range(len(vertexList[i])):
		tup = (ver[j].PointGeometry.X,ver[j].PointGeometry.Y,ver[j].PointGeometry.Z)
		tupleList.append(tup)


		


#Assign your output to the OUT variable
OUT = tupleList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="ac397449-72b8-4053-8904-c07f461562a2" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="File Location" x="9702.97132668241" y="-1293.67094096022" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a={&quot;c:\write_Elevators.csv&quot;};" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="233e1889-93af-4320-8e13-3c884c7e0311" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="File Location" x="9702.97927216161" y="-1390.34238447695" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a={&quot;c:\write_ServiceModule.csv&quot;};" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="12939b65-2328-4bf0-804f-fe86f8bac92f" type="Dynamo.Nodes.DSFunction" nickname="CSV.WriteToFile" x="10114.1239819586" y="-1289.14932791315" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.IO.CSV.WriteToFile@string,var[][]" />
    <Dynamo.Nodes.DSFunction guid="d5d5782c-489e-4304-9b38-8b6a751471a6" type="Dynamo.Nodes.DSFunction" nickname="CSV.WriteToFile" x="10114.0398755965" y="-1412.34088460674" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.IO.CSV.WriteToFile@string,var[][]" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="7e69020c-148e-4bc9-979b-d596f5afed1f" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="TRANSLATED FLOORS" x="7913.23374458872" y="-1339.0564439604" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="FLOORS;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="85ef2fe9-43ab-415a-bebb-9b321b470057" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="TECHROOMS + RESTROOMS" x="7912.86781772604" y="-1428.77277141986" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="TECHRMS_RESTRMS;" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="a6487893-ff89-4a41-b247-0f175ebc4fad" type="Dynamo.Nodes.DSFunction" nickname="List.Transpose" x="8238.59970336049" y="-1431.93288593171" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.List.Transpose@var[]..[]" />
    <DSIronPythonNode.PythonNode guid="f851aa59-4231-4990-b812-3e292c8b9055" type="DSIronPythonNode.PythonNode" nickname="Extruded Tech Rooms" x="8758.84423296844" y="-1418.29312909595" isVisible="false" isUpstreamVisible="false" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floorsList		=	IN[0]
techRoomsList	=	IN[1]



def extruder():
	extruded=[]
	for i in range(len(techRooms)):
		flr = floors[-1]
		cen = flr.EndPoint
		zVal= cen.Z
		crv = techRooms[i]
		extN = crv.Extrude(zVal)
		extruded.append(extN)
	return extruded

finExt = []
for i in range(len(techRoomsList)):
	techRoomsL = techRoomsList[i]
	floors = floorsList[i]
	flr = floors[-1]	
	cen = flr.EndPoint
	zVal= cen.Z
	for j in range(len(techRoomsL)):		
		techRooms = techRoomsL[j]
		extruded=[]
		for k in range(len(techRooms)):
			techR = techRooms[k]		
			extN = techR.Extrude(zVal)
			extruded.append(extN)
		finExt.append(extruded)
		
		
#Assign your output to the OUT variable
OUT = finExt






"""
finExt=[]
for i in range(len(elevListList)):
	floors = floorsList[i]	
	elevList = elevListList[i]
	extL=[]
	for j in range(len(elevList)):	
		keyFloors = keyFloorsList[i][j]
		elevList = elevListList[i][j]	
		ext = elevExtruder()
		extL.append(ext)
	finExt.append(extL)
"""</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="9e449ec4-9deb-4ae6-b128-cb3bf5d6cd43" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="FLOOR PLATES" x="7907.61191857095" y="-1520.85470342431" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="floorSurface;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="b27f223e-ea50-44bf-9b3d-737999cef207" type="DSIronPythonNode.PythonNode" nickname="Python Script" x="1463.87687567385" y="-3397.30780519993" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


class div(object):
	pass
	
a = div()

a.X =10
#Assign your output to the OUT variable
OUT = div.__class__</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="28d06a4b-83af-430e-b24a-95451ef5cb10" type="DSIronPythonNode.PythonNode" nickname="Edge Picker" x="-150.174293264192" y="-1229.07861236689" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type = IN[1]
inputLen = IN[2]
coreDim = IN[3]


#finds number of closest rectangle pieces to find---------------------------------------------------------------------------------------------
def adjacencyList(type):
	adjList = []
	if type ==1: adjList = [0]
	if type ==2: adjList = [1,1]
	if type ==3: adjList = [1,2,1]
	if type ==4: adjList = [2,2,2,2]	
	return adjList
#---------------------------------------------------------------------------------------------------------------------------------------------



#find the common edges between two boxes------------------------------------------------------------------------------------------------------
def findCloseRects(boxList,type):
	indexList = []
	adjList = adjacencyList(type)
	distList=[]
	sortDistList = []
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		distL =[]
		sortL =[]
		indexL=[]		
		for j in range(len(boxList)):
			rec2 = boxList[j]
			recCen2 = rec2.Center()		
			dist = recCen.DistanceTo(recCen2)
			distL.append(dist)
		sortList = distL[:]
		sortList.sort()
		sortL.Add(sortList)
		sortDistList.Add(sortList)
		distList.Add(distL)
		
	indexList=[]
	for i in range(len(distList)):
		distL = distList[i]
		sortL = sortDistList[i]
		numAdj = adjList[i]
		indexL=[]
		for k in range(numAdj):			
			for j in range(len(distL)):			
				if sortL[k+1] == distL[j]:
					index = j
					indexL.append(index)
					break
		indexList.append(indexL)	
	return indexList
#---------------------------------------------------------------------------------------------------------------------------------------------
#finds the closest point from a list of points------------------------------------------------------------------------------------------------
def closestPoint(ptA,ptBList):
	distList=[]
	for i in range(len(ptBList)):
		ptB = ptBList[i]
		dist = ptA.DistanceTo(ptB)
		distList.append(dist)

	sortDistList = distList[:]
	sortDistList.sort()
	
	for i in range(len(sortDistList)):
		for j in range(len(sortDistList)):
			if sortDistList[0] == distList[j]: closePtList = ptBList[j]
		break
	return closePtList
#---------------------------------------------------------------------------------------------------------------------------------------------

def edgePicker(boxList,type):
	str = "did not enter"
	edgeList = findCommonEdges(boxList,type)
	finalRecLines=[]
	for i in range(len(boxList)):
		rec = boxList[i]
		recPts = rec.Points
		recLines = rec.Curves()
		list=[]		
		coprecLines = recLines[:]
		list.extend(coprecLines)
		edgeL = edgeList[i]
		pickedLines = []
		for k in range(len(edgeL)):			
			for j in range(len(list)):
				recL = recLines[j]
				rcStart = recL.StartPoint
				rcEnd	= recL.EndPoint
				rLine1 = Line.ByStartPointEndPoint(rcStart,rcEnd)
				rLine2 = Line.ByStartPointEndPoint(rcEnd,rcStart)
				#if rLine1.Length == edgeL[k].Length or rLine2.Length == edgeL[k].Length:
				if rLine1.Length == edgeL[k].Length and rLine1.PointAtParameter(0.5) == edgeL[k].PointAtParameter(0.5):
				#if edge1.PointAtParameter(0.5) == edge2.PointAtParameter(0.5) and edge1.Length == edge2.Length : 
				#if rLine1.PointAtParameter(0.5) == edgeL.PointAtParameter(0.5) and rLine1.Length == edgeL.Length : 
					str = "it entered"
					del list[j]	
					break
				else: pickedLines.Add(recL)
						
		finalRecLines.Add(list)
	if type == 4: del finalRecLines[3][-1]
	finalRecLines = convToLine(finalRecLines)
	return finalRecLines


#finds common edges between neighboring rect pieces---------------------------------------------------------------------------------------------
def findCommonEdges(boxList,type):
	TAG = 0
	edgeList = []
	closePtList = []
	indexList = findCloseRects(boxList,type)
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		recPts = rec.Points
		indexL = indexList[i]
		edgeL =[]
		closeL =[]
		for j in range(len(indexL)):
			ind = indexL[j]
			recSide = boxList[ind]
			recSideCen = recSide.Center()
			lin = Line.ByStartPointEndPoint(recCen,recSideCen)
			midPt = lin.PointAtParameter(0.5)
			recSidePts = recSide.Points
			closePt1 = closestPoint(midPt,recSidePts)
			closePt2 = closestPoint(midPt,recPts)
			closePt3 = closestPoint(closePt1,recPts)
			if closePt3 == closePt2 : 
				edge = Line.ByStartPointEndPoint(closePt1,closePt2)
				edge = edgeRedo(rec,edge)				
			else : 
				edge = Line.ByStartPointEndPoint(closePt3,closePt2)
			edgeL.Add(edge)
			closeL.Add([closePt1,closePt2])
		closePtList.Add(closeL)
		edgeL = edgeCleaner(edgeL)		
		edgeList.Add(edgeL)
		
	return edgeList
#----------------------------------------------------------------------------------------------------------------------------------------------

#to clean duplicate items in a list------------------------------------------------------------------------------------------------------------
def edgeCleaner(edgeList):
	copEdgeList = edgeList[:]
	if len(edgeList) &gt; 1:
		for i in range(len(edgeList)-1):		
			edge1 = edgeList[i]
			edge2 = edgeList[i+1]			
			if edge1.PointAtParameter(0.5) == edge2.PointAtParameter(0.5) and edge1.Length == edge2.Length : 
				del copEdgeList[i+1]		
	return copEdgeList
#----------------------------------------------------------------------------------------------------------------------------------------------
#to convert curves to lines--------------------------------------------------------------------------------------------------------------------
def convToLine(edgeList):
	lineList=[]
	for i in range(len(edgeList)):
		lineL=[]
		for j in range(len(edgeList[i])):
			lineL.Add(Line.ByStartPointEndPoint(edgeList[i][j].StartPoint,edgeList[i][j].EndPoint))
		lineList.Add(lineL)
	return lineList
#---------------------------------------------------------------------------------------------------------------------------------------------
#to compute the exact edge on the rec which corresponds to the common intersected edge found---------------------------------------------------
def edgeRedo(rec,edge):
	finalEdgeList = []
	recVecList = []
	recLineList = []
	vecEdge = Vector.ByTwoPoints(edge.StartPoint,edge.EndPoint)
	recPts  = rec.Points
	
	midEdge = edge.PointAtParameter(0.5)
	
	recVecList.Add(Vector.ByTwoPoints(recPts[0],recPts[1]))
	recVecList.Add(Vector.ByTwoPoints(recPts[1],recPts[2]))
	recVecList.Add(Vector.ByTwoPoints(recPts[2],recPts[3]))
	recVecList.Add(Vector.ByTwoPoints(recPts[3],recPts[0]))
	
	recLineList.append(Line.ByStartPointEndPoint(recPts[0],recPts[1]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[1],recPts[2]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[2],recPts[3]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[3],recPts[0]))
	
	newLineList=[]
	distList =[]
	for i in range(len(recVecList)):
		recVec = recVecList[i]
		ang = Vector.AngleBetween(vecEdge,recVec)
		finalEdgeList.append(ang)
		if int(ang) == 0 :
			mid = recLineList[i].PointAtParameter(0.5)
			dist = midEdge.DistanceTo(mid)
			distList.Add(dist)
			newLineList.Add(recLineList[i])
			
	checkDist = 10000000000000000000000	
	for i in range(len(newLineList)):
		if distList[i] &lt; checkDist:
			index = i
			checkDist = distList[i]			
	return newLineList[index]
#----------------------------------------------------------------------------------------------------------------------------------------------



#out = placeCoreBox(emptyBox)
out = edgePicker(emptyBox,type)
#out = findCommonEdges(emptyBox,type)
#Assign your output to the OUT variable
OUT = out
#OUT = polytoRect(emptyBox[0])</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="68c98145-0349-421f-a7ac-4403e41c7986" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Code Block" x="222.821583934045" y="-1535.8464367134" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="a6e42b9e-57c1-4793-b50b-6a3e0bbfc790" type="DSIronPythonNode.PythonNode" nickname="Core Placer Points" x="2056.52591628593" y="-2980.1693526958" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type     = IN[1]
inputLen = IN[2]
coreDim  = IN[3]
edgeList = IN[4]


#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	points = 	rec.Points
	diagDist = Line.ByStartPointEndPoint(points[0],points[2]).Length
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge,diagDist
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------


#makes the core rectangle based on number of req it has---------------------------------------------------------------------------------------
def makeCoreBox(rec,numCore,wid,ht,longEdge):
	coreList=[]
	cen = rec.Center()
	pts = rec.Points
	ptPlaceList = []
	#when just need to place one core
	if numCore ==1:
		cs = CoordinateSystem.ByOrigin(cen)
		coreRec= Rectangle.ByWidthHeight(cs,wid,ht)
		coreList.append(coreRec)
		ptPlaceList.append(cen)
	#when more than one core needs to be placed
	else:
		len1 = Line.ByStartPointEndPoint(pts[0],pts[1]).Length
		len2 = Line.ByStartPointEndPoint(pts[0],pts[3]).Length
		#find the longer edge and that line
		if len1 == longEdge:
			lin = Line.ByStartPointEndPoint(pts[0],pts[1])
		else:
			lin = Line.ByStartPointEndPoint(pts[0],pts[3])			
		linCen = lin.PointAtParameter(0.5)
		vec = Vector.ByTwoPoints(linCen,cen)
		linNew = lin.Translate(vec)
		#divide the line to get the points to place core		
		linNewLen = linNew.Length
		perDist = linNewLen/(numCore+1)
		
		#prepare the pointlist
		for i in range(numCore):
			pt = linNew.PointAtDistance((i+1)*perDist)
			ptPlaceList.append(pt)
	return ptPlaceList
#---------------------------------------------------------------------------------------------------------------------------------------------

# function which places core boxes into the empty boxes----------------------------------------------------------------------------------------
def getNumCores(boxList):		
	numCoresList=[]
	lenMeasure = inputLen
	wid = coreDim
	ht = coreDim
	for i in range(len(boxList)):
		rec = boxList[i]
		shortEdge = getShorterDim(rec)[0]
		longEdge = getShorterDim(rec)[1]
		diagDist = getShorterDim(rec)[2]
		if longEdge &gt; lenMeasure :
			numCore = int(math.ceil(longEdge/lenMeasure))	
		else :
			numCore=1
		numCoresList.append(numCore)
	return numCoresList
#----------------------------------------------------------------------------------------------------------------------------------------------




def placeCorePoints(boxList,edgeList):
	pointList=[]
	numCoreList = getNumCores(boxList)
	
	finCoreList=[]
	ptFinalList=[]
	for i in range(len(boxList)):
		edgeL = edgeList[i]
		recL = boxList[i]
		numCores = numCoreList[i]
		getCore = 0
		corePlaced =0
		coreList =[]
		count = 0
		while corePlaced &lt; numCores:
			#fill in 0 to initiate the coreList for 1st time
			if count == 0:
				for j in range(len(edgeL)):
					coreList.Add(0)				
			for j in range(len(edgeL)):
				corePlaced += 1
				if corePlaced &gt; numCores : break				
				coreList[j] += 1				
			count += 1
		finCoreList.Add(coreList)
		ptPlaceList = []
		for j in range(len(edgeL)):
			edge = edgeL[j]
			coresEdge = coreList[j]
			perDist = edge.Length/(coresEdge+1)	
			for k in range(coresEdge):
					
				pt = edge.PointAtDistance((k+1)*perDist)
				ptPlaceList.append(pt)
		ptFinalList.Add(ptPlaceList)
			
	 	
	return ptFinalList





out = placeCorePoints(emptyBox,edgeList)
#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" type="DSIronPythonNode.PythonNode" nickname="Service Core Components" x="3594.08108660206" y="-4515.56038766654" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="11">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flr_WidthList		=	IN[0]
flr_HeightList		=	IN[1]
twr_BaseptList		=	IN[2]
num_passElev		=	IN[3][0]
num_servElev		=	IN[3][1]

passElev_Area		=	IN[4]
servElev_Area		=	IN[4]
tag					=	IN[5]
elevWidth			=	IN[6][0]
elevLength			=	IN[6][1]
restroomProp		=	IN[7]
techrmProp			=	IN[8]
liftLobbyWidth		=	IN[9]
corePtList			=	IN[10]




#compute service core width, length, and serviceCore====================================================================================================
def serviceCoreMaker(ptL):
	global area_banks, area_restroom,area_servmodule
	#calc total area for service core for the tower
	serviceCore_Area 	= area_banks + area_restroom + area_servmodule;
	serviceCore_Area	= serviceCore_Area/len(ptL)
	area_banks			= area_banks/len(ptL)
	area_restroom		= area_restroom/len(ptL)
	area_servmodule		= area_servmodule/len(ptL)
	
	servCore_WidthL = []
	servCore_LengthL = []
	coreVerticesL = []
	b_FacL =[]
	serviceCore_RecL = []
	for i in range(len(ptL)):
		pt = ptL[i]			
		#calc aspect ratio of floor plate
		aspect_Ratio 		= 	flr_Width/flr_Height
		
		#adjust aspectratio
		if aspect_Ratio &lt; 0.65 : aspect_Ratio = 0.75
		if aspect_Ratio &gt; 1.3 : aspect_Ratio = 1.2
		#calc service core length and width
		servCore_Length 	=	math.sqrt(serviceCore_Area/aspect_Ratio)
		servCore_Width		=	serviceCore_Area/servCore_Length	
		
		servCore_Width		=	math.sqrt(serviceCore_Area/aspect_Ratio)
		servCore_Length 	=	serviceCore_Area/servCore_Width	
		
	
		# get the coordinates of center pt
		x,y,z 					= 	pt.X,pt.Y,pt.Z	
		#make the service core rectangle object--------------------------------------------------------------------------------------------------------------1
		cs					= 	CoordinateSystem.ByOrigin(x,y,z)
		serviceCore_Rec 	= 	Rectangle.ByWidthHeight(cs,servCore_Width,servCore_Length)
		serviceCore_Rec 	=	orientFixNEW(serviceCore_Rec,twr_Basept,pt,servCore_Width,servCore_Length)
		
		
		
		coreVertices		=	serviceCore_Rec.Points
		servCore_WidthL.append(servCore_Width)
		servCore_LengthL.append(servCore_Length)
		coreVerticesL.append(coreVertices)
		serviceCore_RecL.append(serviceCore_Rec)
	#comput elev bank factor--------------------------------------------------------------------
	b_Fac				=	area_banks/serviceCore_Area
	#return serviceCore_Rec,b_Fac,coreVertices,area_banks,area_banks,area_servmodule
	return servCore_WidthL,servCore_LengthL,coreVerticesL,b_Fac,serviceCore_RecL



#function to make boxes based off of width, length and vertices===========================================================================================
def makeBox(widthL,lengthL,verticesL,factor,tag):
	new_RecL=[]
	other_RecL=[]
	for i in range(len(widthL)):
		width = widthL[i]
		length = lengthL[i]
		vertices = verticesL[i]
		
		#calculate the shorter of width or height of service core
		if ( tag == 0):
			if (width &lt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2
		else:
			if (width &gt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2		
	
		
		cs1					= 	CoordinateSystem.ByOrigin(vertices[0].X,vertices[0].Y,0)
		cs2					= 	CoordinateSystem.ByOrigin(vertices[index].X,vertices[index].Y,0)
		# to make the primary rectangle ----------------------------------------------------------------------	
		new_Rec 			= 	Rectangle.ByWidthHeight(cs1,new_Width,new_Length)	
		new_Vec				= 	Vector.ByTwoPoints(new_Rec.Points[0],vertices[0])
		new_Rec				=	Geometry.Translate(new_Rec, new_Vec)
		ptsnew_Rec			=	new_Rec.Points
		# to make the secondary rectangle ----------------------------------------------------------------------	
		other_Rec 			= 	Rectangle.ByWidthHeight(cs2,other_Width,other_Length)	
		other_Vec			= 	Vector.ByTwoPoints(other_Rec.Points[index],vertices[index])
		other_Rec			=	Geometry.Translate(other_Rec, other_Vec)
		ptsother_Rec		=	other_Rec.Points
		
		new_RecL.append(new_Rec)
		other_RecL.append(other_Rec)
	
	return [new_RecL,other_RecL]
#============================================================================================================================================================



#make post computations======================================================================================================================================
def coreConfigurator(b_Fac):
	#make the elevator bank rectangle object-----------------------------------------------------1	
	bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
	bank_RecLNew = []
	for i in range(len(bank_RecL)):
		bank_Rec = 	bank_RecL[i]
		widtry1				=	bank_Rec[0].Width
		lentry1				=	bank_Rec[0].Height
				
		# code to readjust the bank rectangle piece based on the final tech rooms and restroom blocks
		if ( widtry1&lt;lentry1):
			shortEdge		=	widtry1
			marked			=	0	
		else:
			shortEdge		=	lentry1
			marked			=	1
				
		if (elevWidth&lt;elevLength):elevEdge = elevWidth
		else:elevEdge =	elevLength			
		numE				=	int(shortEdge / elevEdge)
		numE				+=	1
			
		newDim				=	numE*elevEdge
		if ( marked ==0): ratio	= widtry1/newDim
		else: ratio	= lentry1/newDim
		b_Fac				=	ratio*b_Fac
		#bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
		
	return bank_RecL
	#-------------------------------------------------------------------------------------------------
#============================================================================================================================================================
#to fix the orientation of the serviceCores-----------------------------------------------------------
def orientFixNEW(servCore,twr_Basept,crPt,wid,ht):
	vecX = Vector.XAxis()
	vecY = Vector.YAxis()
	
	vecMain = Vector.ByTwoPoints(crPt,twr_Basept)
	vecMainNormal = vecMain.Normalized()
	
	valX = vecMainNormal.X * vecX.X
	valY = vecMainNormal.Y * vecX.Y
	
	if valX &lt; 0 or valY &lt; 0:
		vecX = vecX.Reverse()
		vecY = vecY.Reverse()
		
	angX = Vector.AngleBetween(vecMain,vecX) 
	angY = Vector.AngleBetween(vecMain,vecY)
	if angX &lt; 50 and angY &gt; 10:
		vecMain = vecX.Scale(wid/2)		
		servCore = servCore.Translate(vecMain)
	else:
		vecMain = vecY.Scale(ht/2)
		servCore = servCore.Translate(vecMain)
	return servCore
#-----------------------------------------------------------------------------------------------------


#iterate through all the blocks and output lists for each---------------------------------------------
outList=[]
bankRecList= []
otherRecList=[]
areaRestrmList=[]
areaServModList=[]
servCoreList=[]

perc = 1.1

for i in range(len(twr_BaseptList)):

	flr_Width  = flr_WidthList[i]
	flr_Height = flr_HeightList[i]
	twr_Basept = twr_BaseptList[i]
	corePts	   = corePtList[i]
	
	#globals var, computer area banks, area restrm, area techrms--------------------------------------------------------------------------------------------
	cirProp = liftLobbyWidth/1.5
	
	area_banks			= servElev_Area*num_servElev[i]/perc + passElev_Area*num_passElev[i]/perc
	area_banks			+=cirProp*area_banks # added the circulation area
	area_restroom 		= restroomProp*area_banks								
	area_servmodule 	= techrmProp*area_banks
	
	
	#OUTPUT VALUES-------------------------------------------------------
	vals 				= 	serviceCoreMaker(corePts)
	servCore_Width		=	vals[0]
	servCore_Length		=	vals[1]
	coreVertices		=	vals[2]
	b_Fac				=	vals[3]
	serviceCore_Rec		=	vals[4]
	bank_Rec 			= 	coreConfigurator(b_Fac)	
	
	#bankRecList.append(bank_Rec[0])
	#otherRecList.append(bank_Rec[1])
	#areaRestrmList.append(area_restroom)
	#areaServModList.append(area_servmodule)
	servCoreList.append(serviceCore_Rec)
	
	

#out = bankRecList,otherRecList,areaRestrmList,areaServModList,servCoreList

out = servCoreList,flr_WidthList[0]/flr_HeightList[0]
#Assign your output to the OUT variable
OUT = out
#OUT = flr_WidthList,flr_HeightList
</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="443c0dc0-da7d-41f4-a950-a208fc3de5e9" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Code Block" x="52.0748263436644" y="-1182.62865321364" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[3];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="f5f99c60-1202-416d-9855-b37d8d0e5ddb" type="DSIronPythonNode.PythonNode" nickname="Edge Picker" x="-148.385534059032" y="-1060.80241929711" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type = IN[1]
inputLen = IN[2]
coreDim = IN[3]


#finds number of closest rectangle pieces to find---------------------------------------------------------------------------------------------
def adjacencyList(type):
	adjList = []
	if type ==1: adjList = [0]
	if type ==2: adjList = [1,1]
	if type ==3: adjList = [1,2,1]
	if type ==4: adjList = [2,2,2,2]	
	return adjList
#---------------------------------------------------------------------------------------------------------------------------------------------



#find the common edges between two boxes------------------------------------------------------------------------------------------------------
def findCloseRects(boxList,type):
	indexList = []
	adjList = adjacencyList(type)
	distList=[]
	sortDistList = []
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		distL =[]
		sortL =[]
		indexL=[]		
		for j in range(len(boxList)):
			rec2 = boxList[j]
			recCen2 = rec2.Center()		
			dist = recCen.DistanceTo(recCen2)
			distL.append(dist)
		sortList = distL[:]
		sortList.sort()
		sortL.Add(sortList)
		sortDistList.Add(sortList)
		distList.Add(distL)
		
	indexList=[]
	for i in range(len(distList)):
		distL = distList[i]
		sortL = sortDistList[i]
		numAdj = adjList[i]
		indexL=[]
		for k in range(numAdj):			
			for j in range(len(distL)):			
				if sortL[k+1] == distL[j]:
					index = j
					indexL.append(index)
					break
		indexList.append(indexL)	
	return indexList
#---------------------------------------------------------------------------------------------------------------------------------------------
#finds the closest point from a list of points------------------------------------------------------------------------------------------------
def closestPoint(ptA,ptBList):
	distList=[]
	for i in range(len(ptBList)):
		ptB = ptBList[i]
		dist = ptA.DistanceTo(ptB)
		distList.append(dist)

	sortDistList = distList[:]
	sortDistList.sort()
	
	for i in range(len(sortDistList)):
		for j in range(len(sortDistList)):
			if sortDistList[0] == distList[j]: closePtList = ptBList[j]
		break
	return closePtList
#---------------------------------------------------------------------------------------------------------------------------------------------

def edgePicker(boxList,type):
	str = "did not enter"
	edgeList = findCommonEdges(boxList,type)
	finalRecLines=[]
	for i in range(len(boxList)):
		rec = boxList[i]
		recPts = rec.Points
		recLines = rec.Curves()
		list=[]		
		coprecLines = recLines[:]
		list.extend(coprecLines)
		edgeL = edgeList[i]
		pickedLines = []
		for k in range(len(edgeL)):			
			for j in range(len(list)):
				recL = recLines[j]
				rcStart = recL.StartPoint
				rcEnd	= recL.EndPoint
				rLine1 = Line.ByStartPointEndPoint(rcStart,rcEnd)
				rLine2 = Line.ByStartPointEndPoint(rcEnd,rcStart)
				#if rLine1.Length == edgeL[k].Length or rLine2.Length == edgeL[k].Length:
				if rLine1.Length == edgeL[k].Length and rLine1.PointAtParameter(0.5) == edgeL[k].PointAtParameter(0.5):
				#if edge1.PointAtParameter(0.5) == edge2.PointAtParameter(0.5) and edge1.Length == edge2.Length : 
				#if rLine1.PointAtParameter(0.5) == edgeL.PointAtParameter(0.5) and rLine1.Length == edgeL.Length : 
					str = "it entered"
					del list[j]	
					break
				else: pickedLines.Add(recL)
						
		finalRecLines.Add(list)
	if type == 4: del finalRecLines[3][-1]
	finalRecLines = convToLine(finalRecLines)
	return finalRecLines


#finds common edges between neighboring rect pieces---------------------------------------------------------------------------------------------
def findCommonEdges(boxList,type):
	TAG = 0
	edgeList = []
	closePtList = []
	indexList = findCloseRects(boxList,type)
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		recPts = rec.Points
		indexL = indexList[i]
		edgeL =[]
		closeL =[]
		for j in range(len(indexL)):
			ind = indexL[j]
			recSide = boxList[ind]
			recSideCen = recSide.Center()
			lin = Line.ByStartPointEndPoint(recCen,recSideCen)
			midPt = lin.PointAtParameter(0.5)
			recSidePts = recSide.Points
			closePt1 = closestPoint(midPt,recSidePts)
			closePt2 = closestPoint(midPt,recPts)
			closePt3 = closestPoint(closePt1,recPts)
			if closePt3 == closePt2 : 
				edge = Line.ByStartPointEndPoint(closePt1,closePt2)
				edge = edgeRedo(rec,edge)				
			else : 
				edge = Line.ByStartPointEndPoint(closePt3,closePt2)
			edgeL.Add(edge)
			closeL.Add([closePt1,closePt2])
		closePtList.Add(closeL)
		edgeL = edgeCleaner(edgeL)		
		edgeList.Add(edgeL)
		
	return edgeList
#----------------------------------------------------------------------------------------------------------------------------------------------

#to clean duplicate items in a list------------------------------------------------------------------------------------------------------------
def edgeCleaner(edgeList):
	copEdgeList = edgeList[:]
	if len(edgeList) &gt; 1:
		for i in range(len(edgeList)-1):		
			edge1 = edgeList[i]
			edge2 = edgeList[i+1]			
			if edge1.PointAtParameter(0.5) == edge2.PointAtParameter(0.5) and edge1.Length == edge2.Length : 
				del copEdgeList[i+1]		
	return copEdgeList
#----------------------------------------------------------------------------------------------------------------------------------------------
#to convert curves to lines--------------------------------------------------------------------------------------------------------------------
def convToLine(edgeList):
	lineList=[]
	for i in range(len(edgeList)):
		lineL=[]
		for j in range(len(edgeList[i])):
			lineL.Add(Line.ByStartPointEndPoint(edgeList[i][j].StartPoint,edgeList[i][j].EndPoint))
		lineList.Add(lineL)
	return lineList
#---------------------------------------------------------------------------------------------------------------------------------------------
#to compute the exact edge on the rec which corresponds to the common intersected edge found---------------------------------------------------
def edgeRedo(rec,edge):
	finalEdgeList = []
	recVecList = []
	recLineList = []
	vecEdge = Vector.ByTwoPoints(edge.StartPoint,edge.EndPoint)
	recPts  = rec.Points
	
	midEdge = edge.PointAtParameter(0.5)
	
	recVecList.Add(Vector.ByTwoPoints(recPts[0],recPts[1]))
	recVecList.Add(Vector.ByTwoPoints(recPts[1],recPts[2]))
	recVecList.Add(Vector.ByTwoPoints(recPts[2],recPts[3]))
	recVecList.Add(Vector.ByTwoPoints(recPts[3],recPts[0]))
	
	recLineList.append(Line.ByStartPointEndPoint(recPts[0],recPts[1]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[1],recPts[2]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[2],recPts[3]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[3],recPts[0]))
	
	newLineList=[]
	distList =[]
	for i in range(len(recVecList)):
		recVec = recVecList[i]
		ang = Vector.AngleBetween(vecEdge,recVec)
		finalEdgeList.append(ang)
		if int(ang) == 0 :
			mid = recLineList[i].PointAtParameter(0.5)
			dist = midEdge.DistanceTo(mid)
			distList.Add(dist)
			newLineList.Add(recLineList[i])
			
	checkDist = 10000000000000000000000	
	for i in range(len(newLineList)):
		if distList[i] &lt; checkDist:
			index = i
			checkDist = distList[i]			
	return newLineList[index]
#----------------------------------------------------------------------------------------------------------------------------------------------




#out = edgePicker(emptyBox,type)
out = findCommonEdges(emptyBox,type)
#Assign your output to the OUT variable
OUT = out
#OUT = polytoRect(emptyBox[0])</Script>
    </DSIronPythonNode.PythonNode>
  </Elements>
  <Connectors>
    <Dynamo.Models.ConnectorModel start="1215010b-2f5d-4031-8865-d1c64d5151a7" start_index="0" end="6d6686be-118d-46d6-a994-4aec80e4691a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="1215010b-2f5d-4031-8865-d1c64d5151a7" start_index="0" end="1f734656-1cf4-4c79-ac60-f31b460bff82" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="31bb949a-db78-4b30-9486-d6b50b132395" start_index="0" end="13335fdd-daad-4d4b-81a4-7415b119810a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="31bb949a-db78-4b30-9486-d6b50b132395" start_index="0" end="69fbd0c3-ab9b-4c1b-9fe6-824966b589d8" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="31bb949a-db78-4b30-9486-d6b50b132395" start_index="0" end="8b49b492-b142-4d57-9a20-7e76fe56402f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="31bb949a-db78-4b30-9486-d6b50b132395" start_index="0" end="e6088aed-cd01-4cea-b17d-b4d9d9b79fff" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="31bb949a-db78-4b30-9486-d6b50b132395" start_index="0" end="fc1df022-d893-4b5d-acd6-fa0152d38f15" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2aa2aa0b-051f-40d7-aa9e-5cb0b5ba33a3" start_index="0" end="3719525c-c82d-4453-b8cf-6bb58712191e" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="3719525c-c82d-4453-b8cf-6bb58712191e" start_index="0" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="3719525c-c82d-4453-b8cf-6bb58712191e" start_index="0" end="7a52859d-1b63-4175-941c-d818a21ef584" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="3719525c-c82d-4453-b8cf-6bb58712191e" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="3719525c-c82d-4453-b8cf-6bb58712191e" start_index="0" end="599e3168-7c24-413f-8b77-44a84794b0ab" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="3719525c-c82d-4453-b8cf-6bb58712191e" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="868a7954-8eff-428e-861d-790b11492e06" start_index="0" end="eafc1115-3510-4d68-8c8e-7309ce1612f4" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="868a7954-8eff-428e-861d-790b11492e06" start_index="0" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="868a7954-8eff-428e-861d-790b11492e06" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="868a7954-8eff-428e-861d-790b11492e06" start_index="0" end="5fd5f97b-8669-4122-b0e9-61bf955b422a" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="868a7954-8eff-428e-861d-790b11492e06" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="d94d7fa2-d56d-4288-a216-c619b46762e3" start_index="0" end="ecd46302-783f-4a29-a72b-c026b571474a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="d94d7fa2-d56d-4288-a216-c619b46762e3" start_index="1" end="e2654352-d2ab-4547-ba84-d9bd4cae7cfb" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="df71274b-f488-4028-9e87-f8d8359aa7be" start_index="0" end="eafc1115-3510-4d68-8c8e-7309ce1612f4" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="17c365fa-6824-4153-83c1-47c2ffc01510" start_index="0" end="eafc1115-3510-4d68-8c8e-7309ce1612f4" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="519e821b-1d37-46f0-9e2d-474c06308025" start_index="0" end="7e3fd7a4-701d-4426-aa25-86615b917980" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="519e821b-1d37-46f0-9e2d-474c06308025" start_index="0" end="d94d7fa2-d56d-4288-a216-c619b46762e3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="519e821b-1d37-46f0-9e2d-474c06308025" start_index="0" end="17c365fa-6824-4153-83c1-47c2ffc01510" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="519e821b-1d37-46f0-9e2d-474c06308025" start_index="0" end="69fbd0c3-ab9b-4c1b-9fe6-824966b589d8" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="3466cc6e-609e-4110-93b0-c477fb202f21" start_index="0" end="519e821b-1d37-46f0-9e2d-474c06308025" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="3466cc6e-609e-4110-93b0-c477fb202f21" start_index="0" end="ef72918a-b669-447f-a00d-8cfd310acee0" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="6fb2b54b-2df0-4aba-bbf1-6541b826e769" start_index="0" end="519e821b-1d37-46f0-9e2d-474c06308025" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="78ce0e7e-888c-4504-a82b-3a143ce68e00" start_index="0" end="1a6b4d4c-dc6d-4243-a7c3-1f882a9c95cd" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="78ce0e7e-888c-4504-a82b-3a143ce68e00" start_index="0" end="7a52859d-1b63-4175-941c-d818a21ef584" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="ac550d14-fe5f-4c02-b394-9c4a8baa43a0" start_index="0" end="7a52859d-1b63-4175-941c-d818a21ef584" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="ac550d14-fe5f-4c02-b394-9c4a8baa43a0" start_index="0" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="9" portType="0" />
    <Dynamo.Models.ConnectorModel start="ac550d14-fe5f-4c02-b394-9c4a8baa43a0" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="9" portType="0" />
    <Dynamo.Models.ConnectorModel start="ac550d14-fe5f-4c02-b394-9c4a8baa43a0" start_index="0" end="599e3168-7c24-413f-8b77-44a84794b0ab" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="ac550d14-fe5f-4c02-b394-9c4a8baa43a0" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="9" portType="0" />
    <Dynamo.Models.ConnectorModel start="3c9da584-a4a5-4e65-bc78-7a785395b657" start_index="0" end="3719525c-c82d-4453-b8cf-6bb58712191e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="3c9da584-a4a5-4e65-bc78-7a785395b657" start_index="0" end="ef72918a-b669-447f-a00d-8cfd310acee0" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="3c9da584-a4a5-4e65-bc78-7a785395b657" start_index="0" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="3c9da584-a4a5-4e65-bc78-7a785395b657" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="3c9da584-a4a5-4e65-bc78-7a785395b657" start_index="0" end="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="3c9da584-a4a5-4e65-bc78-7a785395b657" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="f4662ef7-4920-491c-a08c-e9eb9912d8a8" start_index="0" end="965529b5-5b27-4c42-941b-b8a8ca5b0c1a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="f4662ef7-4920-491c-a08c-e9eb9912d8a8" start_index="0" end="7a52859d-1b63-4175-941c-d818a21ef584" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0a963c9b-1586-4265-9afa-a81149db1a64" start_index="0" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0a963c9b-1586-4265-9afa-a81149db1a64" start_index="1" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="6b338560-d7b0-4500-b5a8-4f4fabbf061e" start_index="0" end="78ce0e7e-888c-4504-a82b-3a143ce68e00" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6b338560-d7b0-4500-b5a8-4f4fabbf061e" start_index="0" end="7cd45512-ef89-4748-a371-3b9879106126" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="6b338560-d7b0-4500-b5a8-4f4fabbf061e" start_index="0" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="eee08eff-9c8c-496b-bbec-e2f98c0879e3" start_index="0" end="6b338560-d7b0-4500-b5a8-4f4fabbf061e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="644044fb-8de2-498c-a80e-61f00a8304b1" start_index="0" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="0" end="7cd45512-ef89-4748-a371-3b9879106126" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="0" end="df536c34-da96-4eaa-b92a-696e8d018c16" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="1" end="6b338560-d7b0-4500-b5a8-4f4fabbf061e" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="1" end="8d4d07be-682a-42eb-af22-21e2671b1bef" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="2" end="6b338560-d7b0-4500-b5a8-4f4fabbf061e" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="2" end="8d4d07be-682a-42eb-af22-21e2671b1bef" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="3" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="7" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="3" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="7" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="3" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="7" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="4" end="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" end_index="8" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="4" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="8" portType="0" />
    <Dynamo.Models.ConnectorModel start="f685c6ad-e63d-4638-8f0c-4d5409cf4563" start_index="4" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="8" portType="0" />
    <Dynamo.Models.ConnectorModel start="57a39e1e-ddd6-4efd-8688-d715c01567b7" start_index="0" end="eee08eff-9c8c-496b-bbec-e2f98c0879e3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="57a39e1e-ddd6-4efd-8688-d715c01567b7" start_index="0" end="e2042bb0-8b22-4aa4-b519-98480ec70f3d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="13335fdd-daad-4d4b-81a4-7415b119810a" start_index="0" end="57a39e1e-ddd6-4efd-8688-d715c01567b7" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc863909-cdb2-4d4c-ac70-cdab5f1f9db2" start_index="0" end="31bb949a-db78-4b30-9486-d6b50b132395" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9888c44e-071c-4dac-8296-fc1e86caef71" start_index="0" end="31bb949a-db78-4b30-9486-d6b50b132395" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="9888c44e-071c-4dac-8296-fc1e86caef71" start_index="0" end="94ab79e8-a180-4b5c-a0d5-39c2d482b0d0" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="9888c44e-071c-4dac-8296-fc1e86caef71" start_index="1" end="94ab79e8-a180-4b5c-a0d5-39c2d482b0d0" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="9888c44e-071c-4dac-8296-fc1e86caef71" start_index="2" end="94ab79e8-a180-4b5c-a0d5-39c2d482b0d0" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="94ab79e8-a180-4b5c-a0d5-39c2d482b0d0" start_index="0" end="1841d5de-fcb3-4383-b3d2-62e7b2c616d9" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="94ab79e8-a180-4b5c-a0d5-39c2d482b0d0" start_index="0" end="fd117d31-8e65-4d23-9a95-094818c41d5e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="1841d5de-fcb3-4383-b3d2-62e7b2c616d9" start_index="0" end="2c8d025a-aa71-4a05-a811-2f4ab67a59bc" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0492db29-5a6a-48ac-90d2-f75c87c87420" start_index="0" end="0351702e-293c-4b99-b97a-db41c0312f88" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="0492db29-5a6a-48ac-90d2-f75c87c87420" start_index="0" end="644044fb-8de2-498c-a80e-61f00a8304b1" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0351702e-293c-4b99-b97a-db41c0312f88" start_index="0" end="2c8d025a-aa71-4a05-a811-2f4ab67a59bc" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="87bbebfa-dfb4-4e25-af0f-22796d78458c" start_index="0" end="0351702e-293c-4b99-b97a-db41c0312f88" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="351c1480-1635-4d4b-b388-cc1dbc2b5207" start_index="0" end="81a0f2da-508b-42b2-8f49-c8e486eb00a9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="351c1480-1635-4d4b-b388-cc1dbc2b5207" start_index="1" end="bede10e0-df9b-456e-b9c1-3c8bd579ca75" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="351c1480-1635-4d4b-b388-cc1dbc2b5207" start_index="1" end="81a0f2da-508b-42b2-8f49-c8e486eb00a9" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="351c1480-1635-4d4b-b388-cc1dbc2b5207" start_index="2" end="bede10e0-df9b-456e-b9c1-3c8bd579ca75" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="351c1480-1635-4d4b-b388-cc1dbc2b5207" start_index="2" end="81a0f2da-508b-42b2-8f49-c8e486eb00a9" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="351c1480-1635-4d4b-b388-cc1dbc2b5207" start_index="3" end="bede10e0-df9b-456e-b9c1-3c8bd579ca75" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="351c1480-1635-4d4b-b388-cc1dbc2b5207" start_index="4" end="87bbebfa-dfb4-4e25-af0f-22796d78458c" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="bede10e0-df9b-456e-b9c1-3c8bd579ca75" start_index="0" end="4300f65b-4327-47a7-8fad-d1b6b68af639" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="81a0f2da-508b-42b2-8f49-c8e486eb00a9" start_index="0" end="4300f65b-4327-47a7-8fad-d1b6b68af639" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4300f65b-4327-47a7-8fad-d1b6b68af639" start_index="0" end="1841d5de-fcb3-4383-b3d2-62e7b2c616d9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4300f65b-4327-47a7-8fad-d1b6b68af639" start_index="0" end="87bbebfa-dfb4-4e25-af0f-22796d78458c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2c8d025a-aa71-4a05-a811-2f4ab67a59bc" start_index="0" end="fc863909-cdb2-4d4c-ac70-cdab5f1f9db2" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="191b539b-f6ef-44b3-9c4b-277a50a880be" start_index="0" end="043ebc1a-c018-4a5a-8146-85aff541e8a3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="5c214bfd-bd00-4a41-8a47-68a419c6b490" start_index="0" end="c3e371b9-4add-43b6-a538-dfb574d9aa75" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="6f820a01-981b-4a7e-a76e-fe1a62d98c11" start_index="0" end="c3e371b9-4add-43b6-a538-dfb574d9aa75" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="c3e371b9-4add-43b6-a538-dfb574d9aa75" start_index="0" end="191b539b-f6ef-44b3-9c4b-277a50a880be" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="3d465364-d22c-429a-9bba-4a6a7cd5438f" start_index="0" end="94ab79e8-a180-4b5c-a0d5-39c2d482b0d0" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="3d465364-d22c-429a-9bba-4a6a7cd5438f" start_index="0" end="49ac0fec-0f03-4167-9c8e-afe6ea4472fd" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="c56aeef4-0c0c-42cb-916a-7f17c965c50c" start_index="0" end="d649c12c-2eed-414e-9284-e60bf8463043" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="c56aeef4-0c0c-42cb-916a-7f17c965c50c" start_index="1" end="d649c12c-2eed-414e-9284-e60bf8463043" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="c56aeef4-0c0c-42cb-916a-7f17c965c50c" start_index="2" end="d649c12c-2eed-414e-9284-e60bf8463043" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="d649c12c-2eed-414e-9284-e60bf8463043" start_index="0" end="1841d5de-fcb3-4383-b3d2-62e7b2c616d9" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="d649c12c-2eed-414e-9284-e60bf8463043" start_index="0" end="c3e371b9-4add-43b6-a538-dfb574d9aa75" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="d649c12c-2eed-414e-9284-e60bf8463043" start_index="0" end="49ac0fec-0f03-4167-9c8e-afe6ea4472fd" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="49ac0fec-0f03-4167-9c8e-afe6ea4472fd" start_index="0" end="6f820a01-981b-4a7e-a76e-fe1a62d98c11" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="49ac0fec-0f03-4167-9c8e-afe6ea4472fd" start_index="0" end="c3e371b9-4add-43b6-a538-dfb574d9aa75" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="00c9bc5f-de66-45e0-979a-d7686efe103f" start_index="0" end="0a963c9b-1586-4265-9afa-a81149db1a64" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="00c9bc5f-de66-45e0-979a-d7686efe103f" start_index="0" end="2958c653-21b8-4497-b7ad-a1fda207a0a4" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="9d25d391-50c9-4f8c-8484-531fa64ade08" start_index="0" end="0a963c9b-1586-4265-9afa-a81149db1a64" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9d25d391-50c9-4f8c-8484-531fa64ade08" start_index="0" end="2958c653-21b8-4497-b7ad-a1fda207a0a4" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="0c800683-32ce-4713-8728-412bd1bdcdac" start_index="0" end="06023a06-715f-4fd3-90b4-f1c570905900" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="7c51fc59-9cbe-4d7d-8873-d2aadd775f6f" start_index="0" end="06023a06-715f-4fd3-90b4-f1c570905900" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="15b1af56-37b0-4527-b70b-9277bfcef748" start_index="0" end="06023a06-715f-4fd3-90b4-f1c570905900" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="06023a06-715f-4fd3-90b4-f1c570905900" start_index="0" end="2958c653-21b8-4497-b7ad-a1fda207a0a4" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2958c653-21b8-4497-b7ad-a1fda207a0a4" start_index="0" end="df71274b-f488-4028-9e87-f8d8359aa7be" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2958c653-21b8-4497-b7ad-a1fda207a0a4" start_index="0" end="0492db29-5a6a-48ac-90d2-f75c87c87420" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2958c653-21b8-4497-b7ad-a1fda207a0a4" start_index="0" end="191b539b-f6ef-44b3-9c4b-277a50a880be" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2958c653-21b8-4497-b7ad-a1fda207a0a4" start_index="0" end="49ac0fec-0f03-4167-9c8e-afe6ea4472fd" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="043ebc1a-c018-4a5a-8146-85aff541e8a3" start_index="0" end="2c8d025a-aa71-4a05-a811-2f4ab67a59bc" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="df536c34-da96-4eaa-b92a-696e8d018c16" start_index="0" end="1215010b-2f5d-4031-8865-d1c64d5151a7" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="df536c34-da96-4eaa-b92a-696e8d018c16" start_index="0" end="ef72918a-b669-447f-a00d-8cfd310acee0" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="df536c34-da96-4eaa-b92a-696e8d018c16" start_index="0" end="d61ada97-160e-4cc5-9377-0ea62127d10f" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="6d6686be-118d-46d6-a994-4aec80e4691a" start_index="0" end="8b49b492-b142-4d57-9a20-7e76fe56402f" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="6d6686be-118d-46d6-a994-4aec80e4691a" start_index="0" end="e6088aed-cd01-4cea-b17d-b4d9d9b79fff" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef72918a-b669-447f-a00d-8cfd310acee0" start_index="0" end="f4310a55-4c53-4646-8d44-a4f198fa380a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef72918a-b669-447f-a00d-8cfd310acee0" start_index="0" end="c8373d8a-851e-4e55-ac8b-cff74640b57a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef72918a-b669-447f-a00d-8cfd310acee0" start_index="0" end="c23e9a7b-225e-40d2-b26d-d9b1be0e3316" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef72918a-b669-447f-a00d-8cfd310acee0" start_index="0" end="9669aebe-ed53-47aa-9a1d-bc356d0580bb" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="e2042bb0-8b22-4aa4-b519-98480ec70f3d" start_index="0" end="ef72918a-b669-447f-a00d-8cfd310acee0" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="1f734656-1cf4-4c79-ac60-f31b460bff82" start_index="0" end="ef72918a-b669-447f-a00d-8cfd310acee0" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="1f734656-1cf4-4c79-ac60-f31b460bff82" start_index="0" end="d61ada97-160e-4cc5-9377-0ea62127d10f" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="2beb0bf4-f5d7-44c8-91f9-a8a1a413d450" start_index="0" end="ef72918a-b669-447f-a00d-8cfd310acee0" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="f4310a55-4c53-4646-8d44-a4f198fa380a" start_index="0" end="69fbd0c3-ab9b-4c1b-9fe6-824966b589d8" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f4310a55-4c53-4646-8d44-a4f198fa380a" start_index="0" end="e6088aed-cd01-4cea-b17d-b4d9d9b79fff" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f4310a55-4c53-4646-8d44-a4f198fa380a" start_index="0" end="8b49b492-b142-4d57-9a20-7e76fe56402f" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="c8373d8a-851e-4e55-ac8b-cff74640b57a" start_index="0" end="d61ada97-160e-4cc5-9377-0ea62127d10f" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="9669aebe-ed53-47aa-9a1d-bc356d0580bb" start_index="0" end="d61ada97-160e-4cc5-9377-0ea62127d10f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="5ed402a7-b681-4ec5-92c3-4f15602c210e" start_index="0" end="d61ada97-160e-4cc5-9377-0ea62127d10f" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="69fbd0c3-ab9b-4c1b-9fe6-824966b589d8" start_index="0" end="82a78431-e853-4bf9-8bc8-eb19694c9184" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="5d65b5cc-e8b5-4ff7-9eb3-6ee300e40102" start_index="0" end="965529b5-5b27-4c42-941b-b8a8ca5b0c1a" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="5d65b5cc-e8b5-4ff7-9eb3-6ee300e40102" start_index="0" end="519e821b-1d37-46f0-9e2d-474c06308025" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="5d65b5cc-e8b5-4ff7-9eb3-6ee300e40102" start_index="0" end="7a52859d-1b63-4175-941c-d818a21ef584" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="965529b5-5b27-4c42-941b-b8a8ca5b0c1a" start_index="0" end="7a52859d-1b63-4175-941c-d818a21ef584" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="965529b5-5b27-4c42-941b-b8a8ca5b0c1a" start_index="0" end="bec4aee5-3a30-4c24-999d-f9f353df762d" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="8b49b492-b142-4d57-9a20-7e76fe56402f" start_index="0" end="f7ffaa2d-edb3-41ba-8ea0-33db2de8b74c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8b49b492-b142-4d57-9a20-7e76fe56402f" start_index="0" end="5cc01002-4f78-47d5-8f54-af496dcb6cf7" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="f7ffaa2d-edb3-41ba-8ea0-33db2de8b74c" start_index="0" end="5639114f-565c-4864-9ab2-5ffbd28b4946" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc1df022-d893-4b5d-acd6-fa0152d38f15" start_index="0" end="332db295-1b29-4933-9aac-9a412a0b81e6" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" start_index="0" end="5d65b5cc-e8b5-4ff7-9eb3-6ee300e40102" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" start_index="0" end="f4662ef7-4920-491c-a08c-e9eb9912d8a8" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" start_index="0" end="6fb2b54b-2df0-4aba-bbf1-6541b826e769" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" start_index="0" end="3466cc6e-609e-4110-93b0-c477fb202f21" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10a3ceb2-3fdd-40bb-bef1-2fe68b05258d" start_index="0" end="0ecab49a-34a9-4fef-abd9-1b43342c17d8" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="7a52859d-1b63-4175-941c-d818a21ef584" start_index="0" end="bec4aee5-3a30-4c24-999d-f9f353df762d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="bec4aee5-3a30-4c24-999d-f9f353df762d" start_index="0" end="50ffe0eb-eeb0-4540-90ba-2b6f88b31d2e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="bec4aee5-3a30-4c24-999d-f9f353df762d" start_index="0" end="1215010b-2f5d-4031-8865-d1c64d5151a7" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="734c4bd1-79dd-41fa-94f6-e7853f1a881d" start_index="0" end="7a52859d-1b63-4175-941c-d818a21ef584" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="734c4bd1-79dd-41fa-94f6-e7853f1a881d" start_index="0" end="599e3168-7c24-413f-8b77-44a84794b0ab" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="332db295-1b29-4933-9aac-9a412a0b81e6" start_index="0" end="ef72918a-b669-447f-a00d-8cfd310acee0" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="d5245f2f-c0b0-4ea7-b8f4-5f2cb77f448e" start_index="0" end="14e09fad-698e-4292-89b6-9941d7862d78" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="3dbf6543-eae7-48b0-9ef2-9073edb58861" start_index="0" end="14e09fad-698e-4292-89b6-9941d7862d78" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="5cc01002-4f78-47d5-8f54-af496dcb6cf7" start_index="0" end="3dbf6543-eae7-48b0-9ef2-9073edb58861" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="5cc01002-4f78-47d5-8f54-af496dcb6cf7" start_index="0" end="301c3934-46ff-4655-92a3-f9a47ae50ae3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="82a78431-e853-4bf9-8bc8-eb19694c9184" start_index="0" end="06a1487f-2d65-420b-b543-cae85229585e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="be8d5938-96b4-48da-b5c9-dad8ac28d520" start_index="0" end="5cb555d1-d237-4710-8da6-b56108d83415" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="06a1487f-2d65-420b-b543-cae85229585e" start_index="0" end="5cb555d1-d237-4710-8da6-b56108d83415" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" start_index="0" end="0357663c-1e1b-4eaa-a210-c4bff030a4ea" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" start_index="0" end="c767726c-a463-42f3-a084-b1c9411764b2" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="efff3d6a-f606-4582-82d1-85905dbdfcc6" start_index="0" end="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="efff3d6a-f606-4582-82d1-85905dbdfcc6" start_index="0" end="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="1d2ad207-efcd-4346-bc18-d610842890e4" start_index="0" end="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="1d2ad207-efcd-4346-bc18-d610842890e4" start_index="0" end="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e591d2d-15b4-48f4-b9aa-178882d70914" start_index="0" end="0357663c-1e1b-4eaa-a210-c4bff030a4ea" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e591d2d-15b4-48f4-b9aa-178882d70914" start_index="0" end="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e591d2d-15b4-48f4-b9aa-178882d70914" start_index="0" end="32c69937-d64e-4dcf-990e-4b3cb429fba4" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e591d2d-15b4-48f4-b9aa-178882d70914" start_index="0" end="275be690-5a3f-485b-80f7-ac8d19efe42d" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e591d2d-15b4-48f4-b9aa-178882d70914" start_index="0" end="28d06a4b-83af-430e-b24a-95451ef5cb10" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e591d2d-15b4-48f4-b9aa-178882d70914" start_index="0" end="a6e42b9e-57c1-4793-b50b-6a3e0bbfc790" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e591d2d-15b4-48f4-b9aa-178882d70914" start_index="0" end="f5f99c60-1202-416d-9855-b37d8d0e5ddb" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="32c69937-d64e-4dcf-990e-4b3cb429fba4" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="b0172315-2e4b-4b5f-afd6-742508a24840" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="07a599e5-558f-4934-9cae-8527bb18e24c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="fd6d25bd-d88d-4cf4-8782-f542af194703" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="275be690-5a3f-485b-80f7-ac8d19efe42d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="1fee66bf-756f-47be-81bc-059d7b7b49b2" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="28d06a4b-83af-430e-b24a-95451ef5cb10" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="a6e42b9e-57c1-4793-b50b-6a3e0bbfc790" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="68c98145-0349-421f-a7ac-4403e41c7986" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0357663c-1e1b-4eaa-a210-c4bff030a4ea" start_index="0" end="f5f99c60-1202-416d-9855-b37d8d0e5ddb" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="3bc257be-1916-44f1-840a-1914121fe58f" start_index="0" end="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="42e2e29c-e839-421e-94cc-e8f46549e6f9" start_index="0" end="c5f0daf3-6a02-45a2-997d-b37ce084c2e3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="32c69937-d64e-4dcf-990e-4b3cb429fba4" start_index="0" end="c26787a5-8996-430f-bf36-58c23ae8114f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fd117d31-8e65-4d23-9a95-094818c41d5e" start_index="0" end="b0172315-2e4b-4b5f-afd6-742508a24840" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="b0172315-2e4b-4b5f-afd6-742508a24840" start_index="0" end="af947995-a8ab-4eec-93f9-fc6c56ab9069" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="b0172315-2e4b-4b5f-afd6-742508a24840" start_index="0" end="453022bb-860d-4177-82ce-88a7dcea4e91" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="b0172315-2e4b-4b5f-afd6-742508a24840" start_index="0" end="7e69020c-148e-4bc9-979b-d596f5afed1f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="f9198390-fd0d-4551-a8b4-75754f686032" start_index="0" end="b0172315-2e4b-4b5f-afd6-742508a24840" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="af947995-a8ab-4eec-93f9-fc6c56ab9069" start_index="0" end="c26787a5-8996-430f-bf36-58c23ae8114f" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="af947995-a8ab-4eec-93f9-fc6c56ab9069" start_index="0" end="ed23a153-1f8a-4f82-8d8f-3ba531d6ba90" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="af947995-a8ab-4eec-93f9-fc6c56ab9069" start_index="0" end="9e449ec4-9deb-4ae6-b128-cb3bf5d6cd43" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a450c4e3-9c4c-40f1-9e07-ca41c64d6197" start_index="0" end="275be690-5a3f-485b-80f7-ac8d19efe42d" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="a450c4e3-9c4c-40f1-9e07-ca41c64d6197" start_index="0" end="32c69937-d64e-4dcf-990e-4b3cb429fba4" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="a450c4e3-9c4c-40f1-9e07-ca41c64d6197" start_index="0" end="28d06a4b-83af-430e-b24a-95451ef5cb10" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="a450c4e3-9c4c-40f1-9e07-ca41c64d6197" start_index="0" end="a6e42b9e-57c1-4793-b50b-6a3e0bbfc790" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="a450c4e3-9c4c-40f1-9e07-ca41c64d6197" start_index="0" end="f5f99c60-1202-416d-9855-b37d8d0e5ddb" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" start_index="0" end="32c69937-d64e-4dcf-990e-4b3cb429fba4" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" start_index="0" end="275be690-5a3f-485b-80f7-ac8d19efe42d" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" start_index="0" end="28d06a4b-83af-430e-b24a-95451ef5cb10" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" start_index="0" end="a6e42b9e-57c1-4793-b50b-6a3e0bbfc790" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="200a0a4a-7933-4626-a3cb-8cd0b23b8eef" start_index="0" end="f5f99c60-1202-416d-9855-b37d8d0e5ddb" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="1612be2e-2aea-4340-8229-12ae72ca4ac0" start_index="0" end="879012ae-02b6-4b1e-b2b1-20d0cfab7683" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ed23a153-1f8a-4f82-8d8f-3ba531d6ba90" start_index="0" end="1612be2e-2aea-4340-8229-12ae72ca4ac0" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ed23a153-1f8a-4f82-8d8f-3ba531d6ba90" start_index="0" end="cf10eef3-cebf-4e5a-9b61-513006e72f2f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="07a599e5-558f-4934-9cae-8527bb18e24c" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="07a599e5-558f-4934-9cae-8527bb18e24c" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="fd6d25bd-d88d-4cf4-8782-f542af194703" start_index="0" end="b8e89c2f-2fc9-4a6d-bd8a-60ce7d74db11" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fd6d25bd-d88d-4cf4-8782-f542af194703" start_index="0" end="b8e89c2f-2fc9-4a6d-bd8a-60ce7d74db11" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="a239fc6e-d882-484b-9cb4-4bd033383935" start_index="0" end="7816939f-d2e5-4c40-8099-0ed64d83d87c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a239fc6e-d882-484b-9cb4-4bd033383935" start_index="0" end="a7e9f424-9740-4d40-afd1-1f4aae322780" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a239fc6e-d882-484b-9cb4-4bd033383935" start_index="0" end="45748629-e625-430b-b33a-b2c437d57dbb" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a239fc6e-d882-484b-9cb4-4bd033383935" start_index="0" end="f4269aaf-9384-40ee-8269-b0836ca82d71" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a239fc6e-d882-484b-9cb4-4bd033383935" start_index="0" end="59322da8-84c2-4652-aaed-b6043c40610e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8e89c2f-2fc9-4a6d-bd8a-60ce7d74db11" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8e89c2f-2fc9-4a6d-bd8a-60ce7d74db11" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8e89c2f-2fc9-4a6d-bd8a-60ce7d74db11" start_index="1" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8e89c2f-2fc9-4a6d-bd8a-60ce7d74db11" start_index="1" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="879012ae-02b6-4b1e-b2b1-20d0cfab7683" start_index="0" end="8d4d07be-682a-42eb-af22-21e2671b1bef" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8d4d07be-682a-42eb-af22-21e2671b1bef" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="8d4d07be-682a-42eb-af22-21e2671b1bef" start_index="0" end="c155fb81-334d-4ca4-baa0-c63442677f68" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8d4d07be-682a-42eb-af22-21e2671b1bef" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="275be690-5a3f-485b-80f7-ac8d19efe42d" start_index="0" end="a239fc6e-d882-484b-9cb4-4bd033383935" end_index="10" portType="0" />
    <Dynamo.Models.ConnectorModel start="45748629-e625-430b-b33a-b2c437d57dbb" start_index="0" end="3df664c4-cf2c-421b-98a3-30ffd488bb28" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="a7e9f424-9740-4d40-afd1-1f4aae322780" start_index="0" end="ef4e036a-4c6e-4d4d-97bb-9e7da30a4a59" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="a7e9f424-9740-4d40-afd1-1f4aae322780" start_index="0" end="599e3168-7c24-413f-8b77-44a84794b0ab" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="a7e9f424-9740-4d40-afd1-1f4aae322780" start_index="0" end="903120c6-a2bc-4a7f-9324-f0befe0d91a7" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a7e9f424-9740-4d40-afd1-1f4aae322780" start_index="0" end="3df664c4-cf2c-421b-98a3-30ffd488bb28" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="f4269aaf-9384-40ee-8269-b0836ca82d71" start_index="0" end="3df664c4-cf2c-421b-98a3-30ffd488bb28" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="7816939f-d2e5-4c40-8099-0ed64d83d87c" start_index="0" end="ef4e036a-4c6e-4d4d-97bb-9e7da30a4a59" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="7816939f-d2e5-4c40-8099-0ed64d83d87c" start_index="0" end="599e3168-7c24-413f-8b77-44a84794b0ab" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef4e036a-4c6e-4d4d-97bb-9e7da30a4a59" start_index="0" end="599e3168-7c24-413f-8b77-44a84794b0ab" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef4e036a-4c6e-4d4d-97bb-9e7da30a4a59" start_index="0" end="10cebea5-de1b-4aaa-bc6e-3cb4bf87b46f" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="599e3168-7c24-413f-8b77-44a84794b0ab" start_index="0" end="10cebea5-de1b-4aaa-bc6e-3cb4bf87b46f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="d150f1bb-500e-42b9-ad82-a7c3b4a1c3d5" start_index="0" end="599e3168-7c24-413f-8b77-44a84794b0ab" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="d150f1bb-500e-42b9-ad82-a7c3b4a1c3d5" start_index="0" end="fd242a9f-8214-48ad-9997-38fe4d82afe3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="c155fb81-334d-4ca4-baa0-c63442677f68" start_index="0" end="d150f1bb-500e-42b9-ad82-a7c3b4a1c3d5" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="903120c6-a2bc-4a7f-9324-f0befe0d91a7" start_index="0" end="30c768a4-1f41-4c2c-bcb6-cf020b9dc548" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="903120c6-a2bc-4a7f-9324-f0befe0d91a7" start_index="0" end="88d9fd1f-c501-4b1a-9092-bd3d72fcc76a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="903120c6-a2bc-4a7f-9324-f0befe0d91a7" start_index="0" end="85ef2fe9-43ab-415a-bebb-9b321b470057" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="88d9fd1f-c501-4b1a-9092-bd3d72fcc76a" start_index="0" end="95479b69-5cbb-4336-80ba-37d5fce71073" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="88d9fd1f-c501-4b1a-9092-bd3d72fcc76a" start_index="1" end="5b67df9a-e802-4711-8978-af5ea57cf54a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="1fee66bf-756f-47be-81bc-059d7b7b49b2" start_index="0" end="5fd5f97b-8669-4122-b0e9-61bf955b422a" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="1fee66bf-756f-47be-81bc-059d7b7b49b2" start_index="0" end="dd5e0569-228b-47de-8b41-3c3e9992047d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="30c768a4-1f41-4c2c-bcb6-cf020b9dc548" start_index="0" end="5fd5f97b-8669-4122-b0e9-61bf955b422a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="3df664c4-cf2c-421b-98a3-30ffd488bb28" start_index="0" end="a1707fe3-b13a-42d3-a492-795cdce17ff9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="3df664c4-cf2c-421b-98a3-30ffd488bb28" start_index="0" end="ef11afca-5d65-4104-bd81-ec44bc36f7ad" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a1707fe3-b13a-42d3-a492-795cdce17ff9" start_index="0" end="903120c6-a2bc-4a7f-9324-f0befe0d91a7" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef11afca-5d65-4104-bd81-ec44bc36f7ad" start_index="0" end="903120c6-a2bc-4a7f-9324-f0befe0d91a7" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef11afca-5d65-4104-bd81-ec44bc36f7ad" start_index="0" end="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="f904476b-4d4d-4cdf-a2c5-22f70188e33f" start_index="0" end="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="f904476b-4d4d-4cdf-a2c5-22f70188e33f" start_index="0" end="843c144f-6497-4e21-a4f6-a300e266a735" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="1c8deb62-9bdb-4bdf-9df2-e136d59b3ea8" start_index="0" end="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" start_index="0" end="65236426-c712-41c1-ab44-e91adffb856b" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10cebea5-de1b-4aaa-bc6e-3cb4bf87b46f" start_index="0" end="d8b40901-d208-4b8b-82ef-878ddaddfd63" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10cebea5-de1b-4aaa-bc6e-3cb4bf87b46f" start_index="0" end="5d1b39b1-969d-4a26-a874-69696f624dd9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="d8b40901-d208-4b8b-82ef-878ddaddfd63" start_index="0" end="f904476b-4d4d-4cdf-a2c5-22f70188e33f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="d8b40901-d208-4b8b-82ef-878ddaddfd63" start_index="0" end="5ea270e8-1be9-42b0-8915-a7af312a821a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="dd5e0569-228b-47de-8b41-3c3e9992047d" start_index="0" end="d8b40901-d208-4b8b-82ef-878ddaddfd63" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="dd5e0569-228b-47de-8b41-3c3e9992047d" start_index="0" end="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="dd5e0569-228b-47de-8b41-3c3e9992047d" start_index="0" end="843c144f-6497-4e21-a4f6-a300e266a735" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="d9724031-75f6-41ef-a06d-5621d7a95c02" start_index="0" end="dd5e0569-228b-47de-8b41-3c3e9992047d" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="5ea270e8-1be9-42b0-8915-a7af312a821a" start_index="0" end="4847187c-ff80-484b-a041-d51d04c3e7cd" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="cf10eef3-cebf-4e5a-9b61-513006e72f2f" start_index="0" end="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="453022bb-860d-4177-82ce-88a7dcea4e91" start_index="0" end="d9ea6210-bd0b-42aa-82eb-02594b4fc93b" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="0b7f5ad5-a16d-4c3c-a42a-b482fd9378fe" start_index="0" end="843c144f-6497-4e21-a4f6-a300e266a735" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="407b1006-41a4-4600-b34e-baead4cfb0e7" start_index="0" end="843c144f-6497-4e21-a4f6-a300e266a735" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="73e95364-e73a-4337-9543-03a6a09286f9" start_index="0" end="843c144f-6497-4e21-a4f6-a300e266a735" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="80296a7c-3afc-47b9-b874-99ce710d86ee" start_index="0" end="4847187c-ff80-484b-a041-d51d04c3e7cd" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="65236426-c712-41c1-ab44-e91adffb856b" start_index="0" end="0942b713-d985-4d61-a2d0-788908152b66" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="65236426-c712-41c1-ab44-e91adffb856b" start_index="0" end="0b7f5ad5-a16d-4c3c-a42a-b482fd9378fe" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="65236426-c712-41c1-ab44-e91adffb856b" start_index="0" end="407b1006-41a4-4600-b34e-baead4cfb0e7" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="65236426-c712-41c1-ab44-e91adffb856b" start_index="0" end="80296a7c-3afc-47b9-b874-99ce710d86ee" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4847187c-ff80-484b-a041-d51d04c3e7cd" start_index="0" end="79dde83d-39a3-4872-8118-5d8dc6101d79" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4847187c-ff80-484b-a041-d51d04c3e7cd" start_index="0" end="6f53f637-8b26-4ad8-90a4-46e425884827" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4847187c-ff80-484b-a041-d51d04c3e7cd" start_index="0" end="3b808e33-a864-4165-8669-fa53ecabe992" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="79dde83d-39a3-4872-8118-5d8dc6101d79" start_index="0" end="cf70bfbe-73be-410f-817f-f88ee98a5214" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6f53f637-8b26-4ad8-90a4-46e425884827" start_index="0" end="2bcf5d36-551b-40f4-a482-ef5eeb9bc5d0" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6f53f637-8b26-4ad8-90a4-46e425884827" start_index="0" end="327e7612-b223-493a-aedc-18d7691b3fd2" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="3b808e33-a864-4165-8669-fa53ecabe992" start_index="0" end="2943aea0-09ee-49c4-9584-6a8876dbbb7e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2bcf5d36-551b-40f4-a482-ef5eeb9bc5d0" start_index="0" end="12939b65-2328-4bf0-804f-fe86f8bac92f" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="2943aea0-09ee-49c4-9584-6a8876dbbb7e" start_index="0" end="d5d5782c-489e-4304-9b38-8b6a751471a6" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="ac397449-72b8-4053-8904-c07f461562a2" start_index="0" end="12939b65-2328-4bf0-804f-fe86f8bac92f" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="233e1889-93af-4320-8e13-3c884c7e0311" start_index="0" end="d5d5782c-489e-4304-9b38-8b6a751471a6" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e69020c-148e-4bc9-979b-d596f5afed1f" start_index="0" end="4847187c-ff80-484b-a041-d51d04c3e7cd" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e69020c-148e-4bc9-979b-d596f5afed1f" start_index="0" end="f851aa59-4231-4990-b812-3e292c8b9055" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="85ef2fe9-43ab-415a-bebb-9b321b470057" start_index="0" end="a6487893-ff89-4a41-b247-0f175ebc4fad" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a6487893-ff89-4a41-b247-0f175ebc4fad" start_index="0" end="f851aa59-4231-4990-b812-3e292c8b9055" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="28d06a4b-83af-430e-b24a-95451ef5cb10" start_index="0" end="a6e42b9e-57c1-4793-b50b-6a3e0bbfc790" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="28d06a4b-83af-430e-b24a-95451ef5cb10" start_index="0" end="443c0dc0-da7d-41f4-a950-a208fc3de5e9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a6e42b9e-57c1-4793-b50b-6a3e0bbfc790" start_index="0" end="2b43a6d0-1375-4de2-93ee-482f1c69b5ca" end_index="10" portType="0" />
  </Connectors>
  <Notes />
</Workspace>