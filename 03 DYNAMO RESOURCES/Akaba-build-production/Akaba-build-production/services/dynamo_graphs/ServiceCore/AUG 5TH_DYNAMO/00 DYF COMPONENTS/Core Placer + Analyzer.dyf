<Workspace Version="0.8.0.1233" X="-705.963931324689" Y="279.515317014757" zoom="0.746684382049231" Name="Core Placer + Analyzer" ID="ded933d3-a05a-4036-9385-09b2cab946f5" Description="Core Maker and analyzes efficiency" Category="ServiceCore New">
  <NamespaceResolutionMap>
    <ClassMap partialName="Point" resolvedName="Autodesk.DesignScript.Geometry.Point" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Rectangle.Points[0]" resolvedName="Autodesk.DesignScript.Geometry.Rectangle" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Rectangle" resolvedName="Autodesk.DesignScript.Geometry.Rectangle" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Point.Z" resolvedName="Autodesk.DesignScript.Geometry.Point" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="List" resolvedName="DSCore.List" assemblyName="DSCoreNodes.dll" />
    <ClassMap partialName="Vector" resolvedName="Autodesk.DesignScript.Geometry.Vector" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Curve" resolvedName="Autodesk.DesignScript.Geometry.Curve" assemblyName="ProtoGeometry.dll" />
    <ClassMap partialName="Curve.reverse" resolvedName="Autodesk.DesignScript.Geometry.Curve" assemblyName="ProtoGeometry.dll" />
  </NamespaceResolutionMap>
  <Elements>
    <DSIronPythonNode.PythonNode guid="219bd21c-7c34-4adc-9f24-cbd5b4e8efe1" type="DSIronPythonNode.PythonNode" nickname="Core Placer Points Strat 2" x="265.054768069569" y="111.597573503529" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type     = IN[1]
inputLen = IN[2]
coreDim  = IN[3]
edgeList = IN[4]


#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	points = 	rec.Points
	diagDist = Line.ByStartPointEndPoint(points[0],points[2]).Length
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge,diagDist
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------


#makes the core rectangle based on number of req it has---------------------------------------------------------------------------------------
def makeCoreBox(rec,numCore,wid,ht,longEdge):
	coreList=[]
	cen = rec.Center()
	pts = rec.Points
	ptPlaceList = []
	#when just need to place one core
	if numCore ==1:
		cs = CoordinateSystem.ByOrigin(cen)
		coreRec= Rectangle.ByWidthHeight(cs,wid,ht)
		coreList.append(coreRec)
		ptPlaceList.append(cen)
	#when more than one core needs to be placed
	else:
		len1 = Line.ByStartPointEndPoint(pts[0],pts[1]).Length
		len2 = Line.ByStartPointEndPoint(pts[0],pts[3]).Length
		#find the longer edge and that line
		if len1 == longEdge:
			lin = Line.ByStartPointEndPoint(pts[0],pts[1])
		else:
			lin = Line.ByStartPointEndPoint(pts[0],pts[3])			
		linCen = lin.PointAtParameter(0.5)
		vec = Vector.ByTwoPoints(linCen,cen)
		linNew = lin.Translate(vec)
		#divide the line to get the points to place core		
		linNewLen = linNew.Length
		perDist = linNewLen/(numCore+1)
		
		#prepare the pointlist
		for i in range(numCore):
			pt = linNew.PointAtDistance((i+1)*perDist)
			ptPlaceList.append(pt)
	return ptPlaceList
#---------------------------------------------------------------------------------------------------------------------------------------------

# function which places core boxes into the empty boxes----------------------------------------------------------------------------------------
def getNumCores(boxList):		
	numCoresList=[]
	lenMeasure = inputLen
	wid = coreDim
	ht = coreDim
	for i in range(len(boxList)):
		rec = boxList[i]
		shortEdge = getShorterDim(rec)[0]
		longEdge = getShorterDim(rec)[1]
		diagDist = getShorterDim(rec)[2]
		if longEdge &gt; lenMeasure :
			numCore = int(math.ceil(longEdge/lenMeasure))	
		else :
			numCore=1
		numCoresList.append(numCore)
	return numCoresList
#----------------------------------------------------------------------------------------------------------------------------------------------




def placeCorePoints(boxList,edgeList):
	pointList=[]
	numCoreList = getNumCores(boxList)
	
	finCoreList=[]
	ptFinalList=[]
	for i in range(len(boxList)):
		edgeL = edgeList[i]
		recL = boxList[i]
		numCores = numCoreList[i]
		getCore = 0
		corePlaced =0
		coreList =[]
		count = 0
		while corePlaced &lt; numCores:
			#fill in 0 to initiate the coreList for 1st time
			if count == 0:
				for j in range(len(edgeL)):
					coreList.Add(0)				
			for j in range(len(edgeL)):
				corePlaced += 1
				if corePlaced &gt; numCores : break				
				coreList[j] += 1				
			count += 1
		finCoreList.Add(coreList)
		ptPlaceList = []
		for j in range(len(edgeL)):
			edge = edgeL[j]
			coresEdge = coreList[j]
			perDist = edge.Length/(coresEdge+1)	
			for k in range(coresEdge):
					
				pt = edge.PointAtDistance((k+1)*perDist)
				ptPlaceList.append(pt)
		ptFinalList.Add(ptPlaceList)
			
	 	
	return ptFinalList





out = placeCorePoints(emptyBox,edgeList)
#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="ca568ee1-0d24-4d67-be51-ec0ee1ddd6b1" type="Dynamo.Nodes.DSFunction" nickname="Floor Surface" x="259.421328126739" y="461.153674386317" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Surface.ByPatch@Autodesk.DesignScript.Geometry.Curve" />
    <DSIronPythonNode.PythonNode guid="9e75d80c-1af2-4485-b4e5-3896d21752e3" type="DSIronPythonNode.PythonNode" nickname="Core Placer Points Strat 1" x="267.091477167881" y="295.749931180633" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type = IN[1]
inputLen = IN[2]
coreDim = IN[3]

#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	points = 	rec.Points
	diagDist = Line.ByStartPointEndPoint(points[0],points[2]).Length
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge,diagDist
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------


#makes the core rectangle based on number of req it has---------------------------------------------------------------------------------------
def makeCoreBox(rec,numCore,wid,ht,longEdge):
	coreList=[]
	cen = rec.Center()
	pts = rec.Points
	ptPlaceList = []
	#when just need to place one core
	if numCore ==1:
		cs = CoordinateSystem.ByOrigin(cen)
		coreRec= Rectangle.ByWidthHeight(cs,wid,ht)
		coreList.append(coreRec)
		ptPlaceList.append(cen)
	#when more than one core needs to be placed
	else:
		len1 = Line.ByStartPointEndPoint(pts[0],pts[1]).Length
		len2 = Line.ByStartPointEndPoint(pts[0],pts[3]).Length
		#find the longer edge and that line
		if len1 == longEdge:
			lin = Line.ByStartPointEndPoint(pts[0],pts[1])
		else:
			lin = Line.ByStartPointEndPoint(pts[0],pts[3])			
		linCen = lin.PointAtParameter(0.5)
		vec = Vector.ByTwoPoints(linCen,cen)
		linNew = lin.Translate(vec)
		#divide the line to get the points to place core		
		linNewLen = linNew.Length
		perDist = linNewLen/(numCore+1)
		
		#prepare the pointlist
		for i in range(numCore):
			pt = linNew.PointAtDistance((i+1)*perDist)
			ptPlaceList.append(pt)
	return ptPlaceList
#---------------------------------------------------------------------------------------------------------------------------------------------

# function which places core boxes into the empty boxes----------------------------------------------------------------------------------------
def placeCoreBox(boxList):		
	allCores=[]
	lenMeasure = inputLen
	wid = coreDim
	ht = coreDim
	for i in range(len(boxList)):
		rec = boxList[i]
		shortEdge = getShorterDim(rec)[0]
		longEdge = getShorterDim(rec)[1]
		diagDist = getShorterDim(rec)[2]
		if longEdge &gt; lenMeasure :
			numCore = int(math.ceil(longEdge/lenMeasure))	
		else :
			numCore=1
		coreRecs = makeCoreBox(rec,numCore,wid,ht,longEdge)
		allCores.append(coreRecs)
	return allCores
#----------------------------------------------------------------------------------------------------------------------------------------------



out = placeCoreBox(emptyBox)
#Assign your output to the OUT variable
OUT = out
#OUT = polytoRect(emptyBox[0])</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" type="DSIronPythonNode.PythonNode" nickname="Service Core Components Strat 2" x="601.309939139903" y="193.497320676721" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="12">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flr_WidthList		=	IN[0]
flr_HeightList		=	IN[1]
twr_BaseptList		=	IN[2]
num_passElev		=	IN[3][0]
num_servElev		=	IN[3][1]

passElev_Area		=	IN[4]
servElev_Area		=	IN[4]
tag					=	IN[5]
elevWidth			=	IN[6][0]
elevLength			=	IN[6][1]
restroomProp		=	IN[7]
techrmProp			=	IN[8]
liftLobbyWidth		=	IN[9]
corePtList			=	IN[10]




#compute service core width, length, and serviceCore====================================================================================================
def serviceCoreMaker(ptL):
	global area_banks, area_restroom,area_servmodule
	rd = random.uniform(0,1)
	#calc total area for service core for the tower
	serviceCore_Area 	= area_banks + area_restroom + area_servmodule;
	serviceCore_Area	= serviceCore_Area/len(ptL)
	area_banks			= area_banks/len(ptL)
	area_restroom		= area_restroom/len(ptL)
	area_servmodule		= area_servmodule/len(ptL)
	
	servCore_WidthL = []
	servCore_LengthL = []
	coreVerticesL = []
	b_FacL =[]
	serviceCore_RecL = []
	for i in range(len(ptL)):
		pt = ptL[i]			
		#calc aspect ratio of floor plate
		aspect_Ratio 		= 	flr_Width/flr_Height
		
		#adjust aspectratio
		if aspect_Ratio &lt; 0.65 : aspect_Ratio = 0.75
		if aspect_Ratio &gt; 1.3 : aspect_Ratio = 1.2
		#calc service core length and width
		if rd&gt;0.5:
			servCore_Length 	=	math.sqrt(serviceCore_Area/aspect_Ratio)
			servCore_Width		=	serviceCore_Area/servCore_Length	
		else:
			servCore_Width		=	math.sqrt(serviceCore_Area/aspect_Ratio)
			servCore_Length 	=	serviceCore_Area/servCore_Width	
		
	
		# get the coordinates of center pt
		x,y,z 					= 	pt.X,pt.Y,pt.Z	
		#make the service core rectangle object--------------------------------------------------------------------------------------------------------------1
		cs					= 	CoordinateSystem.ByOrigin(x,y,z)
		serviceCore_Rec 	= 	Rectangle.ByWidthHeight(cs,servCore_Width,servCore_Length)
		serviceCore_Rec 	=	orientFixNEW(serviceCore_Rec,twr_Basept,pt,servCore_Width,servCore_Length)
		
		
		
		coreVertices		=	serviceCore_Rec.Points
		servCore_WidthL.append(servCore_Width)
		servCore_LengthL.append(servCore_Length)
		coreVerticesL.append(coreVertices)
		serviceCore_RecL.append(serviceCore_Rec)
	#comput elev bank factor--------------------------------------------------------------------
	b_Fac				=	area_banks/serviceCore_Area
	#return serviceCore_Rec,b_Fac,coreVertices,area_banks,area_banks,area_servmodule
	return servCore_WidthL,servCore_LengthL,coreVerticesL,b_Fac,serviceCore_RecL



#function to make boxes based off of width, length and vertices===========================================================================================
def makeBox(widthL,lengthL,verticesL,factor,tag):
	new_RecL=[]
	other_RecL=[]
	for i in range(len(widthL)):
		width = widthL[i]
		length = lengthL[i]
		vertices = verticesL[i]
		
		#calculate the shorter of width or height of service core
		if ( tag == 0):
			if (width &lt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2
		else:
			if (width &gt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2		
	
		
		cs1					= 	CoordinateSystem.ByOrigin(vertices[0].X,vertices[0].Y,0)
		cs2					= 	CoordinateSystem.ByOrigin(vertices[index].X,vertices[index].Y,0)
		# to make the primary rectangle ----------------------------------------------------------------------	
		new_Rec 			= 	Rectangle.ByWidthHeight(cs1,new_Width,new_Length)	
		new_Vec				= 	Vector.ByTwoPoints(new_Rec.Points[0],vertices[0])
		new_Rec				=	Geometry.Translate(new_Rec, new_Vec)
		ptsnew_Rec			=	new_Rec.Points
		# to make the secondary rectangle ----------------------------------------------------------------------	
		other_Rec 			= 	Rectangle.ByWidthHeight(cs2,other_Width,other_Length)	
		other_Vec			= 	Vector.ByTwoPoints(other_Rec.Points[index],vertices[index])
		other_Rec			=	Geometry.Translate(other_Rec, other_Vec)
		ptsother_Rec		=	other_Rec.Points
		
		new_RecL.append(new_Rec)
		other_RecL.append(other_Rec)
	
	return [new_RecL,other_RecL]
#============================================================================================================================================================



#make post computations======================================================================================================================================
def coreConfigurator(b_Fac):
	#make the elevator bank rectangle object-----------------------------------------------------1	
	bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
	bank_RecLNew = []
	for i in range(len(bank_RecL)):
		bank_Rec = 	bank_RecL[i]
		widtry1				=	bank_Rec[0].Width
		lentry1				=	bank_Rec[0].Height
				
		# code to readjust the bank rectangle piece based on the final tech rooms and restroom blocks
		if ( widtry1&lt;lentry1):
			shortEdge		=	widtry1
			marked			=	0	
		else:
			shortEdge		=	lentry1
			marked			=	1
				
		if (elevWidth&lt;elevLength):elevEdge = elevWidth
		else:elevEdge =	elevLength			
		numE				=	int(shortEdge / elevEdge)
		numE				+=	1
			
		newDim				=	numE*elevEdge
		if ( marked ==0): ratio	= widtry1/newDim
		else: ratio	= lentry1/newDim
		b_Fac				=	ratio*b_Fac
		#bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
		
	return bank_RecL
	#-------------------------------------------------------------------------------------------------
#============================================================================================================================================================
#to fix the orientation of the serviceCores-----------------------------------------------------------
def orientFixNEW(servCore,twr_Basept,crPt,wid,ht):
	vecX = Vector.XAxis()
	vecY = Vector.YAxis()
	
	vecMain = Vector.ByTwoPoints(crPt,twr_Basept)
	vecMainNormal = vecMain.Normalized()
	
	valX = vecMainNormal.X * vecX.X
	valY = vecMainNormal.Y * vecY.Y
	
	if valX &lt; 0:
		vecX = vecX.Reverse()
		pass
	if valY &lt; 0:
		vecY = vecY.Reverse()
		pass

		
	angX = Vector.AngleBetween(vecMain,vecX) 
	angY = Vector.AngleBetween(vecMain,vecY)
	if angX &lt;= 80 and angX &gt;= 0: # 50 &amp; 10 .... 100 &amp; 10
		vecMain = vecX.Scale(wid/2)		
		servCore = servCore.Translate(vecMain)
	if angY &lt;= 80 and angY &gt;= 0:
		vecMain = vecY.Scale(ht/2)
		servCore = servCore.Translate(vecMain)
	"""
	if angX == 0: # 50 &amp; 10 .... 100 &amp; 10
		vecMain = vecX.Scale(wid/2)		
		servCore = servCore.Translate(vecMain)
	if angY == 0:
		vecMain = vecY.Scale(ht/2)
		servCore = servCore.Translate(vecMain)
		
	"""	
	return servCore
#-----------------------------------------------------------------------------------------------------


#iterate through all the blocks and output lists for each---------------------------------------------
outList=[]
bankRecList= []
otherRecList=[]
areaRestrmList=[]
areaServModList=[]
servCoreList=[]

perc = 1.1

for i in range(len(twr_BaseptList)):

	flr_Width  = flr_WidthList[i]
	flr_Height = flr_HeightList[i]
	twr_Basept = twr_BaseptList[i]
	corePts	   = corePtList[i]
	
	#globals var, computer area banks, area restrm, area techrms--------------------------------------------------------------------------------------------
	cirProp = liftLobbyWidth/1.5
	
	area_banks			= servElev_Area*num_servElev[i]/perc + passElev_Area*num_passElev[i]/perc
	area_banks			+=cirProp*area_banks # added the circulation area
	area_restroom 		= restroomProp*area_banks								
	area_servmodule 	= techrmProp*area_banks
	
	
	#OUTPUT VALUES-------------------------------------------------------
	vals 				= 	serviceCoreMaker(corePts)
	servCore_Width		=	vals[0]
	servCore_Length		=	vals[1]
	coreVertices		=	vals[2]
	b_Fac				=	vals[3]
	serviceCore_Rec		=	vals[4]
	bank_Rec 			= 	coreConfigurator(b_Fac)	
	
	bankRecList.append(bank_Rec[0])
	otherRecList.append(bank_Rec[1])
	areaRestrmList.append(area_restroom)
	areaServModList.append(area_servmodule)
	servCoreList.append(serviceCore_Rec)
	
	

out = bankRecList,otherRecList,areaRestrmList,areaServModList,servCoreList

#out = servCoreList,flr_WidthList[0]/flr_HeightList[0]
#Assign your output to the OUT variable
OUT = out
#OUT = flr_WidthList,flr_HeightList
</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="e6936ed4-076e-4ee5-954c-a8b3bb72c93a" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="BaseFloor Assets" x="260.583489145711" y="551.864923646483" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="{a.Width,a.Height};" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="903c6006-4dc7-4a99-b024-03ba30e4572d" type="DSIronPythonNode.PythonNode" nickname="BasePoint Maker" x="259.299904266685" y="614.552109169671" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN
rectList = IN[0]

ptList= [x.Center() for x in rectList]
#Assign your output to the OUT variable
OUT = ptList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="fc659bb3-d44a-45bf-afce-72fe9510b666" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Block Width Height" x="260.132625394192" y="683.202191347378" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="width[0];&#xA;height[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="9e69b5c2-51e2-479c-abc5-165eabcc97f6" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_Service Module/ Tech rooms" x="868.589875142731" y="646.413661346553" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[3];" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="e0c86771-3dce-4ca3-a942-84506d5b6d3e" type="Dynamo.Nodes.DSFunction" nickname="GBA - Floor Area" x="263.47868252408" y="761.64708689616" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Surface.Area" />
    <Dynamo.Nodes.DSFunction guid="fce72131-bcfc-4f09-a95b-c4e7bd963571" type="Dynamo.Nodes.DSFunction" nickname="Geometry.Intersect" x="898.563869117181" y="731.799074696883" isVisible="false" isUpstreamVisible="true" lacing="Shortest" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Geometry.Intersect@Autodesk.DesignScript.Geometry.Geometry" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="9cc016d9-e977-460e-942a-85a1c94352b8" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="ServiceCore Types" x="864.546643288039" y="559.765352525368" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="serviceCore_Types;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="46ca0a06-a4a5-48e1-87e6-24f618ededdb" type="DSIronPythonNode.PythonNode" nickname="BuiltArea Blocks" x="263.034743683321" y="843.276085516653" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floor_AreaSrf = IN[0]
totalAREA=[]
for i in range(len(floor_AreaSrf)):
	floor_Area = floor_AreaSrf[i]
	totalBuiltArea = sum(floor_Area)
	totalAREA.append(totalBuiltArea)



#Assign your output to the OUT variable
OUT = totalAREA,sum(totalAREA)</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="c1c7aad1-a830-4169-828c-82b566eac8a9" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Service Core Full Block" x="940.078562113092" y="1184.30845541975" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[4];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="277fe7d2-09f7-4757-bf06-6c20c4ac9612" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_RestRooms_Final" x="1173.63787662918" y="787.004094528193" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="b8d719f5-d994-4ed0-a5d2-b49225ef43a8" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Other_Part Service Area" x="929.474740840001" y="924.667676181793" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="a[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="ffa333c1-52f5-4a9e-985e-3975f96dbe4d" type="DSIronPythonNode.PythonNode" nickname="Area Generator RestRoom + TechRoom" x="1173.99506555517" y="648.421739279642" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

otherRecList = IN[0]
restRmAreaL  = IN[1]
techRmAreaL  = IN[2]



#proportion generator for restrm Area and Techroom Area---------------------------------------------------
def propGenerator():
	propTechL=[]
	propRestL = []
	for i in range(len(otherRecList)):
		techArea = techRmAreaL[i]
		restrmArea = restRmAreaL[i]
		propTechArea = techArea/(techArea+restrmArea)
		propRestArea = 1-propTechArea
		propTechL.append(propTechArea)
		propRestL.append(propRestArea)
	return propTechL,propRestL
#---------------------------------------------------------------------------------------------------------

#main Code called and run---------------------------------------------------------------------------------
def mainCode():
	areaRestrmList=[]
	areaTechrmList=[]
	propL = propGenerator()
	for i in range(len(otherRecList)):
		otherRecL = otherRecList[i]	
		propTech = propL[0][i]	
		propRest = propL[1][i]
		restAreaL = []
		techAreaL = []
		for j in range(len(otherRecL)):
			rec = otherRecL[j]
			recArea = rec.Width * rec.Height
			techArea = propTech * recArea
			restArea = propRest * recArea
			techAreaL.append(techArea)
			restAreaL.append(restArea)
		areaTechrmList.append(techAreaL)
		areaRestrmList.append(restAreaL)			

	return areaTechrmList, areaRestrmList
#--------------------------------------------------------------------------------------------------------


out = mainCode()
#Assign your output to the OUT variable
#OUT = [areaTechrmList, areaRestrmList]
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="68b29497-a19f-4563-882f-5807fc197be0" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_Tech rooms_Final" x="1174.82475980336" y="873.847108043243" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" type="DSIronPythonNode.PythonNode" nickname="Service Core Components Strat 1" x="589.117927213995" y="683.837519076654" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="11">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random

#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flr_WidthList		=	IN[0]
flr_HeightList		=	IN[1]
twr_BaseptList		=	IN[2]
num_passElev		=	IN[3][0]
num_servElev		=	IN[3][1]

passElev_Area		=	IN[4]
servElev_Area		=	IN[4]
tag					=	IN[5]
elevWidth			=	IN[6][0]
elevLength			=	IN[6][1]
restroomProp		=	IN[7]
techrmProp			=	IN[8]
liftLobbyWidth		=	IN[9]
corePtList			=	IN[10]



#compute service core width, length, and serviceCore====================================================================================================
def serviceCoreMaker(ptL):
	global area_banks, area_restroom,area_servmodule
	rd = random.uniform(0,1)
	#calc total area for service core for the tower
	serviceCore_Area 	= area_banks + area_restroom + area_servmodule;
	serviceCore_Area	= serviceCore_Area/len(ptL)
	area_banks			= area_banks/len(ptL)
	area_restroom		= area_restroom/len(ptL)
	area_servmodule		= area_servmodule/len(ptL)
	
	servCore_WidthL = []
	servCore_LengthL = []
	coreVerticesL = []
	b_FacL =[]
	serviceCore_RecL = []
	for i in range(len(ptL)):
		pt = ptL[i]			
		#calc aspect ratio of floor plate
		aspect_Ratio 		= 	flr_Width/flr_Height
		
		#adjust aspectratio
		if aspect_Ratio &lt; 0.65 : aspect_Ratio = 0.75
		if aspect_Ratio &gt; 1.3 : aspect_Ratio = 1.2
		
		
		#calc service core length and width
		if rd&gt;0.5:
			servCore_Length 	=	math.sqrt(serviceCore_Area/aspect_Ratio)
			servCore_Width		=	serviceCore_Area/servCore_Length	
		else:
			servCore_Width		=	math.sqrt(serviceCore_Area/aspect_Ratio)
			servCore_Length 	=	serviceCore_Area/servCore_Width	
		
		"""LATER MAKE AN ORIENT FUNCTION
		if len(ptL) == 1:
			#flipped width and length
			tm = servCore_Length
			servCore_Length = servCore_Width  
			servCore_Width = tm
		"""
		# get the coordinates of center pt
		x,y,z 					= 	pt.X,pt.Y,pt.Z	
		#make the service core rectangle object--------------------------------------------------------------------------------------------------------------1
		cs					= 	CoordinateSystem.ByOrigin(x,y,z)
		serviceCore_Rec 	= 	Rectangle.ByWidthHeight(cs,servCore_Width,servCore_Length)
		coreVertices		=	serviceCore_Rec.Points
		servCore_WidthL.append(servCore_Width)
		servCore_LengthL.append(servCore_Length)
		coreVerticesL.append(coreVertices)
		serviceCore_RecL.append(serviceCore_Rec)
	#comput elev bank factor--------------------------------------------------------------------
	b_Fac				=	area_banks/serviceCore_Area
	#return serviceCore_Rec,b_Fac,coreVertices,area_banks,area_banks,area_servmodule
	return servCore_WidthL,servCore_LengthL,coreVerticesL,b_Fac,serviceCore_RecL



#function to make boxes based off of width, length and vertices===========================================================================================
def makeBox(widthL,lengthL,verticesL,factor,tag):
	new_RecL=[]
	other_RecL=[]
	for i in range(len(widthL)):
		width = widthL[i]
		length = lengthL[i]
		vertices = verticesL[i]
		
		#calculate the shorter of width or height of service core
		if ( tag == 0):
			if (width &lt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2
		else:
			if (width &gt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2		
	
		
		cs1					= 	CoordinateSystem.ByOrigin(vertices[0].X,vertices[0].Y,0)
		cs2					= 	CoordinateSystem.ByOrigin(vertices[index].X,vertices[index].Y,0)
		# to make the primary rectangle ----------------------------------------------------------------------	
		new_Rec 			= 	Rectangle.ByWidthHeight(cs1,new_Width,new_Length)	
		new_Vec				= 	Vector.ByTwoPoints(new_Rec.Points[0],vertices[0])
		new_Rec				=	Geometry.Translate(new_Rec, new_Vec)
		ptsnew_Rec			=	new_Rec.Points
		# to make the secondary rectangle ----------------------------------------------------------------------	
		other_Rec 			= 	Rectangle.ByWidthHeight(cs2,other_Width,other_Length)	
		other_Vec			= 	Vector.ByTwoPoints(other_Rec.Points[index],vertices[index])
		other_Rec			=	Geometry.Translate(other_Rec, other_Vec)
		ptsother_Rec		=	other_Rec.Points
		
		new_RecL.append(new_Rec)
		other_RecL.append(other_Rec)
	
	return [new_RecL,other_RecL]
#============================================================================================================================================================



#make post computations======================================================================================================================================
def coreConfigurator(b_Fac):
	#make the elevator bank rectangle object-----------------------------------------------------1	
	bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
	bank_RecLNew = []
	for i in range(len(bank_RecL)):
		bank_Rec = 	bank_RecL[i]
		widtry1				=	bank_Rec[0].Width
		lentry1				=	bank_Rec[0].Height
				
		# code to readjust the bank rectangle piece based on the final tech rooms and restroom blocks
		if ( widtry1&lt;lentry1):
			shortEdge		=	widtry1
			marked			=	0	
		else:
			shortEdge		=	lentry1
			marked			=	1
				
		if (elevWidth&lt;elevLength):elevEdge = elevWidth
		else:elevEdge =	elevLength			
		numE				=	int(shortEdge / elevEdge)
		numE				+=	1
			
		newDim				=	numE*elevEdge
		if ( marked ==0): ratio	= widtry1/newDim
		else: ratio	= lentry1/newDim
		b_Fac				=	ratio*b_Fac
		#COMMENT THE FOLLOWING IF THE PROPORTION IS ABNORMAL
		bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
		
	return bank_RecL
	#-------------------------------------------------------------------------------------------------
#============================================================================================================================================================


#iterate through all the blocks and output lists for each---------------------------------------------
outList=[]
bankRecList= []
otherRecList=[]
areaRestrmList=[]
areaServModList=[]
servCoreList=[]

perc = 1.1

for i in range(len(twr_BaseptList)):

	flr_Width  = flr_WidthList[i]
	flr_Height = flr_HeightList[i]
	twr_Basept = twr_BaseptList[i]
	corePts	   = corePtList[i]
	
	#globals var, computer area banks, area restrm, area techrms--------------------------------------------------------------------------------------------
	cirProp = liftLobbyWidth/1.5
	
	area_banks			= servElev_Area*num_servElev[i]/perc + passElev_Area*num_passElev[i]/perc
	area_banks			+=cirProp*area_banks # added the circulation area
	area_restroom 		= restroomProp*area_banks								
	area_servmodule 	= techrmProp*area_banks
	
	
	#OUTPUT VALUES-------------------------------------------------------
	vals 				= 	serviceCoreMaker(corePts)
	servCore_Width		=	vals[0]
	servCore_Length		=	vals[1]
	coreVertices		=	vals[2]
	b_Fac				=	vals[3]
	serviceCore_Rec		=	vals[4]
	bank_Rec 			= 	coreConfigurator(b_Fac)	
	
	bankRecList.append(bank_Rec[0])
	otherRecList.append(bank_Rec[1])
	areaRestrmList.append(area_restroom)
	areaServModList.append(area_servmodule)
	servCoreList.append(serviceCore_Rec)
	
	

out = bankRecList,otherRecList,areaRestrmList,areaServModList,servCoreList


#Assign your output to the OUT variable
OUT = out
#OUT = flr_WidthList,flr_HeightList
</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="7a262eff-a70d-4d94-b226-3eb961b0e874" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Total Built Area" x="261.211769700151" y="946.039133250872" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0];&#xA;a[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="0180f91c-ef10-4b23-aac2-5e27c4beec79" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Bank Rectangle Piece" x="797.892973592951" y="1019.11031175644" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="Bank_Rectangle[0];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="265b78cd-60a1-4ef1-a548-58c11f758468" type="DSIronPythonNode.PythonNode" nickname="LATEST : New Elevator Packings" x="1544.83680448945" y="908.684413610096" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="7">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRecL	=	IN[0]
elevWidth	=	IN[1][0]
elevLength	=	IN[1][1]
totElev		=	IN[2]
lobbyWidth	=	IN[3]
servicRecL	=	IN[4]
interLineL	=	IN[5]
maxElevs	=	IN[6]





#FIRST CALLS **********************************************************************************************************************************FIRST CALLS
#to calc how many sub rectangles the elevbankrect needs to be split-------------------------
def getNumRects():
	#very imp transition@@@@@@@@@@@
	recShort	=	otherLen1
	recLong		=	commonLen	
	elevShort	=	getElevShorterDim(elevWidth,elevLength)[0]
	numRects	=	1	
	approx_numElevs	=	int(math.floor(recLong/elevShort))

	#Added to make total num of Elevs always even
	if approx_numElevs%2 &gt; 0: approx_numElevs += 1
	#-----------------------------------------------		
	elevShort 	=	recLong/approx_numElevs		
	while approx_numElevs &gt; maxElevs:
		numRects += 1
		approx_numElevs = int(approx_numElevs/2)	
	return int(numRects)
#------------------------------------------------------------------------------------------num,mainRec



#to subdivide given rect to num of rects based on a num------------------------------------
def subDivRect(num,mainRec):	
	numRects = getNumRects()
	numRects = num
	if numRects &lt; 2 : 
		return "no need to split"
	
	recList = []
	length1 = commonLen
	length2 = otherLen1
	
	dimension = length1/numRects

	startRec = mainRec
	for i in range(numRects):		
		try:
			rec = splitBox(startRec,dimension,length2)
		except:
			recList.append(rec[1])
			return recList			
		recList.append(rec[0])		
		startRec = rec[1]			
	return recList
#------------------------------------------------------------------------------------------



#function to scale rectangles to add in corridors in between elevators-------------------------------------------------------------
def scaledRects(recLists):
	#make new recLists
	newRecs = recLists[:]
	del newRecs[0]
	del newRecs[-1]
	
	
	endRecs = [recLists[0],recLists[-1]]
	
	outRec=[]
	for rec in newRecs:
		pts = rec.Points
		basePt = pts[0]
		wid = rec.Width
		length = rec.Height
		
		l1 = Line.ByStartPointEndPoint(pts[0],pts[1])
		l2 = Line.ByStartPointEndPoint(pts[0],pts[3])
		
		len1 = l1.Length
		len2 = l2.Length
		fac = 0.75 # hardcoded
		
		#prepare basept, p1 and p2 from Scale1D
		if wid == len1: 
			fromPt = pts[1]
			toPt = l1.PointAtParameter(fac)
			midPt = l1.PointAtParameter(0.5)
		else: 
			fromPt = pts[3]
			toPt = l2.PointAtParameter(fac)
			midPt = l2.PointAtParameter(0.5)
		
		#find the vector to translate the scaled rect		
		pCrv = rec.Scale1D(basePt,fromPt,toPt)
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]
			
		lNew1 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[1])
		lNew2 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[3])
			
		if wid == len1: midPtNew = lNew1.PointAtParameter(0.5)
		else: midPtNew = lNew2.PointAtParameter(0.5)
			
			
		#make the vec for translation
		vec= Vector.ByTwoPoints(midPtNew,midPt)
		pCrv = pCrv.Translate(vec)
		
		#block to make rectangle
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]		
		rec = Rectangle.ByCornerPoints(ptsNew[0],ptsNew[3],ptsNew[2],ptsNew[1])
		outRec.append(rec)
			
		
	#code to work on the first and last rectangles.	
	for i in range(len(endRecs)):
		if (i==0):pass
		rec = endRecs[i]
		
		pts = rec.Points
		basePt = pts[0]
		wid = rec.Width
		length = rec.Height
		
		l1 = Line.ByStartPointEndPoint(pts[0],pts[1])
		l2 = Line.ByStartPointEndPoint(pts[0],pts[3])
		
		len1 = l1.Length
		len2 = l2.Length
		fac = 0.9 # hardcoded
		
		#prepare basept, p1 and p2 from Scale1D
		if wid == len1: 
			fromPt = pts[1]
			toPt = l1.PointAtParameter(fac)
			midPt = l1.PointAtParameter(0.5)
		else: 
			fromPt = pts[3]
			toPt = l2.PointAtParameter(fac)
			midPt = l2.PointAtParameter(0.5)
		
		
		
		#find the vector to translate the scaled rect		
		pCrv = rec.Scale1D(basePt,fromPt,toPt)
		crv = pCrv.Curves()
		if(i&gt;0):
			ptsNew = [x.StartPoint for x in crv]
			
			lNew1 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[1])
			lNew2 = Line.ByStartPointEndPoint(ptsNew[0],ptsNew[3])
			
			if wid == len1: midPtNew = lNew1.PointAtParameter(fac/2)
			else: midPtNew = lNew2.PointAtParameter(fac/2)
		
			#make the vec for translation
			vec= Vector.ByTwoPoints(midPtNew,midPt)
			pCrv = pCrv.Translate(vec)

		#block to make rectangle
		crv = pCrv.Curves()
		ptsNew = [x.StartPoint for x in crv]		
		rec = Rectangle.ByCornerPoints(ptsNew[0],ptsNew[3],ptsNew[2],ptsNew[1])
		
		endRecs[i] = rec
		#break	
		
		
	#finally merge all components
	finList=[]		
	finList.extend([endRecs[0]])
	finList.extend(outRec)
	finList.extend([endRecs[-1]])
		
	return finList
#-----------------------------------------------------------------------------------------------------------------------------------
#FIRST CALLS **********************************************************************************************************************************FIRST CALLS

#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------

#get the shorter dimension---------------------------------------------------------------
def getElevShorterDim(width,length):
	if(width&lt;length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge = length
		longEdge  = width
	return shortEdge,longEdge
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------

#====================================================================================================================================================================================
#make rects based on dimension given------------------------------------------------------------------------
def splitBox(rec,dim,length):
	recPts	=	rec.Points
	#make four lines for the input rectangles
	lin0		=	Line.ByStartPointEndPoint(recPts[0],recPts[1])#0
	lin1		=	Line.ByStartPointEndPoint(recPts[1],recPts[2])#1
	lin2 		=	Line.ByStartPointEndPoint(recPts[2],recPts[3])#2
	lin3		=	Line.ByStartPointEndPoint(recPts[3],recPts[0])#3
	# get the first point of first line
	firstPt		=	lin0.StartPoint
	
	# get the length and lines for those edges whose length matches input length
	if lin0.Length &gt;= length-0.005 and lin0.Length &lt;= length+0.005: 
		bigDimension = lin1.Length
		lineShort1 = lin1
		lineShort2 = lin3				
	if lin1.Length &gt;= length-0.005 and lin1.Length &lt;= length+0.005: 
		bigDimension = lin0.Length
		lineShort1 = lin0
		lineShort2 = lin2
	
	#get the points to make the two rectangles
	f1 		=	dim/bigDimension
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	rec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	rec2	=	Rectangle.ByCornerPoints(ptOut1,ptOut2,stPt2,endPt1)
	#get the center points for two rects
	rec1Cen	=	rec1.Center()
	rec2Cen = 	rec2.Center()
	#get the vectors from the first pt
	vec1	=	Vector.ByTwoPoints(firstPt,rec1Cen)
	vec2	=	Vector.ByTwoPoints(firstPt,rec2Cen)
	#compare the length of the vectors to get how far are they from start pt
	vcLen1 	=	vec1.Length
	vcLen2 	=	vec2.Length
	#finally set them as the final ouput rect
	if vcLen1 &lt; vcLen2 :
		outRec1 = 	rec1
		outRec2 = 	rec2
	else:
		outRec1 = 	rec2
		outRec2 = 	rec1	
			
	return outRec1,outRec2
#---------------------------------------------------------------------------------------------------------------	
	
#main function making the elevator packings------------------------------------------------
def makeElevBox(bkRec,commonLen,otherLen1):
	inpRec = []
	inpRec.append(bkRec)

	elevDims	=	getElevShorterDim(elevWidth,elevLength)
	elevShort	=	elevDims[0]
	elevLong	=	elevDims[1]
	
	longCounter = 	0
	listDims	=	[]
	frstPtList	=	[]
	count		=	0
	
	#very imp transition@@@@@@@@@@@
	recShort	=	otherLen1
	recLong		=	commonLen
		
	numElevs	=	int(math.floor(recLong/elevShort))
	#"""
	#Added to make total num of Elevs always even
	if numElevs%2 &gt; 0: 
		numElevs += 1
		#elevShort = recLong/numElevs
	#-----------------------------------------------

	elevShort 	=	recLong/numElevs	
	areaElev 	=	elevShort*commonLen

	
	
	cap = 5		
	#BLOCK TO MAKE LIST OF DIMENSIONS TO PREPARE ELEV ROWS AND LOBBY PLACEMENTS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	#loop till you catch up with the dimension longitudinally
	while (cap&gt;0):
		longCounter += elevLong
		if (longCounter &gt; recShort): # recShort replaced by otherLen   +++ longCounter &gt; recShort-0.005 and longCounter &lt; recShort+0.005
			break
		listDims.append(elevLong)
		if (count%2 ==0):
			longCounter += lobbyWidth	
			if (longCounter &gt; recShort):# recShort replaced by otherLen
				break
			listDims.append(lobbyWidth)			
		count		+= 1
	ct = 0
	lobbies = 0
	# test to check whole length added
	for i in range(len(listDims)):
		ct += listDims[i]
		if (listDims[i] == lobbyWidth):
			lobbies += 1
	#if lobbies == 0: lobbies =1
	#get the left over space
	leftOver =  recShort - ct
	perBayAdd=  leftOver/lobbies
	perBayAdd+=	0.002
	
	# distribute it to the lift lobbies
	if (perBayAdd &gt; 0):
		for i in range(len(listDims)):
			if (listDims[i] == lobbyWidth):
				listDims[i] += perBayAdd + 0.002
	
	#added to make sure the total dimension not exceeding
	if sum(listDims)&gt;otherLen1:
		extra = sum(listDims)-otherLen1
		listDims[-1] -= extra
	
	recLists = []
	stRec	 = bkRec

	index1 = 0
	index2 = 1
	longDim = getShorterDim(servicRec)[1]
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	
	str =""
	prnList=[]
	#BLOCK TO MAKE ELEVATOR ROWS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	for i in range(len(listDims)-1):		
		try:
			rec = splitBox(stRec,listDims[i],commonLen)		
			prnList.append("DID IT")
		except:
			#nRec = stRec.Reverse
			#rec = splitBox(nRec,listDims[i],commonLen)	
			str =  "Not Done"
			prnList.append("FAILED")
			#continue
		recLists.append(rec[0])
		#frstPtList.append(rec[2])
		stRec = rec[1]
		if (i==len(listDims)-2): 
			recLists.append(rec[1])
			prnList.append("LAST CASE")
			#break
	
	#make the list of elevator row first
	elevRowLists = []
	copRecLists =  []
	str = "dont know"
	strN= ""
	for i in range(len(recLists)):
		if i ==0: dimA = listDims[i+1]		
		#if dimA != listDims[i]: copRecLists.append(recLists[i])		

		if i != 0 and dimA !=listDims[i-1] and i == len(recLists)-1 : 
			pass
		elif dimA != listDims[i]: copRecLists.append(recLists[i])
			
		#copRecLists = list(recLists[i] if dimA == listDims[i]:)
	
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	
	#BLOCK TO PLACE ELEVATOR BOXES IN THE ROWS
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
	str2 = ""
	recElevs=[]
	recElevsRow=[]
	for i in range(len(copRecLists)):
		stRec = copRecLists[i]
		elevRow=[]
		shorter = getShorterDim(stRec)[0]
		for j in range(int(numElevs)-1):		
			try:
				rec = splitBox(stRec,elevShort+0.0002,shorter)				
			except:
				#continue
				stt = ""
			stRec = rec[1]
			elevRow.append(rec[0])
			if j==int(numElevs)-2: 
				elevRow.append(rec[1])
			
			#frstPtList.append(rec[2])
			recElevs.append(rec)
			str2 =  " all added" 
		recElevsRow.append(elevRow)
	#@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@	
	totalElev = [len(x) for x in recElevsRow]
	sumtotalElev = sum(totalElev)
	#return recLists,listDims,recDims[0],copRecLists,recElevs,len(recElevs)
	return recElevsRow


def mainCode(mainRec):
	numRc = getNumRects()
	if numRc &gt;=2:
		aRects = subDivRect(getNumRects(),mainRec)
		subRects = scaledRects(aRects)
	else:
		subRects = [mainRec]
	outL = []
	strList=[]
	for i in range(numRc):
		
		bankRec = subRects[i]
		comLen = interLine.Length/numRc
		
		# set commonLength and otherLength
		if (comLen == bankRec.Width): 
			otrLen = bankRec.Height
		elif (comLen == bankRec.Height): 
			otrLen = bankRec.Width
		elif (bankRec.Width&lt;bankRec.Height):
			comLen = bankRec.Width
			otrLen = bankRec.Height
		else:
			comLen = bankRec.Height
			otrLen = bankRec.Width
				
		out = makeElevBox(bankRec,comLen,otrLen)
		outL.append(out)
	return outL
	
#function to see rectangle size ---------------------------------------------------------------------------------------------
def sizeChecker(rec,dim):
	wid = rec.Width
	ht = rec.Height	
	if wid &lt; dim or ht &lt; dim:
		return False
	else: return True
#----------------------------------------------------------------------------------------------------------------------------

"""
mainRecL	=	IN[0]
elevWidthL	=	IN[1][0]
elevLengthL	=	IN[1][1]
totElevL	=	IN[2]
lobbyWidth	=	IN[3]
servicRecL	=	IN[4]
interLineL	=	IN[5][0]
maxElevs	=	IN[6]

"""

outF=[]
interLine  = interLineL[0]
testLen=[]
for i in range(len(mainRecL)):
	#1st Block lev handling each rect block
	coreInside = mainRecL[i]
	#outF.append(len(coreInside))
	interLine  = interLineL[i][0][0]
	
	"""
	if len(coreInside) &lt;1:
		out ="More Than One Cores , Cant Handle"
		#pass
	else:
	"""
	out1=[]
	for j in range(len(coreInside)):
		interLine  = interLineL[i][j][0]
		commonLen	=	float(interLine.Length)
		otherLen1	=	0
		mainRec 	= 	coreInside[j]
		bankRec 	= 	mainRec
		servicRec 	=	servicRecL[i][j]
			
		#if sizeChecker(mainRec,8) == False: break
			
		if (commonLen &gt; mainRec.Width-0.005 and commonLen &lt; mainRec.Width+0.005): otherLen1 = float(mainRec.Height)
		if (commonLen &gt; mainRec.Height-0.005 and commonLen &lt; mainRec.Height+0.005): otherLen1 = float(mainRec.Width)
		out = mainCode(mainRec)
		testLen.append(otherLen1)
		out1.append(out)
	outF.append(out1)
		

		
	










#Assign your output to the OUT variable
#OUT = out,numRc,subRects,bankRec
OUT = outF
</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.DSFunction guid="7e2b9479-2ad5-48e2-8a13-4da02bded48b" type="Dynamo.Nodes.DSFunction" nickname="List.Transpose" x="482.891874678521" y="1045.37138859043" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.List.Transpose@var[]..[]" />
    <DSIronPythonNode.PythonNode guid="a541d8f5-afe2-41ed-a639-a49ee4d6ab59" type="DSIronPythonNode.PythonNode" nickname="Technical Rooms + Restrooms" x="1176.78343077305" y="954.902213312533" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random

wrapperRectL		=	IN[0]
areaTechnicalL		=	IN[1]
areaRestrmL			=	IN[2]







#function to make three rectangle pieces for tech rooms and restroom----------------------------------
def makeThreePiece(width,length,pts,f1,f2):
	if (width &gt; length):
		rec1Length 		=	f1*length
		rec1Width		=	width
		
		rec2Length 		=	f2*length
		rec2Width		=	width
		
		rec3Length 		=	length - rec1Length - rec2Length
		rec3Width		=	width
		
		index			=	1		
	else:
		rec1Length 		=	length
		rec1Width		=	f1*width
		
		rec2Length 		=	length
		rec2Width		=	f2*width
		
		rec3Length 		=	length
		rec3Width		=	width - rec1Width - rec2Width
		
		index			=	3
	
	cs1					= 	CoordinateSystem.ByOrigin(pts[0].X,pts[0].Y,0) 
	
	# to make the 1st rectangle ----------------------------------------------------------------------	
	rec1 				= 	Rectangle.ByWidthHeight(cs1,rec1Width,rec1Length)	
	rec1Vec				= 	Vector.ByTwoPoints(rec1.Points[0],pts[0])
	rec1				=	Geometry.Translate(rec1, rec1Vec)
	rec1Pt				=	rec1.Points	
	cs1					= 	CoordinateSystem.ByOrigin(rec1Pt[0].X,rec1Pt[0].Y,0)
	
	# to make the 2nd rectangle ----------------------------------------------------------------------	
	rec2 				= 	Rectangle.ByWidthHeight(cs1,rec2Width,rec2Length)	
	rec2Vec				= 	Vector.ByTwoPoints(rec2.Points[0],rec1Pt[index])
	rec2				=	Geometry.Translate(rec2, rec2Vec)
	rec2Pt				=	rec2.Points	
	cs1					= 	CoordinateSystem.ByOrigin(rec2Pt[0].X,rec2Pt[0].Y,0)
	
	# to make the 2nd rectangle ----------------------------------------------------------------------	
	rec3 				= 	Rectangle.ByWidthHeight(cs1,rec3Width,rec3Length)	
	rec3Vec				= 	Vector.ByTwoPoints(rec3.Points[0],rec2Pt[index])
	rec3				=	Geometry.Translate(rec3, rec3Vec)
	
	return rec1,rec2,rec3
#END OF FUNCTION#-------------------------------------------------------------------------------------


#function to make three rectangle pieces for tech rooms and restroom----------------------------------
def makeTwoPiece(width,length,pts,f1,f2,flip):
	if flip ==0:
		if (width &gt; length):
			rec1Length 		=	f1*length
			rec1Width		=	width
			
			rec2Length 		=	length-rec1Length#f2*length
			rec2Width		=	width
					
			index			=	1		
		else:
			rec1Length 		=	length
			rec1Width		=	f1*width
			
			rec2Length 		=	length
			rec2Width		=	width-rec1Width#f2*width
				
			index			=	3
	else:
		if (width &lt; length):
			rec1Length 		=	f1*length
			rec1Width		=	width
			
			rec2Length 		=	length-rec1Length#f2*length
			rec2Width		=	width
					
			index			=	1		
		else:
			rec1Length 		=	length
			rec1Width		=	f1*width
			
			rec2Length 		=	length
			rec2Width		=	width-rec1Width#f2*width
				
			index			=	3
	
	cs1					= 	CoordinateSystem.ByOrigin(pts[0].X,pts[0].Y,0) 
	
	# to make the 1st rectangle ----------------------------------------------------------------------	
	rec1 				= 	Rectangle.ByWidthHeight(cs1,rec1Width,rec1Length)	
	rec1Vec				= 	Vector.ByTwoPoints(rec1.Points[0],pts[0])
	rec1				=	Geometry.Translate(rec1, rec1Vec)
	rec1Pt				=	rec1.Points	
	cs1					= 	CoordinateSystem.ByOrigin(rec1Pt[0].X,rec1Pt[0].Y,0)
	
	# to make the 2nd rectangle ----------------------------------------------------------------------	
	rec2 				= 	Rectangle.ByWidthHeight(cs1,rec2Width,rec2Length)	
	rec2Vec				= 	Vector.ByTwoPoints(rec2.Points[0],rec1Pt[index])
	rec2				=	Geometry.Translate(rec2, rec2Vec)
	rec2Pt				=	rec2.Points	
	
	return rec1,rec2
#END OF FUNCTION#-------------------------------------------------------------------------------------
#main function called and executed----------------------------------------------------------------------
def mainCode():
	outT = []
	outR1 = []
	outR2 = []
	
	for i in range(len(wrapperRectL)):
		#tag = random.randint(0,1)
		# incoming rectangle specifications
		wrapR = wrapperRectL[i]
		recListTech=[]
		recListRest1=[]
		recListRest2=[]
		for j in range(len(wrapR)):
			wrapPts			=	wrapR[j].Points
			wrapWidth		=	wrapR[j].Width
			wrapLength		=	wrapR[j].Height
			#added to make the cut direction------------------------------
			if wrapWidth &gt; wrapLength : ratio = wrapLength/wrapWidth
			else : ratio = wrapWidth/wrapLength			
			if ratio &lt; 0.4 : tag = 1
			else: tag = 0 
			
			#----------------------------------------------------------------------------------------
				
			totArea			=	wrapWidth * wrapLength
			facT			=	areaTechnicalL[i][j] / totArea
			facR			=	areaRestrmL[i][j] / totArea
			
			
			
			recA = makeTwoPiece(wrapWidth,wrapLength,wrapPts,0.6,0.4,tag)
			recB = makeTwoPiece(recA[1].Width,recA[1].Height,recA[1].Points,0.5,0.5,1)
			recListTech.append(recA[0])
			recListRest1.append(recB[0])
			recListRest2.append(recB[1])
			
		outT.append(recListTech)
		outR1.append(recListRest1)
		outR2.append(recListRest2)
	return outT,outR1,outR2
#-------------------------------------------------------------------------------------------------------

#Assign your output to the OUT variable
#OUT = [techRec1,otherRec]
OUT = mainCode()</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="2c8387f9-d347-4508-bdbc-7d83227fc138" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Technical Rooms" x="1165.87466837159" y="1066.87051816517" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="techRoom[0];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="91d89c66-f1f0-4dc6-aa82-114cbb0dad5e" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Floor Curve" x="1546.55985157761" y="725.820444365455" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="floorcrv;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="77b4cf82-12e1-4a6f-b8a6-75c43aa3f6bc" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Toilets" x="1547.03627887424" y="640.537379933665" isVisible="false" isUpstreamVisible="true" lacing="Disabled" CodeText="Toilet[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" type="DSIronPythonNode.PythonNode" nickname="Number of Elevators Needed" x="260.123954261395" y="1042.75232399791" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

totalBuiltAreaL	= 	IN[0]
passArea		=	IN[1]
servArea		=	IN[2]

passElevList=[]
servElevList=[]
for i in range(len(totalBuiltAreaL)):
	totalBuiltArea = totalBuiltAreaL[i]
	passElev = math.ceil(totalBuiltArea/passArea)
	servElev = math.ceil(totalBuiltArea/servArea)
	
	#make sure elevator counts are even
	if (passElev % 2 == 1): passElev += 1
	if (servElev % 2 == 1): servElev += 1
	
	passElevList.append(passElev)
	servElevList.append(servElev)




#Assign your output to the OUT variable
OUT = [passElevList, servElevList]</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="688da89c-1178-4f33-8a68-012ab3a575f7" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Area_RestRooms" x="977.641098140332" y="1102.99120136032" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[2];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="d6e22e00-3a84-4a60-a120-3c477d103ab1" type="DSIronPythonNode.PythonNode" nickname="Total Elevs Per Block" x="486.077214383432" y="1130.3380149086" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


elevLists = IN[0]

num = len(elevLists)
finLists=[]
for i in range(num):
	finLists.append(sum(elevLists[i]))


	

#Assign your output to the OUT variable
OUT = finLists</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="38c2edde-a409-4d11-852e-b454f84357a2" type="DSIronPythonNode.PythonNode" nickname="OneList" x="1827.85307888422" y="977.355663183953" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

listElevsList = IN[0]
interLineList = IN[1]





#make one list of the whole elev sublists---------------------------------
def oneList():
	return [z for x in listElevs for y in x for z in y]
#-------------------------------------------------------------------------


#to get the sorted elevs based on distance from closest point to the intersect line---------------------------------------------------------------------
def newSortElevs():
	sortedRect=[]
	avgRecList=[]
	recList = oneList()
	closePtList =[]	
	distList = []
	for i in range(len(recList)):
		recPt = recList[i].Center()		
		closePt = Geometry.ClosestPointTo(interLine[0],recList[i])
		closePtList.append(closePt)
		dist = Line.ByStartPointEndPoint(closePt,recPt).Length
		distList.append(dist)
	
	copyRecList = recList[:]
	sortedDistList = distList[:]
	sortedDistList.sort()
	
	for i in range(len(recList)):
		sortDis = sortedDistList[i]
		for j in range(len(copyRecList)):
			if sortDis == distList[j]:
				found = copyRecList[j]
				del copyRecList[j]
				del distList[j]
				break
		sortedRect.append(found)
	#return distList,sortedDistList,recList,sortedRect,copyRecList
	return sortedRect
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#calc number of elev per row---------------------------------------------------------------------------------------------------------------------------------
def numElevsperRow():
	for i in range(len(listElevs)):
		x = len(listElevs)
		y = len(listElevs[0][0])
		val = x*y
		break
	return val
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#make one list into lists as per rows of elev----------------------------------------------------------------------------------------------------------------
def makeListRow():
	numElevsRow = numElevsperRow()
	sortedElevList = newSortElevs()
	
	#create list of elevators who are combined together per row.
	num = int(len(oneList())/numElevsRow)
	megaList=[]	
	for i in range(num):
		x = i*numElevsRow
		alist = []
		for j in range(x,x+numElevsRow):			
			alist.append(sortedElevList[j])
		megaList.append(alist)
	return megaList
#-----------------------------------------------------------------------------------------------------------------------------------------------------------

#sort the rows based on the start point of instersect line--------------------------------------------------------------------------------------------------
def sortSecondRun():
	rowElevList = makeListRow()
	stPoint = interLine[0].PointAtParameter(0)

	# get the distance list for each row
	fullDistance=[]
	for i in range(len(rowElevList)):
		recList = rowElevList[i]
		disList=[]		
		for j in range(len(recList)):
			rec = recList[j]
			dist = Line.ByStartPointEndPoint(stPoint,rec.Center()).Length
			disList.append(dist)
		fullDistance.append(disList)
	
	
	#sort the distance list
	sortedDistList = fullDistance[:]
	copyElevs = rowElevList[:]
	for i in range(len(sortedDistList)):
		sortedDistList[i] = fullDistance[i][:]
		copyElevs[i] = rowElevList[i][:]
		sortedDistList[i].sort()
	
	#make the new recLists sorted
	for i in range(len(rowElevList)):
		recList = rowElevList[i]
		sortList = sortedDistList[i]
		distList1 = fullDistance[i]
				
		for j in range(len(sortList)):
			rec = recList[j]
			sortdis = sortList[j]
			newRec=[]
			for k in range(len(sortList)):
				if float(sortdis) == float(distList1[k]):
					rowElevList[i][j] = copyElevs[i][k]					
					break
	rev = []
	for i in range(len(rowElevList)):
		rev.append(rowElevList[-i])
	#return fullDistance,rowElevList,distList1,sortedDistList
	return rowElevList
#-----------------------------------------------------------------------------------------------------------------------------------------------------------




"""
listElevsList = IN[0]
interLineList = IN[1]
"""



fin = []
for i in range(len(listElevsList)):
	listElevL = listElevsList[i]
	interLineL = interLineList[i]
	newL=[]
	for j in range(len(listElevL)):
		listElevs = listElevL[j]
		interLine = interLineL[j]
		result = sortSecondRun()
		newL.append(result)
	fin.append(newL)
















#Assign your output to the OUT variable
#OUT = oneList(),out,makePts(),scaleVals(),newSortElevs(),numElevsperRow(),sortSecondRun()
#OUT = sortSecondRun()
OUT = fin</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="1f454317-e3c6-40d5-baed-39e3e34d4239" type="DSIronPythonNode.PythonNode" nickname="Elevator Dimensions" x="259.342477779891" y="1197.86235575563" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN
elevArea	=	IN[0]
ratio		=	IN[1]


len			=	math.sqrt(elevArea/ratio)
wid			=	elevArea/len
#Assign your output to the OUT variable
OUT = wid,len
#OUT = len,wid</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="aea0db6c-0a2c-4326-a096-a90a5302665d" type="DSIronPythonNode.PythonNode" nickname="Technical Room Arrangements&#xD;&#xA;" x="1552.25201245563" y="1125.92952372813" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

mainRecList		=	IN[0]

#---------------------------------------------------------------



# 1 = LONGITUDINAL CUT		0 = TRAVERSAL CUT
#make boxes inside--------------------------------------------------------------------------------
def splitRec(rec,f1,tag):
	recPoints	=	rec.Points
	width		=	rec.Width
	length		=	rec.Height
	#make the four edges of the input rectangle
	lineList	=	[]
	for i in range(len(recPoints)):
		if(i== len(recPoints)-1):
			k = 0
		else:
			k = i+1
		ptA		=	recPoints[i]
		ptB		=	recPoints[k]
		lin		=	Line.ByStartPointEndPoint(ptA,ptB)
		lineList.append(lin)
		
	#pick two points on the shorter lines
	len1	=	lineList[0].Length
	len2	=	lineList[1].Length
	if (tag == 1):
		if (len1&lt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
	else:
		if (len1&gt;len2):
			lineShort1	=	lineList[0]
			lineShort2	=	lineList[2]
		else:
			lineShort1	=	lineList[1]
			lineShort2	=	lineList[3]
		
		
	ptOut1	=	lineShort1.PointAtParameter(f1)
	ptOut2	=	lineShort2.PointAtParameter(1-f1)
	stPt1	=	lineShort1.StartPoint
	endPt1	=	lineShort1.EndPoint
	stPt2	=	lineShort2.StartPoint
	endPt2	=	lineShort2.EndPoint
	# make the new rectangle by corner points !! SEQUENCE OF CORNER POINTS MIGHT BE AN ISSUE
	outRec1	=	Rectangle.ByCornerPoints(stPt1,endPt2,ptOut2,ptOut1)
	outRec2	=	Rectangle.ByCornerPoints(stPt2,endPt1,ptOut1,ptOut2)
		
	#return lineShort1,lineShort2,ptOut1,ptOut2,width,length,outRec1,outRec2
	return outRec1,outRec2
	#return lineList
#END OF FUNCTION# --------------------------------------------------------------------------------


finalList=[]
for i in range(len(mainRecList)):
	mainRecL = mainRecList[i]
	getList = []
	for j in range(len(mainRecL)):
		mainRec 		= 	mainRecL[j]
		outList			=	[]
		twoLinearRecs	=	splitRec(mainRec,0.60,0)
		rec1			=	twoLinearRecs[0]
		rec2			=	twoLinearRecs[1]
		for k in range(3):
			#fac		=	random.random()
			fac 	=	0.35
			out1 	=	splitRec(rec1,fac,0)
			outList.append(out1)
			rec1	=	out1[1]			
			out2 	=	splitRec(rec2,fac,0)
			outList.append(out2)
			rec2	=	out2[1]		
		getList.append(outList)
	finalList.append(getList)
	
	

#Assign your output to the OUT variable
#OUT = lineStoreList,lineList,restrmPoints,shortLine,finalPoint
OUT = finalList</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="4e8981d4-28a3-42e5-a3f4-f8ee4cc28d24" type="DSIronPythonNode.PythonNode" nickname="Separate Bank Maker" x="2138.18975106871" y="586.87333906226" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

elevBoxesList = IN[0]
buildSectionsList=IN[1]





#to fix the sequence of elevators in the elv boxes----------------------------------------------------------------------		
def reverseList():
	global elevBoxes	
	cnt =0
	for i in range(len(elevBoxes)-1):	
		if (i)%2 == 0:
			cnt += 1
			if cnt%2==0:
				str =""
				elevBoxes[i].reverse()
				elevBoxes[i+1].reverse()
#-----------------------------------------------------------------------------------------------------------------------	


#to make one list of input elev lists-----------------------------------------------------------------------------------
def totalElevList():
	newElevBoxes=[]	
	for i in range(len(elevBoxes)):
		elev = elevBoxes[i]
		for j in range(len(elev)):
			newElevBoxes.append(elev[j])
	return newElevBoxes
#-----------------------------------------------------------------------------------------------------------------------	


#to distribute number of elevators per bank based on number elev per row------------------------------------------------
def bankNumbers():
	listElevBoxes=totalElevList()
	totalElevNum = len(listElevBoxes)
	bankNum=[]
	
	perDivision = int(math.floor(totalElevNum/buildSections))
	if (perDivision &gt;= numElevRow): perDivision = numElevRow
	if (perDivision &lt; numElevRow): perDivision = int(numElevRow/2)
	diff = totalElevNum - (perDivision*buildSections)
	
	#perDivision = [numElevRow if perDivision &gt;= numElevRow]
	#perDivision = [numElevRow/2 if perDivision &lt; numElevRow]
	
	if perDivision &gt;=1:
		for i in range(buildSections):
			bankNum.append(perDivision)
		bankNum[-1] += diff
	
	
	#to make all if they all are even numbers
	surplus =0
	for i in range(len(bankNum)):
		if bankNum[i]%2 !=0:
			bankNum[i] -= 1
			surplus	+= 1
	if surplus &gt; 0 : bankNum[-1] += surplus	
	bankNum.sort()
	bankNum.reverse()

	return bankNum
#-----------------------------------------------------------------------------------------------------------------------

#to make separate banks of elevs based on number of building sections---------------------------------------------------
def makePairs():
	str = []
	newElevsList =[]
	for i in range(0,numRows,2): 
		if i == numRows-1:			
			newElevsList.extend(elevBoxes[-1])
			str.append("entered here")
		else:		
			listA = elevBoxes[i]
			listB = elevBoxes[i+1]
			newList = crossLists(listA,listB)
			newElevsList.extend(newList)
			str.append("may be")				
	return newElevsList
#-----------------------------------------------------------------------------------------------------------------------

#to cross two lists togthr and return one list out----------------------------------------------------------------------
def crossLists(listA,listB):
	crossedList = []
	for i in range(len(listA)):
		crossedList.append(listA[i])
		crossedList.append(listB[i])
	return crossedList
#-----------------------------------------------------------------------------------------------------------------------


#to make separate banks of elevs based on number of building sections---------------------------------------------------
def makeBanks():
	#listElevBoxes=totalElevList()
	#totalElevNum = len(listElevBoxes)
	
	listElevBoxes=makePairs()
	totalElevNum = len(listElevBoxes)
	
	elevperBank = bankNumbers()
	elevCount   = 0
	perRowCount = 0
	listBanks=[]
	temp =0	
	for i in range(buildSections):
		elevAtBank =[]
		xVal = elevperBank[i]		
		for j in range(xVal):
			try:
				elevAtBank.append(listElevBoxes[temp+j])
			except:
				print "some error"
			#elevAtBank.append(listElevBoxes[temp+j])
			if ( j == xVal-1): temp = temp + xVal
		listBanks.append(elevAtBank)
	return listBanks
#------------------------------------------------------------------------------------------------------------------------

"""
elevBoxesList = IN[0]
buildSectionsList=IN[1]
"""

outN1=[]
outN2=[]
outTots=[]
for i in range(len(elevBoxesList)):
	elevBoxesL= elevBoxesList[i]
	buildSections = buildSectionsList[i]
	getL1=[]
	getL2=[]
	sum=0
	for j in range(len(elevBoxesL)):
		elevBoxes = elevBoxesL[j]
		numElevRow = len(elevBoxes[0])
		numRows = len(elevBoxes)
		#reverseList()
		out = makeBanks()
		out2 = bankNumbers()
		#crossed = makePairs()
		getL1.append(out)
		getL2.append(out2)
		sum += len(totalElevList())
	outN1.append(getL1)
	outN2.append(getL2)
	outTots.append(sum)



#Assign your output to the OUT variable
OUT = outN1,outN2,outTots
#OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="b762bca7-7630-4b98-b0a1-963b6e7d7c59" type="DSIronPythonNode.PythonNode" nickname="Building sections per Volume" x="1537.08568835684" y="546.549097732907" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

spaceList = IN[0]
buildSec = IN[1]

buildSecs = []
for i in range(len(spaceList)):
	buildSecs.append(buildSec)
	

#Assign your output to the OUT variable
OUT = buildSecs</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="4705291f-75af-4fe7-8cd4-4fad36b2aac3" type="DSIronPythonNode.PythonNode" nickname="Num Floors Each Block" x="2145.05150521491" y="1074.25013162895" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flrList = IN[0]

out=[]
for i in range(len(flrList)):
	out.append(flrList[i].Count)


#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="fa26a732-3c9c-4568-a9ce-52ff425c33cb" type="DSIronPythonNode.PythonNode" nickname="Edge Picker Strat 2" x="29.1991868236279" y="198.791760994905" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type = IN[1]
inputLen = IN[2]
coreDim = IN[3]


#finds number of closest rectangle pieces to find---------------------------------------------------------------------------------------------
def adjacencyList(type):
	adjList = []
	if type ==1: adjList = [0]
	if type ==2: adjList = [1,1]
	if type ==3: adjList = [1,2,1]
	if type ==4: adjList = [2,2,2,2]	
	return adjList
#---------------------------------------------------------------------------------------------------------------------------------------------



#find the common edges between two boxes------------------------------------------------------------------------------------------------------
def findCloseRects(boxList,type):
	indexList = []
	adjList = adjacencyList(type)
	distList=[]
	sortDistList = []
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		distL =[]
		sortL =[]
		indexL=[]		
		for j in range(len(boxList)):
			rec2 = boxList[j]
			recCen2 = rec2.Center()
			dist = recCen.DistanceTo(recCen2)
			#done to make sure further away rectangles dont counted as being close
			v1 = Vector.ByTwoPoints(recCen,recCen2)
			if v1.Length != 0:
				str = "1st enetered"
				vangX = v1.AngleBetween(Vector.XAxis())
				vangY = v1.AngleBetween(Vector.YAxis())
				if type == 4:				
					if int(vangX) == 0 or int(vangY) == 0:
						str ="2nd entered"
						dist = 900000000000000000000000000	
				if type == 5:
					if int(vangX) &lt;30 or int(vangY) &lt;30:
						str ="2nd entered"
						dist = 1		
			
			distL.append(dist)
			
		sortList = distL[:]
		sortList.sort()
		sortL.Add(sortList)
		sortDistList.Add(sortList)
		distList.Add(distL)
		
	indexList=[]
	for i in range(len(distList)):
		distL = distList[i]
		sortL = sortDistList[i]
		numAdj = adjList[i]
		indexL=[]
		for k in range(numAdj):			
			for j in range(len(distL)):			
				if sortL[k+1] == distL[j]:
					index = j
					indexL.append(index)
					#break
		indexList.append(indexL)
	"""
	indexList=[]
	#hardcode it
	indexList.append([2,3])
	indexList.append([3,2])
	indexList.append([1,0])
	indexList.append([1,0])	
	"""	
	return indexList
#---------------------------------------------------------------------------------------------------------------------------------------------
#finds the closest point from a list of points------------------------------------------------------------------------------------------------
def closestPoint(ptA,ptBList):
	distList=[]
	for i in range(len(ptBList)):
		ptB = ptBList[i]
		dist = ptA.DistanceTo(ptB)
		distList.append(dist)

	sortDistList = distList[:]
	sortDistList.sort()
	
	for i in range(len(sortDistList)):
		for j in range(len(sortDistList)):
			if sortDistList[0] == distList[j]: closePtList = ptBList[j]
		break
	return closePtList
#---------------------------------------------------------------------------------------------------------------------------------------------

def edgePicker(boxList,type):
	str = "did not enter"
	edgeList = findCommonEdges(boxList,type)
	finalRecLines=[]
	for i in range(len(boxList)):
		rec = boxList[i]
		recPts = rec.Points
		recLines = rec.Curves()
		list=[]		
		coprecLines = recLines[:]
		list.extend(coprecLines)
		edgeL = edgeList[i]
		pickedLines = []
		for k in range(len(edgeL)):			
			for j in range(len(list)):
				recL = recLines[j]
				rcStart = recL.StartPoint
				rcEnd	= recL.EndPoint
				rLine1 = Line.ByStartPointEndPoint(rcStart,rcEnd)
				rLine2 = Line.ByStartPointEndPoint(rcEnd,rcStart)
				"""
				if rLine1.Length == edgeL[k].Length and rLine1.PointAtParameter(0.5) == edgeL[k].PointAtParameter(0.5): 
					str = "it entered"
					del list[j]	
					break
				else: pickedLines.Add(recL)
				"""
				if rLine1.Length == edgeL[k].Length:
					if	rLine1.PointAtParameter(0.5) == edgeL[k].PointAtParameter(0.5) or rLine2.PointAtParameter(0.5) == edgeL[k].PointAtParameter(0.5):
						str = "it entered"
						del list[j]	
						break
				else: pickedLines.Add(recL)
				
				
						
		finalRecLines.Add(list)
	if type == 4: del finalRecLines[3][-1]
	finalRecLines = convToLine(finalRecLines)
	return finalRecLines


#finds common edges between neighboring rect pieces---------------------------------------------------------------------------------------------
def findCommonEdges(boxList,type):
	TAG = 0
	edgeList = []
	closePtList = []
	indexList = findCloseRects(boxList,type)
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		recPts = rec.Points
		indexL = indexList[i]
		edgeL =[]
		closeL =[]
		for j in range(len(indexL)):
			ind = indexL[j]
			recSide = boxList[ind]
			recSideCen = recSide.Center()
			lin = Line.ByStartPointEndPoint(recCen,recSideCen)
			midPt = lin.PointAtParameter(0.5)
			recSidePts = recSide.Points
			closePt1 = closestPoint(midPt,recSidePts)
			closePt2 = closestPoint(midPt,recPts)
			closePt3 = closestPoint(closePt1,recPts)
			if closePt3 == closePt2 : 
				edge = Line.ByStartPointEndPoint(closePt1,closePt2)
				edge = edgeRedo(rec,edge)				
			else : 
				edge = Line.ByStartPointEndPoint(closePt3,closePt2)
			edgeL.Add(edge)
			closeL.Add([closePt1,closePt2])
		closePtList.Add(closeL)
		edgeL = edgeCleaner(edgeL)		
		edgeList.Add(edgeL)
		
	return edgeList
#----------------------------------------------------------------------------------------------------------------------------------------------

#to clean duplicate items in a list------------------------------------------------------------------------------------------------------------
def edgeCleaner(edgeList):
	copEdgeList = edgeList[:]
	if len(edgeList) &gt; 1:
		for i in range(len(edgeList)-1):		
			edge1 = edgeList[i]
			edge2 = edgeList[i+1]			
			if edge1.PointAtParameter(0.5) == edge2.PointAtParameter(0.5) and edge1.Length == edge2.Length : 
				del copEdgeList[i+1]		
	return copEdgeList
#----------------------------------------------------------------------------------------------------------------------------------------------
#to convert curves to lines--------------------------------------------------------------------------------------------------------------------
def convToLine(edgeList):
	lineList=[]
	for i in range(len(edgeList)):
		lineL=[]
		for j in range(len(edgeList[i])):
			lineL.Add(Line.ByStartPointEndPoint(edgeList[i][j].StartPoint,edgeList[i][j].EndPoint))
		lineList.Add(lineL)
	return lineList
#---------------------------------------------------------------------------------------------------------------------------------------------
#to compute the exact edge on the rec which corresponds to the common intersected edge found---------------------------------------------------
def edgeRedo(rec,edge):
	finalEdgeList = []
	recVecList = []
	recLineList = []
	vecEdge = Vector.ByTwoPoints(edge.StartPoint,edge.EndPoint)
	recPts  = rec.Points
	
	midEdge = edge.PointAtParameter(0.5)
	
	recVecList.Add(Vector.ByTwoPoints(recPts[0],recPts[1]))
	recVecList.Add(Vector.ByTwoPoints(recPts[1],recPts[2]))
	recVecList.Add(Vector.ByTwoPoints(recPts[2],recPts[3]))
	recVecList.Add(Vector.ByTwoPoints(recPts[3],recPts[0]))
	
	recLineList.append(Line.ByStartPointEndPoint(recPts[0],recPts[1]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[1],recPts[2]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[2],recPts[3]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[3],recPts[0]))
	
	newLineList=[]
	distList =[]
	for i in range(len(recVecList)):
		recVec = recVecList[i]
		ang = Vector.AngleBetween(vecEdge,recVec)
		finalEdgeList.append(ang)
		if int(ang) == 0 :
			mid = recLineList[i].PointAtParameter(0.5)
			dist = midEdge.DistanceTo(mid)
			distList.Add(dist)
			newLineList.Add(recLineList[i])
			
	checkDist = 10000000000000000000000	
	for i in range(len(newLineList)):
		if distList[i] &lt; checkDist:
			index = i
			checkDist = distList[i]			
	return newLineList[index]
#----------------------------------------------------------------------------------------------------------------------------------------------




out = edgePicker(emptyBox,type)
#out = findCommonEdges(emptyBox,type)
#out = findCloseRects(emptyBox,type)
#Assign your output to the OUT variable
OUT = out
#OUT = polytoRect(emptyBox[0])</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="8591e8da-2352-4484-896b-bd0a830bf407" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Number of Elev Per Bank" x="2139.02795590961" y="908.317418426933" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="numberElevPerBank[1];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="d2289390-cfe4-44ea-b5a6-20f052a06ae4" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="GBA" x="2137.52513105267" y="814.967023258083" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="grossBuildingArea;" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="f6a4f1b5-654e-4a22-a76c-9855a1543d14" type="DSIronPythonNode.PythonNode" nickname="Key Floor Finder" x="2707.93377220789" y="785.644911997048" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="7">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

buildSectionsList 	= 	IN[0]
grossBuildAreaList	=	IN[1]
elevPerbankListL	=	IN[2]
boundaryFactor		=	IN[3]
servModAreaList		=	IN[4]
elevArea			=	IN[5]
numFloorsList		=	IN[6]



#compute target area for each bank of elev serving each building section--------------------------------------------------------------------
def targetAreaCalculator(uba,buildSections):
	#output target area list for each bank of elev for each building section
	tarAreaList = []	
	#make the uba array
	totalBuildArea = 0
	for i in range(len(uba)):
		totalBuildArea += uba[i]		
	# compute the fraction
	frac 	=	totalBuildArea/buildSections
	
	#compute the target areas by iterating
	for i in range(1,buildSections+1):
		tarAreaList.append(frac*i)	
	return tarAreaList
#-------------------------------------------------------------------------------------------------------------------------------------------

#ccompute the key floors where the banks of elevators needs to be dropped-------------------------------------------------------------------
def keyFloorFinder():
	currentFloor = 1 # current floor counter
	#computer bank Area for each bank ( from elev Area )
	bankArea = [x*elevArea for x in elevPerbankList] 
	#bankArea = [10000 for x in elevPerbankList] 
	
	# iterate to find usable Build Area first
	ubaList = []
	for i in range(len(grossBuildArea)):
		ubaList.append(grossBuildArea[i]-servModArea)
	#compute the targetAreaList
	tarAreaList = targetAreaCalculator(ubaList,buildSections)
	
	#make the served areas list and key floor list and set as 0 values
	servedAreaList = [0 for x in range(buildSections)]		
	key = [0 for x in range(buildSections)]
	
	while currentFloor &lt;= len(ubaList)-1:
		#iterate to check if target is reached
		for i in range(buildSections):
			if servedAreaList[i] &lt; tarAreaList[i] and tarAreaList[i] - servedAreaList[i] &gt;= ubaList[currentFloor]*boundaryFactor:
				ubaList[currentFloor] = ubaList[currentFloor] - bankArea[i] 
		#iterate to check if target is reached	
		for i in range(buildSections):
			if servedAreaList[i] &lt; tarAreaList[i] and tarAreaList[i] - servedAreaList[i] &gt;= ubaList[currentFloor]*boundaryFactor:
				# update served areas and the key floors
				servedAreaList[i] = servedAreaList[i] + ubaList[currentFloor] 
				key[i]	=	key[i] + 1		
		#still checking if target has been reached
		for i in range(buildSections):
			if servedAreaList[i] &gt; tarAreaList[i] and servedAreaList[i] - tarAreaList[i] &gt;= ubaList[currentFloor] - ubaList[currentFloor]*boundaryFactor:
				servedAreaList[i] = servedAreaList[i] - ubaList[key[i]]
				ubaList[key[i]] = ubaList[key[i]] + bankArea[i] 
				for j in range(i+1,buildSections):
					servedAreaList[j] = servedAreaList[j] + bankArea[i] 
					key[i] = key[i] - 1
		tarAreaList = targetAreaCalculator(ubaList,buildSections)
		currentFloor += 1
	return [key,servedAreaList,tarAreaList,ubaList]
#-------------------------------------------------------------------------------------------------------------------------------------------



finalOut =[]
for i in range(len(grossBuildAreaList)):
	grossBuildArea = grossBuildAreaList[i]
	buildSections = buildSectionsList[i]
	elevL = elevPerbankListL[i]
	servModAreaL = servModAreaList[i]
	keyF=[]
	for j in range(len(servModAreaL)):
		elevPerbankList = elevL[j]		
		servModArea = servModAreaL[j]
		tarAreaList = 	targetAreaCalculator(grossBuildArea,buildSections)
		keyFloors	=	keyFloorFinder()
		
		keysTest = keyFloors[0]
		
		count =0
		for i in range(len(keysTest)):
			if keysTest[i] ==0: count += 1
		if count &gt; len(keysTest)/2:
			for i in range(len(keysTest)):
				keysTest[i] = numFloors
		
		keyFloors[0]	= 	keysTest
		keyF.append(keyFloors)
	finalOut.append(keyF)
		
		

#Assign your output to the OUT variable
#OUT = keysTest#
OUT = finalOut</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="9363080c-5ae8-4617-a64d-3833bfbf7e89" type="DSIronPythonNode.PythonNode" nickname="Key OutputGenerator" x="2912.26404817529" y="739.014015557127" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

keyList = IN[0]



#[key,servedAreaList,tarAreaList,ubaList]
finKeyList=[]
finServedAreaList = []
fintarAreaList = []
finubaList = []
for i in range(len(keyList)):
	keyL = keyList[i]
	finKeyL=[]
	finServedAreaL= []
	fintarAreaL = []
	finubaL = []
	for j in range(len(keyL)):
		key = keyL[j]
		finKeyL.append(key[0])
		finServedAreaL.append(key[1])
		fintarAreaL.append(key[2])
		finubaL.append(key[3])
	finKeyList.append(finKeyL)
	finServedAreaList.append(finServedAreaL)
	fintarAreaList.append(fintarAreaL)
	finubaList.append(finubaL)

out = finKeyList,finServedAreaList,fintarAreaList,finubaList
#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="7baa36b9-f520-4749-af0a-75882cc7aa6d" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Target Areas for Banks" x="3320.09112806854" y="697.366885714017" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="targetAreas[2];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="35304e65-3b82-4575-9d8f-a01a1903562b" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Updated UBA" x="3322.98140117645" y="799.141096578338" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="updatedUBA[3];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="dcf7b509-12ba-449b-bf5f-5fd9eaad91cf" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Served Areas by Banks" x="3322.45109595956" y="896.699825396758" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="servedAreas[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="800e5e11-1329-47c6-8ba8-6ef7f390a462" type="DSIronPythonNode.PythonNode" nickname="Feedback Function" x="3651.0754514755" y="877.625100206918" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

ubaListList 			= 	IN[0]
servedAreaListList		=	IN[1]
numElevPerBankList		=	IN[2]
ecap					=	IN[3]
buildSectionsList		=	IN[4]

#--------------------------------------------------------------------------------------------------------------------

# to compute the efficiency of set elevator layouts------------------------------------------------------------------
def feedBack():
	#make a list of area for building sections
	sections	= [0 for x in range(buildSections)]
	sections[0] = servedAreaList[0] # first building section area
	#isolated building section areas  
	totBankCap = 0
	for i in range(1,buildSections):
		sections[i] = servedAreaList[i] - servedAreaList[i-1]
		# total elevator bank capacity
		totBankCap  +=numElevPerBank[i]*ecap	
	#total UBA
	ubaTotal = 0
	for i in range(len(ubaList)):
		ubaTotal 	+=ubaList[i]
	
	#percentage of uba served by every bank
	percentUBA_Bank	= [0 for x in range(buildSections)]
	#used capacity of the banks
	ucap			= [0 for x in range(buildSections)]
	# added to test errors
	if totBankCap ==0 : totBankCap  =1
	for i in range(buildSections):
		percentUBA_Bank[i] = (sections[i]*100)/ubaTotal
		ucap[i] = (sections[i]*100)/totBankCap
	
	return percentUBA_Bank,ucap	
#--------------------------------------------------------------------------------------------------------------------	

"""
ubaListList 			= 	IN[0]
servedAreaListList		=	IN[1]
numElevPerBankList		=	IN[2]
ecap					=	IN[3]
buildSectionsList		=	IN[4]
"""
outF=[]
for i in range(len(ubaListList)):
	ubaL = ubaListList[i]
	buildSections = buildSectionsList[i]
	
	for j in range(len(ubaL)):
		ubaList = ubaL [j]
		servedAreaList = servedAreaListList[i][j]
		numElevPerBank = numElevPerBankList[i][j]		
		out = feedBack()
	outF.append(out)






#Assign your output to the OUT variable
OUT = outF</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="a6fff2cb-4b9c-4c7a-8628-b79fb5814c2e" type="DSIronPythonNode.PythonNode" nickname="Final Num Elevators" x="3653.13246073783" y="815.594560397893" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

rectListList = IN[0]

finX = []

for i in range(len(rectListList)):# big blocks
	rectL = rectListList[i]
	x=0
	for j in range(len(rectL)):# num cores
		rec = rectL[j]
		x += len(rec[0])*len(rec)
	finX.append(x)

#Assign your output to the OUT variable
OUT = finX</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="cca343a8-9f43-4f30-8d90-8877f13e64c6" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Total Elevator Expected" x="3652.96315788749" y="755.467805319367" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="totElev_Expected;" ShouldFocus="false" />
    <Dynamo.Nodes.Symbol guid="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" type="Dynamo.Nodes.Symbol" nickname="Input" x="-430.638734721076" y="99.1853599197803" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="rectangleBox" />
    </Dynamo.Nodes.Symbol>
    <Dynamo.Nodes.Symbol guid="a7a59025-82fb-4c50-82b4-d51887090f61" type="Dynamo.Nodes.Symbol" nickname="Input" x="-430.638734721076" y="159.044351139467" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="floorCurve" />
    </Dynamo.Nodes.Symbol>
    <Dynamo.Nodes.Output guid="f971fc82-95a6-456c-b6a3-118e4d386e56" type="Dynamo.Nodes.Output" nickname="Output" x="4249.42309599132" y="683.030897236116" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="TechRooms+RestRooms" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.Output guid="2202a769-e0b0-42e7-8d17-11ec4a6879de" type="Dynamo.Nodes.Output" nickname="Output" x="4251.62001239109" y="751.852976757304" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="CoreDetails" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.Output guid="876eece8-67d2-4e7d-a218-cda76a4a4836" type="Dynamo.Nodes.Output" nickname="Output" x="4254.53624666385" y="812.572083071159" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="keyFloorsHeights" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.Output guid="bec92abd-3c81-4937-ab19-6d68790c3b2c" type="Dynamo.Nodes.Output" nickname="Output" x="4254.24009146837" y="874.134148952229" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="userFeedBacks" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.Output guid="93433b84-86cc-45f5-a21d-1e5e0d990e53" type="Dynamo.Nodes.Output" nickname="Output" x="4250.96165208502" y="941.04571596103" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="expectedElevs" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.Output guid="3b2958ba-0572-4e7d-a96e-10dbf244d8f4" type="Dynamo.Nodes.Output" nickname="Output" x="4253.95527006873" y="1004.46937883527" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="loadedElevs" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.Output guid="8987678f-615b-42e2-af0f-3dda2a9e49b1" type="Dynamo.Nodes.Output" nickname="Output" x="4255.25956322172" y="1074.07966502748" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="corridorLine" />
    </Dynamo.Nodes.Output>
    <DSIronPythonNode.PythonNode guid="86709535-3941-4970-9a2c-0def2f4b27c1" type="DSIronPythonNode.PythonNode" nickname="Corridor Maker" x="1169.00691460008" y="1159.08185085863" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

recList = IN[0]
corDim = IN[1]

tmp = corDim
recOffsList=[]
for i in range(len(recList)):
	recL = recList[i]
	recOffsL=[]
	for j in range(len(recL)):
		rec = recL[j]
		recCen = rec.Center()
		recWid = rec.Width
		recHt = rec.Height
		cs = CoordinateSystem.ByOrigin(recCen)
		recNew = Rectangle.ByWidthHeight(cs,recWid+corDim,recHt+corDim)
		recOffsL.append(recNew)
	recOffsList.append(recOffsL)
#Assign your output to the OUT variable
OUT = recOffsList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.Output guid="ae23c87e-d01f-4523-9e47-f2a920c13fa9" type="Dynamo.Nodes.Output" nickname="Output" x="4256.22626528778" y="1141.05672738086" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="techRoomInteriorLayouts" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.CodeBlockNodeModel guid="d1e54b16-eb6f-43bc-889b-dfe50e1c2fc3" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Boundary Factor" x="2142.6183112285" y="1139.65506188086" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="boundaryFactor=0.9;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="1972d046-424c-4d3f-aaae-a31fb0aa59ab" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="eCap" x="3323.30920091743" y="960.680005206625" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="eCap=1000;" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="47af02fb-131e-4e14-ad26-a66b2a95c38e" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="BuildSection Limits" x="1375.39511168731" y="281.523801175833" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a=1;&#xA;b=6;" ShouldFocus="false" />
    <DSCoreNodesUI.Input.DoubleSlider guid="f31d76eb-cc6c-4780-9464-fa4cd4dd2e82" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Elev Dimension Ratio" x="-429.734492132885" y="1187.86573883721" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>1.25</System.Double>
      <Range min="0.5" max="2" step="0.25" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="f0ae20e8-eef3-4fb1-9785-9a78b0a3b643" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Corridor Dimension" x="-430.638734721076" y="1251.76323839361" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>2</System.Double>
      <Range min="1.5" max="4" step="0.5" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="4c1d21d9-d7ff-477a-8d3a-a3fc060d9948" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Area Per Elevator" x="-430.638734721076" y="1317.09812872992" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>5</System.Double>
      <Range min="2.5" max="5" step="0.5" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="70528c48-328a-4ae6-a33a-e228ea6bb49b" type="DSCoreNodesUI.Input.DoubleSlider" nickname="TechRooms Proportion" x="-430.638734721076" y="1117.98721241046" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>0.2</System.Double>
      <Range min="0.1" max="0.5" step="0.05" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="5aabb036-665b-4eaa-a4b9-f36ba0c9c788" type="DSCoreNodesUI.Input.DoubleSlider" nickname="RestRooms Proportion" x="-430.638734721076" y="1055.0378224963" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>0.2</System.Double>
      <Range min="0.1" max="0.5" step="0.05" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="987fd9b2-491a-42e3-9320-a8e57d3ace37" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Random Tag" x="-435.066555061375" y="757.584566125949" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>1</System.Double>
      <Range min="0" max="1" step="1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSCoreNodesUI.Input.DoubleSlider guid="699f8ceb-9b13-43b0-9e36-d9668ae92a35" type="DSCoreNodesUI.Input.DoubleSlider" nickname="Core Dimension" x="-430.638734721076" y="921.994377728092" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <System.Double>10</System.Double>
      <Range min="7" max="15" step="0.5" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSIronPythonNode.PythonNode guid="ad82bc3d-3623-4157-a2d1-ffd60ac243ad" type="DSIronPythonNode.PythonNode" nickname="Randomize Strategies" x="1425.13731614126" y="-106.307564487907" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *

import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


strat1 = IN[0]
strat2 = IN[1]
strat3 = IN[2]


randInp = random.randint(1,15)
if randInp &lt;= int(8) : 
	out = strat1
	strat = "Strategy 1"
elif randInp &gt; 8 and randInp &lt;= 11  : 
	out = strat2
	strat = "Strategy 2"
else : 
	out = strat3
	strat = "Strategy 3"
	

#Assign your output to the OUT variable
OUT = out,strat</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.Symbol guid="8193be36-0a4b-4927-93bb-1f1ae2025c32" type="Dynamo.Nodes.Symbol" nickname="Input" x="-430.638734721076" y="219.880199019685" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="shellType" />
    </Dynamo.Nodes.Symbol>
    <Dynamo.Nodes.Symbol guid="1380030a-ec11-473f-9404-a09f966e4a31" type="Dynamo.Nodes.Symbol" nickname="Input" x="-434.180990993315" y="393.561978185842" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="maxDistancetoCore" />
    </Dynamo.Nodes.Symbol>
    <Dynamo.Nodes.Symbol guid="528350cb-70fa-4758-9d24-d0a953058ac5" type="Dynamo.Nodes.Symbol" nickname="Input" x="-434.180990993315" y="459.624427692704" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="liftLobbyWidth" />
    </Dynamo.Nodes.Symbol>
    <Dynamo.Nodes.Symbol guid="d495c094-22bc-4106-8316-bcb52c536fdf" type="Dynamo.Nodes.Symbol" nickname="Input" x="-434.180990993315" y="520.854270695315" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="maxElevperRow" />
    </Dynamo.Nodes.Symbol>
    <Dynamo.Nodes.Symbol guid="f3997b4a-7fef-43d0-accd-ebc31bc8ff1f" type="Dynamo.Nodes.Symbol" nickname="Input" x="-434.180990993315" y="583.79444007729" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="AreaOneElevatorServes" />
    </Dynamo.Nodes.Symbol>
    <Dynamo.Nodes.Output guid="88afcccc-79ba-4a91-b34b-b1cf14a2db8c" type="Dynamo.Nodes.Output" nickname="Output" x="2346.08226117143" y="-8.94798224651761" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="BuildingVerticalSections" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.CodeBlockNodeModel guid="55de3fc0-4d30-4d85-83e6-e17f0fb9bd98" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Lower Upper Levels" x="-434.396603566886" y="823.305700300756" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a=0;&#xA;b=1;" ShouldFocus="false" />
    <Dynamo.Nodes.DSFunction guid="ef315132-c09f-4b58-9322-abb13e656608" type="Dynamo.Nodes.DSFunction" nickname="Random Inputs" x="-261.438841076334" y="815.525928260122" isVisible="true" isUpstreamVisible="true" lacing="Shortest" assembly="DSCoreNodes.dll" function="DSCore.Math.Random@double,double" />
    <DSIronPythonNode.PythonNode guid="1c6610ba-587e-4259-adb4-341fbeaa67c6" type="DSIronPythonNode.PythonNode" nickname="Randomize Tags" x="-87.2671645262141" y="829.035778412073" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

randInp = IN[0]



if randInp &gt; 0.5 : out = 1
else : out = 0

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="01875bdf-1df6-4d15-8106-f5b25ed53104" type="DSIronPythonNode.PythonNode" nickname="BuildingVerticalSection Override" x="1825.12997476486" y="520.264717409469" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random

buildSecVal = IN[0]
heightList = IN[1]

buildSecList = []
for i in range(len(heightList)):
	buildSecList.append(buildSecVal)

for i in range(len(buildSecList)):
	buildSecValue = buildSecList[i]
	height = heightList[i]
	
	if height &lt; 40: buildSecList[i] = 1
	if height &gt;= 80 and height &lt; 200: buildSecList[i] = random.randint(2,4)
	if height &gt;= 200 and height &lt; 350: buildSecList[i] = random.randint(3,5)
	if height &gt;= 350 and height &lt; 500: buildSecList[i] = random.randint(4,6)
	if height &gt;= 500: buildSecList[i] = 5

#Assign your output to the OUT variable
OUT = buildSecList</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.Watch guid="98852ff5-8655-49d9-bba7-b60fed62d7fd" type="Dynamo.Nodes.Watch" nickname="Watch" x="2685.73600853404" y="70.6588858779032" isVisible="true" isUpstreamVisible="true" lacing="Disabled" />
    <DSIronPythonNode.PythonNode guid="97c7174b-50ca-45af-9ac2-33f33ec1351d" type="DSIronPythonNode.PythonNode" nickname="Height Calculator" x="1652.29306030477" y="179.788543406591" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

floorList = IN[0]
zValList = []
for i in range(len(floorList)):
	floorL = floorList[i]	
	for j in range(len(floorL)):	
		flr = floorL[-1]
		zVal = flr.Center().Z
		zValList.append(zVal)
		break

#Assign your output to the OUT variable
OUT = zValList</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="4dbfc0ee-286c-49d5-a507-bdf2c127c0ac" type="DSIronPythonNode.PythonNode" nickname="OLD: BuildingVerticalSection Override" x="1821.89081856746" y="431.409903312008" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random

#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

heightList = IN[0]
buildValues = IN[1]

buildSecList = []
for i in range(len(heightList)):
	height = heightList[i]
	buildSecList[i] = buildValues
	#buildSecList[i] = sectionMaker(buildSecList[i])
	


def sectionMaker(bdValue):	
	if height &lt; 40: bdValue = 1
	elif height &gt;= 80 and height &lt; 200: bdValue = random.randint(1,3)
	elif height &gt;= 200 and height &lt; 350: bdValue = random.randint(2,4)
	elif height &gt;= 350 and height &lt; 500: bdValue = random.randint(3,5)
	elif height &gt;= 500: bdValue = random.randint(5,7)
	else : bdValue = random.randint(1,5)	
	return bdValue

	
	


#Assign your output to the OUT variable
OUT = buildSecList #int(random.uniform(1,3))#buildSecList</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="a6b61826-0a07-45de-bbd4-e8d7cce0f621" type="DSIronPythonNode.PythonNode" nickname="Building Section Values" x="1646.6924751199" y="273.609457406814" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random



#Assign your output to the OUT variable
OUT = random.randint(1,6)</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="4fd9839a-31f0-4854-a2c7-62fb8518d028" type="DSIronPythonNode.PythonNode" nickname="Core Placer Points Strat 3" x="267.204527067499" y="-71.6534703857468" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type     = IN[1]
inputLen = IN[2]
coreDim  = IN[3]
edgeList = IN[4]


#get the shorter dimension---------------------------------------------------------------
def getShorterDim(rec):
	width	=	rec.Width
	length	=	rec.Height
	points = 	rec.Points
	diagDist = Line.ByStartPointEndPoint(points[0],points[2]).Length
	if(width&lt;=length): 
		shortEdge	= width
		longEdge	= length
	else: 
		shortEdge 	= length
		longEdge  	= width
	return shortEdge,longEdge,diagDist
	#return longEdge,shortEdge
# END OF FUNCTION ------------------------------------------------------------------------


#makes the core rectangle based on number of req it has---------------------------------------------------------------------------------------
def makeCoreBox(rec,numCore,wid,ht,longEdge):
	coreList=[]
	cen = rec.Center()
	pts = rec.Points
	ptPlaceList = []
	#when just need to place one core
	if numCore ==1:
		cs = CoordinateSystem.ByOrigin(cen)
		coreRec= Rectangle.ByWidthHeight(cs,wid,ht)
		coreList.append(coreRec)
		ptPlaceList.append(cen)
	#when more than one core needs to be placed
	else:
		len1 = Line.ByStartPointEndPoint(pts[0],pts[1]).Length
		len2 = Line.ByStartPointEndPoint(pts[0],pts[3]).Length
		#find the longer edge and that line
		if len1 == longEdge:
			lin = Line.ByStartPointEndPoint(pts[0],pts[1])
		else:
			lin = Line.ByStartPointEndPoint(pts[0],pts[3])			
		linCen = lin.PointAtParameter(0.5)
		vec = Vector.ByTwoPoints(linCen,cen)
		linNew = lin.Translate(vec)
		#divide the line to get the points to place core		
		linNewLen = linNew.Length
		perDist = linNewLen/(numCore+1)
		
		#prepare the pointlist
		for i in range(numCore):
			pt = linNew.PointAtDistance((i+1)*perDist)
			ptPlaceList.append(pt)
	return ptPlaceList
#---------------------------------------------------------------------------------------------------------------------------------------------

# function which places core boxes into the empty boxes----------------------------------------------------------------------------------------
def getNumCores(boxList):		
	numCoresList=[]
	lenMeasure = inputLen
	wid = coreDim
	ht = coreDim
	for i in range(len(boxList)):
		rec = boxList[i]
		shortEdge = getShorterDim(rec)[0]
		longEdge = getShorterDim(rec)[1]
		diagDist = getShorterDim(rec)[2]
		if longEdge &gt; lenMeasure :
			numCore = int(math.ceil(longEdge/lenMeasure))	
		else :
			numCore=1
		numCoresList.append(numCore)
	return numCoresList
#----------------------------------------------------------------------------------------------------------------------------------------------




def placeCorePoints(boxList,edgeList):
	pointList=[]
	numCoreList = getNumCores(boxList)
	
	finCoreList=[]
	ptFinalList=[]
	for i in range(len(boxList)):
		edgeL = edgeList[i]
		recL = boxList[i]
		numCores = numCoreList[i]
		getCore = 0
		corePlaced =0
		coreList =[]
		count = 0
		while corePlaced &lt; numCores:
			#fill in 0 to initiate the coreList for 1st time
			if count == 0:
				for j in range(len(edgeL)):
					coreList.Add(0)				
			for j in range(len(edgeL)):
				corePlaced += 1
				if corePlaced &gt; numCores : break				
				coreList[j] += 1				
			count += 1
		finCoreList.Add(coreList)
		ptPlaceList = []
		for j in range(len(edgeL)):
			edge = edgeL[j]
			coresEdge = coreList[j]
			perDist = edge.Length/(coresEdge+1)	
			for k in range(coresEdge):
				if coresEdge == 1:
					pt = edge.PointAtParameter(random.uniform(0.2,0.8))
				else:					
					pt = edge.PointAtDistance((k+1)*perDist)
				ptPlaceList.append(pt)
		ptFinalList.Add(ptPlaceList)
			
	 	
	return ptFinalList





out = placeCorePoints(emptyBox,edgeList)
#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="5247996b-e9ff-4e79-91e6-8a53c7e7a33b" type="DSIronPythonNode.PythonNode" nickname="Edge Picker Strat 3" x="32.4504362772745" y="54.2826778833075" isVisible="true" isUpstreamVisible="true" lacing="Disabled" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

emptyBox = IN[0]
type = IN[1]
inputLen = IN[2]
coreDim = IN[3]

#finds number of closest rectangle pieces to find---------------------------------------------------------------------------------------------
def adjacencyList(type):
	adjList = []
	if type ==1: adjList = [0]
	if type ==2: adjList = [1,1]
	if type ==3: adjList = [1,2,1]
	if type ==4: adjList = [2,2,2,2]	
	return adjList
#---------------------------------------------------------------------------------------------------------------------------------------------

#finds the closest point from a list of points------------------------------------------------------------------------------------------------
def closestPoint(ptA,ptBList):
	distList=[]
	for i in range(len(ptBList)):
		ptB = ptBList[i]
		dist = ptA.DistanceTo(ptB)
		distList.append(dist)

	sortDistList = distList[:]
	sortDistList.sort()
	
	for i in range(len(sortDistList)):
		for j in range(len(sortDistList)):
			if sortDistList[0] == distList[j]: closePtList = ptBList[j]
		break
	return closePtList
#---------------------------------------------------------------------------------------------------------------------------------------------
#to convert curves to lines--------------------------------------------------------------------------------------------------------------------
def convToLine(edgeList):
	lineList=[]
	for i in range(len(edgeList)):
		lineL=[]
		for j in range(len(edgeList[i])):
			lineL.Add(Line.ByStartPointEndPoint(edgeList[i][j].StartPoint,edgeList[i][j].EndPoint))
		lineList.Add(lineL)
	return lineList
#---------------------------------------------------------------------------------------------------------------------------------------------

#find the common edges between two boxes------------------------------------------------------------------------------------------------------
def findCloseRects(boxList,type):
	indexList = []
	adjList = adjacencyList(type)
	distList=[]
	sortDistList = []
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		distL =[]
		sortL =[]
		indexL=[]		
		for j in range(len(boxList)):
			rec2 = boxList[j]
			recCen2 = rec2.Center()
			dist = recCen.DistanceTo(recCen2)
			#done to make sure further away rectangles dont counted as being close
			v1 = Vector.ByTwoPoints(recCen,recCen2)
			if v1.Length != 0:
				str = "1st enetered"
				vangX = v1.AngleBetween(Vector.XAxis())
				vangY = v1.AngleBetween(Vector.YAxis())
				if type == 4:				
					if int(vangX) == 0 or int(vangY) == 0:
						str ="2nd entered"
						dist = 900000000000000000000000000	
				if type == 5:
					if int(vangX) &lt;30 or int(vangY) &lt;30:
						str ="2nd entered"
						dist = 1		
			
			distL.append(dist)
			
		sortList = distL[:]
		sortList.sort()
		sortL.Add(sortList)
		sortDistList.Add(sortList)
		distList.Add(distL)
		
	indexList=[]
	for i in range(len(distList)):
		distL = distList[i]
		sortL = sortDistList[i]
		numAdj = adjList[i]
		indexL=[]
		for k in range(numAdj):			
			for j in range(len(distL)):			
				if sortL[k+1] == distL[j]:
					index = j
					indexL.append(index)
					#break
		indexList.append(indexL)
	
	return indexList
#---------------------------------------------------------------------------------------------------------------------------------------------



#finds common edges between neighboring rect pieces---------------------------------------------------------------------------------------------
def findCommonEdges(boxList,type):
	TAG = 0
	edgeList = []
	closePtList = []
	indexList = findCloseRects(boxList,type)
	for i in range(len(boxList)):
		rec = boxList[i]
		recCen = rec.Center()
		recPts = rec.Points
		indexL = indexList[i]
		edgeL =[]
		closeL =[]
		for j in range(len(indexL)):
			ind = indexL[j]
			recSide = boxList[ind]
			recSideCen = recSide.Center()
			lin = Line.ByStartPointEndPoint(recCen,recSideCen)
			midPt = lin.PointAtParameter(0.5)
			recSidePts = recSide.Points
			closePt1 = closestPoint(midPt,recSidePts)
			closePt2 = closestPoint(midPt,recPts)
			closePt3 = closestPoint(closePt1,recPts)
			if closePt3 == closePt2 : 
				edge = Line.ByStartPointEndPoint(closePt1,closePt2)
				edge = edgeRedo(rec,edge)				
			else : 
				edge = Line.ByStartPointEndPoint(closePt3,closePt2)
			edgeL.Add(edge)
			closeL.Add([closePt1,closePt2])
		closePtList.Add(closeL)
		edgeL = edgeCleaner(edgeL)		
		edgeList.Add(edgeL)
		
	return edgeList
#----------------------------------------------------------------------------------------------------------------------------------------------

#adds more edges to the list which are not common----------------------------------------------------------------------------------------------
def addEdge(boxList,type):
	finalEdgeList = []
	commonEdgeList = findCommonEdges(emptyBox,type)
	
	for i in range(len(boxList)):
		rec = boxList[i]
		recPts = rec.Points
		
		l1 = Line.ByStartPointEndPoint(recPts[0],recPts[1])
		l2 = Line.ByStartPointEndPoint(recPts[1],recPts[2])
		l3 = Line.ByStartPointEndPoint(recPts[2],recPts[3])
		l4 = Line.ByStartPointEndPoint(recPts[3],recPts[0])
		
		l1Mid = l1.PointAtParameter(0.5)
		l2Mid = l2.PointAtParameter(0.5)
		l3Mid = l3.PointAtParameter(0.5)
		l4Mid = l4.PointAtParameter(0.5)
		
		commonEdgeL = commonEdgeList[i]
		copiedEdgesL = commonEdgeL[:]
		if len(commonEdgeL) &gt; 1: 
			finalEdgeList.append(copiedEdgesL)	
			continue		
		for j in range(len(commonEdgeL)):
			edge = commonEdgeL[j]
			edgeMid = edge.PointAtParameter(0.5)
			if edgeMid.X == l1Mid.X and edgeMid.Y == l1Mid.Y :
				copiedEdgesL.append(l3)
				break
				pass
			if edgeMid.X == l2Mid.X and edgeMid.Y == l2Mid.Y :
				copiedEdgesL.append(l4)
				break
				pass
			if edgeMid.X == l3Mid.X and edgeMid.Y == l3Mid.Y :
				copiedEdgesL.append(l1)
				break
				pass
			if edgeMid.X == l4Mid.X and edgeMid.Y == l4Mid.Y :
				copiedEdgesL.append(l2)
				break
				pass
		finalEdgeList.append(copiedEdgesL)	
	
	return finalEdgeList
#----------------------------------------------------------------------------------------------------------------------------------------------

#to clean duplicate items in a list------------------------------------------------------------------------------------------------------------
def edgeCleaner(edgeList):
	copEdgeList = edgeList[:]
	if len(edgeList) &gt; 1:
		for i in range(len(edgeList)-1):		
			edge1 = edgeList[i]
			edge2 = edgeList[i+1]			
			if edge1.PointAtParameter(0.5) == edge2.PointAtParameter(0.5) and edge1.Length == edge2.Length : 
				del copEdgeList[i+1]		
	return copEdgeList
#----------------------------------------------------------------------------------------------------------------------------------------------

#to compute the exact edge on the rec which corresponds to the common intersected edge found---------------------------------------------------
def edgeRedo(rec,edge):
	finalEdgeList = []
	recVecList = []
	recLineList = []
	vecEdge = Vector.ByTwoPoints(edge.StartPoint,edge.EndPoint)
	recPts  = rec.Points
	
	midEdge = edge.PointAtParameter(0.5)
	
	recVecList.Add(Vector.ByTwoPoints(recPts[0],recPts[1]))
	recVecList.Add(Vector.ByTwoPoints(recPts[1],recPts[2]))
	recVecList.Add(Vector.ByTwoPoints(recPts[2],recPts[3]))
	recVecList.Add(Vector.ByTwoPoints(recPts[3],recPts[0]))
	
	recLineList.append(Line.ByStartPointEndPoint(recPts[0],recPts[1]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[1],recPts[2]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[2],recPts[3]))
	recLineList.append(Line.ByStartPointEndPoint(recPts[3],recPts[0]))
	
	newLineList=[]
	distList =[]
	for i in range(len(recVecList)):
		recVec = recVecList[i]
		ang = Vector.AngleBetween(vecEdge,recVec)
		finalEdgeList.append(ang)
		if int(ang) == 0 :
			mid = recLineList[i].PointAtParameter(0.5)
			dist = midEdge.DistanceTo(mid)
			distList.Add(dist)
			newLineList.Add(recLineList[i])
			
	checkDist = 10000000000000000000000	
	for i in range(len(newLineList)):
		if distList[i] &lt; checkDist:
			index = i
			checkDist = distList[i]			
	return newLineList[index]
#----------------------------------------------------------------------------------------------------------------------------------------------



out = addEdge(emptyBox,type)
#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" type="DSIronPythonNode.PythonNode" nickname="Service Core Components Strat 3" x="599.47146802149" y="-163.590450454276" isVisible="false" isUpstreamVisible="true" lacing="Disabled" inputcount="12">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

flr_WidthList		=	IN[0]
flr_HeightList		=	IN[1]
twr_BaseptList		=	IN[2]
num_passElev		=	IN[3][0]
num_servElev		=	IN[3][1]

passElev_Area		=	IN[4]
servElev_Area		=	IN[4]
tag					=	IN[5]
elevWidth			=	IN[6][0]
elevLength			=	IN[6][1]
restroomProp		=	IN[7]
techrmProp			=	IN[8]
liftLobbyWidth		=	IN[9]
corePtList			=	IN[10]




#compute service core width, length, and serviceCore====================================================================================================
def serviceCoreMaker(ptL):
	global area_banks, area_restroom,area_servmodule
	rd = random.uniform(0,1)
	#calc total area for service core for the tower
	serviceCore_Area 	= area_banks + area_restroom + area_servmodule;
	serviceCore_Area	= serviceCore_Area/len(ptL)
	area_banks			= area_banks/len(ptL)
	area_restroom		= area_restroom/len(ptL)
	area_servmodule		= area_servmodule/len(ptL)
	
	servCore_WidthL = []
	servCore_LengthL = []
	coreVerticesL = []
	b_FacL =[]
	serviceCore_RecL = []
	for i in range(len(ptL)):
		pt = ptL[i]			
		#calc aspect ratio of floor plate
		aspect_Ratio 		= 	flr_Width/flr_Height
		
		#adjust aspectratio
		if aspect_Ratio &lt; 0.65 : aspect_Ratio = 0.75
		if aspect_Ratio &gt; 1.3 : aspect_Ratio = 1.2
		#calc service core length and width
		if rd&gt;0.5:
			servCore_Length 	=	math.sqrt(serviceCore_Area/aspect_Ratio)
			servCore_Width		=	serviceCore_Area/servCore_Length	
		else:
			servCore_Width		=	math.sqrt(serviceCore_Area/aspect_Ratio)
			servCore_Length 	=	serviceCore_Area/servCore_Width	
		
	
		# get the coordinates of center pt
		x,y,z 					= 	pt.X,pt.Y,pt.Z	
		#make the service core rectangle object--------------------------------------------------------------------------------------------------------------1
		cs					= 	CoordinateSystem.ByOrigin(x,y,z)
		serviceCore_Rec 	= 	Rectangle.ByWidthHeight(cs,servCore_Width,servCore_Length)
		serviceCore_Rec 	=	orientFixNEW(serviceCore_Rec,twr_Basept,pt,servCore_Width,servCore_Length)
		
		
		
		coreVertices		=	serviceCore_Rec.Points
		servCore_WidthL.append(servCore_Width)
		servCore_LengthL.append(servCore_Length)
		coreVerticesL.append(coreVertices)
		serviceCore_RecL.append(serviceCore_Rec)
	#comput elev bank factor--------------------------------------------------------------------
	b_Fac				=	area_banks/serviceCore_Area
	#return serviceCore_Rec,b_Fac,coreVertices,area_banks,area_banks,area_servmodule
	return servCore_WidthL,servCore_LengthL,coreVerticesL,b_Fac,serviceCore_RecL



#function to make boxes based off of width, length and vertices===========================================================================================
def makeBox(widthL,lengthL,verticesL,factor,tag):
	new_RecL=[]
	other_RecL=[]
	for i in range(len(widthL)):
		width = widthL[i]
		length = lengthL[i]
		vertices = verticesL[i]
		
		#calculate the shorter of width or height of service core
		if ( tag == 0):
			if (width &lt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2
		else:
			if (width &gt; length):
				new_Length 		=	length
				new_Width		=	factor*width
				other_Length 	=	length
				other_Width		=	width - new_Width
				index			=	3		
			else:
				new_Width		=	width	
				new_Length		=	factor*length
				other_Width 	=	width
				other_Length	=	length - new_Length
				index			=	2		
	
		
		cs1					= 	CoordinateSystem.ByOrigin(vertices[0].X,vertices[0].Y,0)
		cs2					= 	CoordinateSystem.ByOrigin(vertices[index].X,vertices[index].Y,0)
		# to make the primary rectangle ----------------------------------------------------------------------	
		new_Rec 			= 	Rectangle.ByWidthHeight(cs1,new_Width,new_Length)	
		new_Vec				= 	Vector.ByTwoPoints(new_Rec.Points[0],vertices[0])
		new_Rec				=	Geometry.Translate(new_Rec, new_Vec)
		ptsnew_Rec			=	new_Rec.Points
		# to make the secondary rectangle ----------------------------------------------------------------------	
		other_Rec 			= 	Rectangle.ByWidthHeight(cs2,other_Width,other_Length)	
		other_Vec			= 	Vector.ByTwoPoints(other_Rec.Points[index],vertices[index])
		other_Rec			=	Geometry.Translate(other_Rec, other_Vec)
		ptsother_Rec		=	other_Rec.Points
		
		new_RecL.append(new_Rec)
		other_RecL.append(other_Rec)
	
	return [new_RecL,other_RecL]
#============================================================================================================================================================



#make post computations======================================================================================================================================
def coreConfigurator(b_Fac):
	#make the elevator bank rectangle object-----------------------------------------------------1	
	bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
	bank_RecLNew = []
	for i in range(len(bank_RecL)):
		bank_Rec = 	bank_RecL[i]
		widtry1				=	bank_Rec[0].Width
		lentry1				=	bank_Rec[0].Height
				
		# code to readjust the bank rectangle piece based on the final tech rooms and restroom blocks
		if ( widtry1&lt;lentry1):
			shortEdge		=	widtry1
			marked			=	0	
		else:
			shortEdge		=	lentry1
			marked			=	1
				
		if (elevWidth&lt;elevLength):elevEdge = elevWidth
		else:elevEdge =	elevLength			
		numE				=	int(shortEdge / elevEdge)
		numE				+=	1
			
		newDim				=	numE*elevEdge
		if ( marked ==0): ratio	= widtry1/newDim
		else: ratio	= lentry1/newDim
		b_Fac				=	ratio*b_Fac
		#bank_RecL			=	makeBox(servCore_Width,servCore_Length,coreVertices,b_Fac,tag)
		
	return bank_RecL
	#-------------------------------------------------------------------------------------------------
#============================================================================================================================================================
#to fix the orientation of the serviceCores-----------------------------------------------------------
def orientFixNEW(servCore,twr_Basept,crPt,wid,ht):
	vecX = Vector.XAxis()
	vecY = Vector.YAxis()
	
	vecMain = Vector.ByTwoPoints(crPt,twr_Basept)
	vecMainNormal = vecMain.Normalized()
	
	valX = vecMainNormal.X * vecX.X
	valY = vecMainNormal.Y * vecY.Y
	
	if valX &lt; 0:
		vecX = vecX.Reverse()
		pass
	if valY &lt; 0:
		vecY = vecY.Reverse()
		pass

		
	angX = Vector.AngleBetween(vecMain,vecX) 
	angY = Vector.AngleBetween(vecMain,vecY)
	if angX &lt;= 80 and angX &gt;= 0: # 50 &amp; 10 .... 100 &amp; 10
		vecMain = vecX.Scale(wid/2)		
		servCore = servCore.Translate(vecMain)
	if angY &lt;= 80 and angY &gt;= 0:
		vecMain = vecY.Scale(ht/2)
		servCore = servCore.Translate(vecMain)
	"""
	if angX == 0: # 50 &amp; 10 .... 100 &amp; 10
		vecMain = vecX.Scale(wid/2)		
		servCore = servCore.Translate(vecMain)
	if angY == 0:
		vecMain = vecY.Scale(ht/2)
		servCore = servCore.Translate(vecMain)
		
	"""	
	return servCore
#-----------------------------------------------------------------------------------------------------


#iterate through all the blocks and output lists for each---------------------------------------------
outList=[]
bankRecList= []
otherRecList=[]
areaRestrmList=[]
areaServModList=[]
servCoreList=[]

perc = 1.1

for i in range(len(twr_BaseptList)):

	flr_Width  = flr_WidthList[i]
	flr_Height = flr_HeightList[i]
	twr_Basept = twr_BaseptList[i]
	corePts	   = corePtList[i]
	
	#globals var, computer area banks, area restrm, area techrms--------------------------------------------------------------------------------------------
	cirProp = liftLobbyWidth/1.5
	
	area_banks			= servElev_Area*num_servElev[i]/perc + passElev_Area*num_passElev[i]/perc
	area_banks			+=cirProp*area_banks # added the circulation area
	area_restroom 		= restroomProp*area_banks								
	area_servmodule 	= techrmProp*area_banks
	
	
	#OUTPUT VALUES-------------------------------------------------------
	vals 				= 	serviceCoreMaker(corePts)
	servCore_Width		=	vals[0]
	servCore_Length		=	vals[1]
	coreVertices		=	vals[2]
	b_Fac				=	vals[3]
	serviceCore_Rec		=	vals[4]
	bank_Rec 			= 	coreConfigurator(b_Fac)	
	
	bankRecList.append(bank_Rec[0])
	otherRecList.append(bank_Rec[1])
	areaRestrmList.append(area_restroom)
	areaServModList.append(area_servmodule)
	servCoreList.append(serviceCore_Rec)
	
	

out = bankRecList,otherRecList,areaRestrmList,areaServModList,servCoreList

#out = servCoreList,flr_WidthList[0]/flr_HeightList[0]
#Assign your output to the OUT variable
OUT = out
#OUT = flr_WidthList,flr_HeightList
</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.Output guid="b261e382-1002-4fa4-be47-94938599e9b4" type="Dynamo.Nodes.Output" nickname="Output" x="2346.23148569735" y="51.7027787441849" isVisible="true" isUpstreamVisible="true" lacing="Disabled">
      <Symbol value="strategyUsed" />
    </Dynamo.Nodes.Output>
    <Dynamo.Nodes.CodeBlockNodeModel guid="019f4934-db46-4b3c-95ea-d57d12fc87de" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Code Block" x="1378.19994057099" y="184.919273662576" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[0];" ShouldFocus="false" />
    <Dynamo.Nodes.CodeBlockNodeModel guid="9037733f-0835-41a2-8904-11e6ad04b0b9" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Code Block" x="1651.5273234077" y="-10.4535879485376" isVisible="true" isUpstreamVisible="true" lacing="Disabled" CodeText="a[1];" ShouldFocus="false" />
  </Elements>
  <Connectors>
    <Dynamo.Models.ConnectorModel start="219bd21c-7c34-4adc-9f24-cbd5b4e8efe1" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="10" portType="0" />
    <Dynamo.Models.ConnectorModel start="ca568ee1-0d24-4d67-be51-ec0ee1ddd6b1" start_index="0" end="e0c86771-3dce-4ca3-a942-84506d5b6d3e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9e75d80c-1af2-4485-b4e5-3896d21752e3" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="10" portType="0" />
    <Dynamo.Models.ConnectorModel start="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" start_index="0" end="ad82bc3d-3623-4157-a2d1-ffd60ac243ad" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="e6936ed4-076e-4ee5-954c-a8b3bb72c93a" start_index="0" end="fc659bb3-d44a-45bf-afce-72fe9510b666" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="e6936ed4-076e-4ee5-954c-a8b3bb72c93a" start_index="0" end="fc659bb3-d44a-45bf-afce-72fe9510b666" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="903c6006-4dc7-4a99-b024-03ba30e4572d" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="903c6006-4dc7-4a99-b024-03ba30e4572d" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="903c6006-4dc7-4a99-b024-03ba30e4572d" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc659bb3-d44a-45bf-afce-72fe9510b666" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc659bb3-d44a-45bf-afce-72fe9510b666" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc659bb3-d44a-45bf-afce-72fe9510b666" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc659bb3-d44a-45bf-afce-72fe9510b666" start_index="1" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc659bb3-d44a-45bf-afce-72fe9510b666" start_index="1" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="fc659bb3-d44a-45bf-afce-72fe9510b666" start_index="1" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="9e69b5c2-51e2-479c-abc5-165eabcc97f6" start_index="0" end="ffa333c1-52f5-4a9e-985e-3975f96dbe4d" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="e0c86771-3dce-4ca3-a942-84506d5b6d3e" start_index="0" end="46ca0a06-a4a5-48e1-87e6-24f618ededdb" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="e0c86771-3dce-4ca3-a942-84506d5b6d3e" start_index="0" end="d2289390-cfe4-44ea-b5a6-20f052a06ae4" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="fce72131-bcfc-4f09-a95b-c4e7bd963571" start_index="0" end="265b78cd-60a1-4ef1-a548-58c11f758468" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="fce72131-bcfc-4f09-a95b-c4e7bd963571" start_index="0" end="38c2edde-a409-4d11-852e-b454f84357a2" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="9cc016d9-e977-460e-942a-85a1c94352b8" start_index="0" end="9e69b5c2-51e2-479c-abc5-165eabcc97f6" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9cc016d9-e977-460e-942a-85a1c94352b8" start_index="0" end="c1c7aad1-a830-4169-828c-82b566eac8a9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9cc016d9-e977-460e-942a-85a1c94352b8" start_index="0" end="b8d719f5-d994-4ed0-a5d2-b49225ef43a8" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9cc016d9-e977-460e-942a-85a1c94352b8" start_index="0" end="688da89c-1178-4f33-8a68-012ab3a575f7" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9cc016d9-e977-460e-942a-85a1c94352b8" start_index="0" end="0180f91c-ef10-4b23-aac2-5e27c4beec79" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="46ca0a06-a4a5-48e1-87e6-24f618ededdb" start_index="0" end="7a262eff-a70d-4d94-b226-3eb961b0e874" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="c1c7aad1-a830-4169-828c-82b566eac8a9" start_index="0" end="86709535-3941-4970-9a2c-0def2f4b27c1" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="277fe7d2-09f7-4757-bf06-6c20c4ac9612" start_index="0" end="a541d8f5-afe2-41ed-a639-a49ee4d6ab59" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8d719f5-d994-4ed0-a5d2-b49225ef43a8" start_index="0" end="fce72131-bcfc-4f09-a95b-c4e7bd963571" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8d719f5-d994-4ed0-a5d2-b49225ef43a8" start_index="0" end="265b78cd-60a1-4ef1-a548-58c11f758468" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8d719f5-d994-4ed0-a5d2-b49225ef43a8" start_index="0" end="a541d8f5-afe2-41ed-a639-a49ee4d6ab59" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="b8d719f5-d994-4ed0-a5d2-b49225ef43a8" start_index="0" end="ffa333c1-52f5-4a9e-985e-3975f96dbe4d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ffa333c1-52f5-4a9e-985e-3975f96dbe4d" start_index="0" end="277fe7d2-09f7-4757-bf06-6c20c4ac9612" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ffa333c1-52f5-4a9e-985e-3975f96dbe4d" start_index="0" end="68b29497-a19f-4563-882f-5807fc197be0" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="68b29497-a19f-4563-882f-5807fc197be0" start_index="0" end="a541d8f5-afe2-41ed-a639-a49ee4d6ab59" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="68b29497-a19f-4563-882f-5807fc197be0" start_index="0" end="f6a4f1b5-654e-4a22-a76c-9855a1543d14" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" start_index="0" end="ad82bc3d-3623-4157-a2d1-ffd60ac243ad" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="7a262eff-a70d-4d94-b226-3eb961b0e874" start_index="0" end="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0180f91c-ef10-4b23-aac2-5e27c4beec79" start_index="0" end="fce72131-bcfc-4f09-a95b-c4e7bd963571" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="0180f91c-ef10-4b23-aac2-5e27c4beec79" start_index="0" end="265b78cd-60a1-4ef1-a548-58c11f758468" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="265b78cd-60a1-4ef1-a548-58c11f758468" start_index="0" end="38c2edde-a409-4d11-852e-b454f84357a2" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="7e2b9479-2ad5-48e2-8a13-4da02bded48b" start_index="0" end="d6e22e00-3a84-4a60-a120-3c477d103ab1" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a541d8f5-afe2-41ed-a639-a49ee4d6ab59" start_index="0" end="77b4cf82-12e1-4a6f-b8a6-75c43aa3f6bc" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a541d8f5-afe2-41ed-a639-a49ee4d6ab59" start_index="0" end="f971fc82-95a6-456c-b6a3-118e4d386e56" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a541d8f5-afe2-41ed-a639-a49ee4d6ab59" start_index="0" end="2c8387f9-d347-4508-bdbc-7d83227fc138" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="2c8387f9-d347-4508-bdbc-7d83227fc138" start_index="0" end="aea0db6c-0a2c-4326-a096-a90a5302665d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="91d89c66-f1f0-4dc6-aa82-114cbb0dad5e" start_index="0" end="b762bca7-7630-4b98-b0a1-963b6e7d7c59" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" start_index="0" end="7e2b9479-2ad5-48e2-8a13-4da02bded48b" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="688da89c-1178-4f33-8a68-012ab3a575f7" start_index="0" end="ffa333c1-52f5-4a9e-985e-3975f96dbe4d" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="d6e22e00-3a84-4a60-a120-3c477d103ab1" start_index="0" end="265b78cd-60a1-4ef1-a548-58c11f758468" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="d6e22e00-3a84-4a60-a120-3c477d103ab1" start_index="0" end="cca343a8-9f43-4f30-8d90-8877f13e64c6" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="38c2edde-a409-4d11-852e-b454f84357a2" start_index="0" end="4e8981d4-28a3-42e5-a3f4-f8ee4cc28d24" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="38c2edde-a409-4d11-852e-b454f84357a2" start_index="0" end="a6fff2cb-4b9c-4c7a-8628-b79fb5814c2e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="1f454317-e3c6-40d5-baed-39e3e34d4239" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="1f454317-e3c6-40d5-baed-39e3e34d4239" start_index="0" end="265b78cd-60a1-4ef1-a548-58c11f758468" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="1f454317-e3c6-40d5-baed-39e3e34d4239" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="1f454317-e3c6-40d5-baed-39e3e34d4239" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="aea0db6c-0a2c-4326-a096-a90a5302665d" start_index="0" end="ae23c87e-d01f-4523-9e47-f2a920c13fa9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4e8981d4-28a3-42e5-a3f4-f8ee4cc28d24" start_index="0" end="8591e8da-2352-4484-896b-bd0a830bf407" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4e8981d4-28a3-42e5-a3f4-f8ee4cc28d24" start_index="0" end="2202a769-e0b0-42e7-8d17-11ec4a6879de" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4705291f-75af-4fe7-8cd4-4fad36b2aac3" start_index="0" end="f6a4f1b5-654e-4a22-a76c-9855a1543d14" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="fa26a732-3c9c-4568-a9ce-52ff425c33cb" start_index="0" end="219bd21c-7c34-4adc-9f24-cbd5b4e8efe1" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="8591e8da-2352-4484-896b-bd0a830bf407" start_index="0" end="f6a4f1b5-654e-4a22-a76c-9855a1543d14" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="8591e8da-2352-4484-896b-bd0a830bf407" start_index="0" end="800e5e11-1329-47c6-8ba8-6ef7f390a462" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="d2289390-cfe4-44ea-b5a6-20f052a06ae4" start_index="0" end="f6a4f1b5-654e-4a22-a76c-9855a1543d14" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f6a4f1b5-654e-4a22-a76c-9855a1543d14" start_index="0" end="9363080c-5ae8-4617-a64d-3833bfbf7e89" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9363080c-5ae8-4617-a64d-3833bfbf7e89" start_index="0" end="7baa36b9-f520-4749-af0a-75882cc7aa6d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9363080c-5ae8-4617-a64d-3833bfbf7e89" start_index="0" end="35304e65-3b82-4575-9d8f-a01a1903562b" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9363080c-5ae8-4617-a64d-3833bfbf7e89" start_index="0" end="dcf7b509-12ba-449b-bf5f-5fd9eaad91cf" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9363080c-5ae8-4617-a64d-3833bfbf7e89" start_index="0" end="876eece8-67d2-4e7d-a218-cda76a4a4836" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="35304e65-3b82-4575-9d8f-a01a1903562b" start_index="0" end="800e5e11-1329-47c6-8ba8-6ef7f390a462" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="dcf7b509-12ba-449b-bf5f-5fd9eaad91cf" start_index="0" end="800e5e11-1329-47c6-8ba8-6ef7f390a462" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="800e5e11-1329-47c6-8ba8-6ef7f390a462" start_index="0" end="bec92abd-3c81-4937-ab19-6d68790c3b2c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a6fff2cb-4b9c-4c7a-8628-b79fb5814c2e" start_index="0" end="3b2958ba-0572-4e7d-a96e-10dbf244d8f4" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="cca343a8-9f43-4f30-8d90-8877f13e64c6" start_index="0" end="93433b84-86cc-45f5-a21d-1e5e0d990e53" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="219bd21c-7c34-4adc-9f24-cbd5b4e8efe1" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="9e75d80c-1af2-4485-b4e5-3896d21752e3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="e6936ed4-076e-4ee5-954c-a8b3bb72c93a" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="903c6006-4dc7-4a99-b024-03ba30e4572d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="91d89c66-f1f0-4dc6-aa82-114cbb0dad5e" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="fa26a732-3c9c-4568-a9ce-52ff425c33cb" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="4fd9839a-31f0-4854-a2c7-62fb8518d028" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="6a947df9-c7b5-4854-95cf-ce6d4dbe0c55" start_index="0" end="5247996b-e9ff-4e79-91e6-8a53c7e7a33b" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a7a59025-82fb-4c50-82b4-d51887090f61" start_index="0" end="4705291f-75af-4fe7-8cd4-4fad36b2aac3" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a7a59025-82fb-4c50-82b4-d51887090f61" start_index="0" end="ca568ee1-0d24-4d67-be51-ec0ee1ddd6b1" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a7a59025-82fb-4c50-82b4-d51887090f61" start_index="0" end="97c7174b-50ca-45af-9ac2-33f33ec1351d" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="86709535-3941-4970-9a2c-0def2f4b27c1" start_index="0" end="8987678f-615b-42e2-af0f-3dda2a9e49b1" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="d1e54b16-eb6f-43bc-889b-dfe50e1c2fc3" start_index="0" end="f6a4f1b5-654e-4a22-a76c-9855a1543d14" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="1972d046-424c-4d3f-aaae-a31fb0aa59ab" start_index="0" end="800e5e11-1329-47c6-8ba8-6ef7f390a462" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="47af02fb-131e-4e14-ad26-a66b2a95c38e" start_index="0" end="a6b61826-0a07-45de-bbd4-e8d7cce0f621" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="47af02fb-131e-4e14-ad26-a66b2a95c38e" start_index="1" end="a6b61826-0a07-45de-bbd4-e8d7cce0f621" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f31d76eb-cc6c-4780-9464-fa4cd4dd2e82" start_index="0" end="1f454317-e3c6-40d5-baed-39e3e34d4239" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f0ae20e8-eef3-4fb1-9785-9a78b0a3b643" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="11" portType="0" />
    <Dynamo.Models.ConnectorModel start="f0ae20e8-eef3-4fb1-9785-9a78b0a3b643" start_index="0" end="86709535-3941-4970-9a2c-0def2f4b27c1" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f0ae20e8-eef3-4fb1-9785-9a78b0a3b643" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="11" portType="0" />
    <Dynamo.Models.ConnectorModel start="4c1d21d9-d7ff-477a-8d3a-a3fc060d9948" start_index="0" end="1f454317-e3c6-40d5-baed-39e3e34d4239" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="4c1d21d9-d7ff-477a-8d3a-a3fc060d9948" start_index="0" end="f6a4f1b5-654e-4a22-a76c-9855a1543d14" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="4c1d21d9-d7ff-477a-8d3a-a3fc060d9948" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="4c1d21d9-d7ff-477a-8d3a-a3fc060d9948" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="4c1d21d9-d7ff-477a-8d3a-a3fc060d9948" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="70528c48-328a-4ae6-a33a-e228ea6bb49b" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="8" portType="0" />
    <Dynamo.Models.ConnectorModel start="70528c48-328a-4ae6-a33a-e228ea6bb49b" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="8" portType="0" />
    <Dynamo.Models.ConnectorModel start="70528c48-328a-4ae6-a33a-e228ea6bb49b" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="8" portType="0" />
    <Dynamo.Models.ConnectorModel start="5aabb036-665b-4eaa-a4b9-f36ba0c9c788" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="7" portType="0" />
    <Dynamo.Models.ConnectorModel start="5aabb036-665b-4eaa-a4b9-f36ba0c9c788" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="7" portType="0" />
    <Dynamo.Models.ConnectorModel start="5aabb036-665b-4eaa-a4b9-f36ba0c9c788" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="7" portType="0" />
    <Dynamo.Models.ConnectorModel start="699f8ceb-9b13-43b0-9e36-d9668ae92a35" start_index="0" end="fa26a732-3c9c-4568-a9ce-52ff425c33cb" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="699f8ceb-9b13-43b0-9e36-d9668ae92a35" start_index="0" end="9e75d80c-1af2-4485-b4e5-3896d21752e3" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="699f8ceb-9b13-43b0-9e36-d9668ae92a35" start_index="0" end="219bd21c-7c34-4adc-9f24-cbd5b4e8efe1" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="699f8ceb-9b13-43b0-9e36-d9668ae92a35" start_index="0" end="4fd9839a-31f0-4854-a2c7-62fb8518d028" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="699f8ceb-9b13-43b0-9e36-d9668ae92a35" start_index="0" end="5247996b-e9ff-4e79-91e6-8a53c7e7a33b" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="ad82bc3d-3623-4157-a2d1-ffd60ac243ad" start_index="0" end="019f4934-db46-4b3c-95ea-d57d12fc87de" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="ad82bc3d-3623-4157-a2d1-ffd60ac243ad" start_index="0" end="9037733f-0835-41a2-8904-11e6ad04b0b9" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8193be36-0a4b-4927-93bb-1f1ae2025c32" start_index="0" end="219bd21c-7c34-4adc-9f24-cbd5b4e8efe1" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="8193be36-0a4b-4927-93bb-1f1ae2025c32" start_index="0" end="9e75d80c-1af2-4485-b4e5-3896d21752e3" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="8193be36-0a4b-4927-93bb-1f1ae2025c32" start_index="0" end="fa26a732-3c9c-4568-a9ce-52ff425c33cb" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="8193be36-0a4b-4927-93bb-1f1ae2025c32" start_index="0" end="4fd9839a-31f0-4854-a2c7-62fb8518d028" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="8193be36-0a4b-4927-93bb-1f1ae2025c32" start_index="0" end="5247996b-e9ff-4e79-91e6-8a53c7e7a33b" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="1380030a-ec11-473f-9404-a09f966e4a31" start_index="0" end="219bd21c-7c34-4adc-9f24-cbd5b4e8efe1" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="1380030a-ec11-473f-9404-a09f966e4a31" start_index="0" end="9e75d80c-1af2-4485-b4e5-3896d21752e3" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="1380030a-ec11-473f-9404-a09f966e4a31" start_index="0" end="fa26a732-3c9c-4568-a9ce-52ff425c33cb" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="1380030a-ec11-473f-9404-a09f966e4a31" start_index="0" end="4fd9839a-31f0-4854-a2c7-62fb8518d028" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="1380030a-ec11-473f-9404-a09f966e4a31" start_index="0" end="5247996b-e9ff-4e79-91e6-8a53c7e7a33b" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="528350cb-70fa-4758-9d24-d0a953058ac5" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="9" portType="0" />
    <Dynamo.Models.ConnectorModel start="528350cb-70fa-4758-9d24-d0a953058ac5" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="9" portType="0" />
    <Dynamo.Models.ConnectorModel start="528350cb-70fa-4758-9d24-d0a953058ac5" start_index="0" end="265b78cd-60a1-4ef1-a548-58c11f758468" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="528350cb-70fa-4758-9d24-d0a953058ac5" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="9" portType="0" />
    <Dynamo.Models.ConnectorModel start="d495c094-22bc-4106-8316-bcb52c536fdf" start_index="0" end="265b78cd-60a1-4ef1-a548-58c11f758468" end_index="6" portType="0" />
    <Dynamo.Models.ConnectorModel start="f3997b4a-7fef-43d0-accd-ebc31bc8ff1f" start_index="0" end="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="f3997b4a-7fef-43d0-accd-ebc31bc8ff1f" start_index="0" end="8d5f5d0b-d4e8-45a7-ba8d-6cb22bb87eea" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="55de3fc0-4d30-4d85-83e6-e17f0fb9bd98" start_index="0" end="ef315132-c09f-4b58-9322-abb13e656608" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="55de3fc0-4d30-4d85-83e6-e17f0fb9bd98" start_index="1" end="ef315132-c09f-4b58-9322-abb13e656608" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="ef315132-c09f-4b58-9322-abb13e656608" start_index="0" end="1c6610ba-587e-4259-adb4-341fbeaa67c6" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="1c6610ba-587e-4259-adb4-341fbeaa67c6" start_index="0" end="ccdcaf02-3fb7-40c8-bf9b-92666e3eafda" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="1c6610ba-587e-4259-adb4-341fbeaa67c6" start_index="0" end="c83892ec-b40b-42ff-b27e-ba4a1c619c6a" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="1c6610ba-587e-4259-adb4-341fbeaa67c6" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="5" portType="0" />
    <Dynamo.Models.ConnectorModel start="01875bdf-1df6-4d15-8106-f5b25ed53104" start_index="0" end="4e8981d4-28a3-42e5-a3f4-f8ee4cc28d24" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="01875bdf-1df6-4d15-8106-f5b25ed53104" start_index="0" end="f6a4f1b5-654e-4a22-a76c-9855a1543d14" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="01875bdf-1df6-4d15-8106-f5b25ed53104" start_index="0" end="800e5e11-1329-47c6-8ba8-6ef7f390a462" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="01875bdf-1df6-4d15-8106-f5b25ed53104" start_index="0" end="88afcccc-79ba-4a91-b34b-b1cf14a2db8c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="97c7174b-50ca-45af-9ac2-33f33ec1351d" start_index="0" end="4dbfc0ee-286c-49d5-a507-bdf2c127c0ac" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="97c7174b-50ca-45af-9ac2-33f33ec1351d" start_index="0" end="01875bdf-1df6-4d15-8106-f5b25ed53104" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="97c7174b-50ca-45af-9ac2-33f33ec1351d" start_index="0" end="98852ff5-8655-49d9-bba7-b60fed62d7fd" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a6b61826-0a07-45de-bbd4-e8d7cce0f621" start_index="0" end="01875bdf-1df6-4d15-8106-f5b25ed53104" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="a6b61826-0a07-45de-bbd4-e8d7cce0f621" start_index="0" end="4dbfc0ee-286c-49d5-a507-bdf2c127c0ac" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="4fd9839a-31f0-4854-a2c7-62fb8518d028" start_index="0" end="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" end_index="10" portType="0" />
    <Dynamo.Models.ConnectorModel start="5247996b-e9ff-4e79-91e6-8a53c7e7a33b" start_index="0" end="4fd9839a-31f0-4854-a2c7-62fb8518d028" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" start_index="0" end="ad82bc3d-3623-4157-a2d1-ffd60ac243ad" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="6cefd45a-0d57-4742-b2c5-1c8ea3d772a1" start_index="0" end="ad82bc3d-3623-4157-a2d1-ffd60ac243ad" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="019f4934-db46-4b3c-95ea-d57d12fc87de" start_index="0" end="9cc016d9-e977-460e-942a-85a1c94352b8" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="9037733f-0835-41a2-8904-11e6ad04b0b9" start_index="0" end="b261e382-1002-4fa4-be47-94938599e9b4" end_index="0" portType="0" />
  </Connectors>
  <Notes />
</Workspace>