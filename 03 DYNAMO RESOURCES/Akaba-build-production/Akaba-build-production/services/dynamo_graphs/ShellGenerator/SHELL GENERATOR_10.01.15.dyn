<Workspace Version="0.8.2.2392" X="14.3959795499867" Y="-174.942650595366" zoom="0.635856709296405" Name="Home" Description="" RunType="Automatic" RunPeriod="1000" HasRunWithoutCrash="True">
  <NamespaceResolutionMap />
  <Elements>
    <DSIronPythonNode.PythonNode guid="ad3592c6-0d37-4aee-ac8c-65034e25d578" type="DSIronPythonNode.PythonNode" nickname="Generates Floor Plane Heights" x="738.612368715964" y="815.962890112505" isVisible="false" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import math
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

#inputs------------------------------------------------------------
twr_Height = IN[0]
regflr_Ht  = IN[1]
mechflr_Ht = IN[2]
keyflr_Mech= IN[3]
hasMechFloor = IN[4]
#inputs------------------------------------------------------------

approxNum_Floors  =  twr_Height / regflr_Ht
numberof_MechFloors = math.ceil(approxNum_Floors / keyflr_Mech)
height_Counter = 0
height_List=[]
height = 0
tag = 0

while height&lt;twr_Height:		
	#iterate to add the heights for the regular floors till first mechanical lvl
	for i in range(keyflr_Mech):
		if i == 0 and tag == 0:
			height += 0
			tag = 1
		else:
			height += regflr_Ht
		height_List.append(height)
		
		if (hasMechFloor and (height + mechflr_Ht + 1) &gt; twr_Height): break
		if (not hasMechFloor) and height &gt; twr_Height: break			
				
	if ((height) &gt; twr_Height):	break	

	if hasMechFloor:	
		height += mechflr_Ht
		# add the mechanical floor height to the height list
		height_List.append(height)
 
new_shell_height = height

#Assign your output to the OUT variable
OUT = height_List, new_shell_height</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="57df710f-ce14-48a9-9c6f-c609ca32090c" type="DSIronPythonNode.PythonNode" nickname="Irregular Shape Maker" x="528.475781852519" y="447.19429692583" isVisible="false" isUpstreamVisible="false" lacing="Disabled" isSelectedInput="False" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


x = IN[0]
y = IN[1]
lenX = IN[2]
lenY = IN[3]
type = int(IN[4])

pt = Point.ByCoordinates(x,y,0)

#find the closest point from a point-------------------------------------------------------------------------------------	
def closestPoint(ptA,ptList):
	shortLen	=	100000000000000 # set as a really high value
	index		=	0
	for i in range(len(ptList)):
		vec				= 	Vector.ByTwoPoints(ptA,ptList[i])
		vecLen			=	vec.Length
		if ( vecLen &lt; shortLen ):
			shortLen	=	vecLen
			index		=	i
	# returns the closest point to ptA from the list
	return ptList[index]
#------------------------------------------------------------------------------------------------------------------------




def typeListMaker():
	if type == 1:		
		len = [lenX,lenY,lenX,lenY]
		dir = [0,0,1,1]
		sides = 4		
	if type == 2:
		a = int(lenX/2)		
		b = int(lenY/3)			
		len = [lenX,a,b,lenY-a,lenX-b,lenY]
		dir = [0,0,1,0,1,1]
		sides = 6
	if type == 3:		
		a1 = int(lenX/3)
		a2 = int(lenX/4)
		b = int(lenY/2)	
		len = [lenX,lenY,a1,b,a2,b,lenX-a1-a2,lenY]
		dir = [0,0,1,1,1,0,1,1]
		sides = 8
	if type == 4:
		len = [lenX,lenY,lenX,lenY]
		dir = [0,0,1,1]
		sides = 4	
	return len,dir,sides


#function which makes l shaped profile-----------------------------------------------------------------------------------
def shapeGenerator():
	linList = []
	ptList = []
	
	ptX = Point.ByCoordinates(200000,0,0)
	ptY = Point.ByCoordinates(0,200000,0)
	
	xvec = Vector.ByTwoPoints(pt,ptX)
	yvec = Vector.ByTwoPoints(pt,ptY)
	xvecN = xvec.Reverse()
	yvecN = yvec.Reverse()
	a = int(lenX/2)
	b = int(lenY/3)
	 
	len = typeListMaker()[0]
	dir = typeListMaker()[1]
	sides = typeListMaker()[2]
	
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon = Polygon.ByPoints(ptList)
	polyCenter = polygon.Center()
	closePt = closestPoint(polyCenter,ptList)
	return [polygon],closePt
#---------------------------------------------------------------------------------------------------------------------------



#function which makes  shaped profile---------------------------------------------------------------------------------------
def shapeGenType4():
	linList = []
	ptList = []
	
	ptX = Point.ByCoordinates(200000,0,0)
	ptY = Point.ByCoordinates(0,200000,0)
	
	xvec = Vector.ByTwoPoints(pt,ptX)
	yvec = Vector.ByTwoPoints(pt,ptY)
	xvecN = xvec.Reverse()
	yvecN = yvec.Reverse()
		
	 
	len = typeListMaker()[0]
	dir = typeListMaker()[1]
	sides = typeListMaker()[2]
	
	#1st outer polygon===============================================================
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon = Polygon.ByPoints(ptList)
	polyCenter = polygon.Center()
	closePt = closestPoint(polyCenter,ptList)
	#================================================================================
	a = lenX/1.8
	b = lenY/2.2
	len[0] = len[0] - a
	len[1] = len[1] - b
	len[2] = len[0]
	len[3] = len[1]
	
	linList = []
	ptList = []
	#inner polygon====================================================================
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon2 = Polygon.ByPoints(ptList)
	ptN = Point.ByCoordinates(pt.X+(a/2),pt.Y+(b/2))
	vecShift = Vector.ByTwoPoints(pt,ptN)
	polygon2 = polygon2.Translate(vecShift)
	#================================================================================
	
	
	return [polygon,polygon2],closePt
#---------------------------------------------------------------------------------------------------------------------------


if type == 4: out = shapeGenType4()
else : out = shapeGenerator()

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="bac481de-0358-47d9-8fb5-25e02a10216a" type="DSCoreNodesUI.Input.IntegerSlider" nickname="Shell Type" x="94.58081193718" y="570.53505177466" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True">
      <System.Int32>4</System.Int32>
      <Range min="1" max="4" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSCoreNodesUI.Input.IntegerSlider guid="5be180f4-026d-4892-82c4-67718ab91630" type="DSCoreNodesUI.Input.IntegerSlider" nickname="pos Y" x="93.6714118618327" y="408.622769336678" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True">
      <System.Int32>0</System.Int32>
      <Range min="0" max="200" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSCoreNodesUI.Input.IntegerSlider guid="70e3dca9-3731-4168-8952-b8a16b3b7888" type="DSCoreNodesUI.Input.IntegerSlider" nickname="pos X" x="93.8395218008591" y="351.628577896228" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True">
      <System.Int32>0</System.Int32>
      <Range min="-200" max="0" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <Dynamo.Nodes.CodeBlockNodeModel guid="e0a396a4-216b-48bf-8e6f-906317937665" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="User Input Floor Heights" x="126.580242791707" y="959.292468493156" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True" CodeText="regularFloorHeight = 3.5;&#xA;mechanicalFloorHeight = 7;&#xA;mechFloorFrequency = 18;&#xA;hasMechFloor = false;" ShouldFocus="false" />
    <DSCoreNodesUI.Input.DoubleSlider guid="1c469abf-7c6c-452f-abd9-f8208716be6a" type="DSCoreNodesUI.Input.DoubleSlider" nickname="akaba.input.requirements.totalUsableArea" x="89.8203434050844" y="882.666321807975" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True">
      <System.Double>70000</System.Double>
      <Range min="0" max="100000" step="0.1" />
    </DSCoreNodesUI.Input.DoubleSlider>
    <DSIronPythonNode.PythonNode guid="e59c2d4a-e903-41b8-b931-14ce5aa625c7" type="DSIronPythonNode.PythonNode" nickname="getShellHeight" x="533.067085454863" y="702.183294080116" isVisible="false" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" inputcount="4">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variables.
dataEnteringNode = IN

width = IN[0]
length = IN[1]
totalUsableArea = IN[2]
floorheight = IN[3]

volume = totalUsableArea*floorheight

height = 0

if (width!=0 and length!=0):
	height = volume/(width*length)


#Assign your output to the OUT variable.
OUT = height</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="8219e2c4-7592-4fcd-b294-d1f5d8224cd0" type="DSCoreNodesUI.Input.IntegerSlider" nickname="akaba.input.requirements.site.width" x="92.4660888174656" y="737.103622406821" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True">
      <System.Int32>30</System.Int32>
      <Range min="10" max="200" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSCoreNodesUI.Input.IntegerSlider guid="0def3b5c-c62c-403a-810c-132967c3eb8a" type="DSCoreNodesUI.Input.IntegerSlider" nickname="akaba.input.requirements.site.height" x="91.2407764149455" y="798.89874928058" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True">
      <System.Int32>30</System.Int32>
      <Range min="10" max="200" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <Dynamo.Nodes.DSFunction guid="0c96b696-128e-4afd-9fc1-a1528d9a4f0c" type="Dynamo.Nodes.DSFunction" nickname="Curve.ExtrudeAsSolid" x="1120.04782485652" y="550.70329575436" isVisible="false" isUpstreamVisible="true" lacing="Shortest" isSelectedInput="False" assembly="ProtoGeometry.dll" function="Autodesk.DesignScript.Geometry.Curve.ExtrudeAsSolid@double">
      <PortInfo index="1" default="True" />
    </Dynamo.Nodes.DSFunction>
    <Dynamo.Nodes.CodeBlockNodeModel guid="794bfc76-1ecf-4457-84e7-d5dda7ff123b" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="split output" x="696.859779858544" y="451.666948822038" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" CodeText="list[0];&#xA;list[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="0d59e559-86a5-4ed3-8512-8927ca1a3974" type="DSIronPythonNode.PythonNode" nickname="Floor Maker" x="1340.49444068241" y="789.254202454487" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

recList=IN[0]
floorHeights = IN[1]


#makes floors translate to given height list---------------------------------------------------------------------------------------
def floorTranslator(recList,flrHtList):
	outlines = []
	#define the translation vector
	ptA = Point.ByCoordinates(0,0,0)
	ptB = Point.ByCoordinates(0,0,100)
	vec = Vector.ByTwoPoints(ptA,ptB)
	
	for j in range(len(flrHtList)):
		dist = flrHtList[j]
		tempList = []
		
		for i in range(len(recList)):
			rec = recList[i]
			newRec = rec.Translate(vec,dist)
			tempList.append(newRec)
		outlines.append(tempList)
	return outlines
#---------------------------------------------------------------------------------------------------------------------------------


out = floorTranslator(recList,floorHeights)

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="b2af0b4e-3c7b-4b93-830a-82739c84ddb8" type="DSIronPythonNode.PythonNode" nickname="Irregular Shape Maker" x="1009.08300136558" y="-439.117503255595" isVisible="false" isUpstreamVisible="false" lacing="Disabled" isSelectedInput="False" inputcount="5">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN


x = IN[0]
y = IN[1]
lenX = IN[2]
lenY = IN[3]
type = int(IN[4])

pt = Point.ByCoordinates(x,y,0)

#find the closest point from a point-------------------------------------------------------------------------------------	
def closestPoint(ptA,ptList):
	shortLen	=	100000000000000 # set as a really high value
	index		=	0
	for i in range(len(ptList)):
		vec				= 	Vector.ByTwoPoints(ptA,ptList[i])
		vecLen			=	vec.Length
		if ( vecLen &lt; shortLen ):
			shortLen	=	vecLen
			index		=	i
	# returns the closest point to ptA from the list
	return ptList[index]
#------------------------------------------------------------------------------------------------------------------------




def typeListMaker():
	if type == 1:		
		len = [lenX,lenY,lenX,lenY]
		dir = [0,0,1,1]
		sides = 4		
	if type == 2:
		a = int(lenX/2)		
		b = int(lenY/3)			
		len = [lenX,a,b,lenY-a,lenX-b,lenY]
		dir = [0,0,1,0,1,1]
		sides = 6
	if type == 3:		
		a1 = int(lenX/3)
		a2 = int(lenX/4)
		b = int(lenY/2)	
		len = [lenX,lenY,a1,b,a2,b,lenX-a1-a2,lenY]
		dir = [0,0,1,1,1,0,1,1]
		sides = 8
	if type == 4:
		len = [lenX,lenY,lenX,lenY]
		dir = [0,0,1,1]
		sides = 4	
	return len,dir,sides


#function which makes l shaped profile-----------------------------------------------------------------------------------
def shapeGenerator():
	linList = []
	ptList = []
	
	ptX = Point.ByCoordinates(200000,0,0)
	ptY = Point.ByCoordinates(0,200000,0)
	
	xvec = Vector.ByTwoPoints(pt,ptX)
	yvec = Vector.ByTwoPoints(pt,ptY)
	xvecN = xvec.Reverse()
	yvecN = yvec.Reverse()
	a = int(lenX/2)
	b = int(lenY/3)
	 
	len = typeListMaker()[0]
	dir = typeListMaker()[1]
	sides = typeListMaker()[2]
	
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon = Polygon.ByPoints(ptList)
	polyCenter = polygon.Center()
	closePt = closestPoint(polyCenter,ptList)
	return polygon,closePt
#---------------------------------------------------------------------------------------------------------------------------



#function which makes  shaped profile---------------------------------------------------------------------------------------
def shapeGenType4():
	linList = []
	ptList = []
	
	ptX = Point.ByCoordinates(200000,0,0)
	ptY = Point.ByCoordinates(0,200000,0)
	
	xvec = Vector.ByTwoPoints(pt,ptX)
	yvec = Vector.ByTwoPoints(pt,ptY)
	xvecN = xvec.Reverse()
	yvecN = yvec.Reverse()
		
	 
	len = typeListMaker()[0]
	dir = typeListMaker()[1]
	sides = typeListMaker()[2]
	
	#1st outer polygon===============================================================
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon = Polygon.ByPoints(ptList)
	polyCenter = polygon.Center()
	closePt = closestPoint(polyCenter,ptList)
	#================================================================================
	a = lenX/1.8
	b = lenY/2.2
	len[0] = len[0] - a
	len[1] = len[1] - b
	len[2] = len[0]
	len[3] = len[1]
	
	linList = []
	ptList = []
	#inner polygon====================================================================
	point = pt
	ptList.append(point)
	for i in range(sides):
		#toggle vec values
		if i%2 ==0:
			if dir[i]==0: vec = xvec
			else: vec = xvecN
		else:
			if dir[i]==0: vec = yvec
			else: vec = yvecN	
		l1 = Line.ByStartPointDirectionLength(point,vec,len[i])
		linList.append(l1)
		point = l1.EndPoint
		ptList.append(point)
	polygon2 = Polygon.ByPoints(ptList)
	ptN = Point.ByCoordinates(pt.X+(a/2),pt.Y+(b/2))
	vecShift = Vector.ByTwoPoints(pt,ptN)
	polygon2 = polygon2.Translate(vecShift)
	#================================================================================
	
	
	return [polygon,polygon2],closePt
#---------------------------------------------------------------------------------------------------------------------------


if type == 4: out = shapeGenType4()
else : out = shapeGenerator()

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <DSCoreNodesUI.Input.IntegerSlider guid="10bf8d65-92d3-4413-9f00-b3d4c93b37c8" type="DSCoreNodesUI.Input.IntegerSlider" nickname="Random Height Generator" x="995.2176083525" y="-305.216128003081" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="True">
      <System.Int32>28</System.Int32>
      <Range min="0" max="100" step="1" />
    </DSCoreNodesUI.Input.IntegerSlider>
    <DSIronPythonNode.PythonNode guid="65cb9412-3dde-465a-ad54-d3bd33e90e69" type="DSIronPythonNode.PythonNode" nickname="Box Maker" x="1261.30260929373" y="-420.981729728592" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" inputcount="2">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

polygon = IN[0][0]
closPt = IN[0][1]
type = IN[1]
if type!=4:
	polyPts = polygon.Points

#finds the opposite point to the closest point-------------------------------------------------
def oppPointFinder(poly,closPt):
	polyPts = poly.Points
	for i in range(len(polyPts)):
		if closPt == polyPts[i]:
			oppPt = polyPts[i-3]
			index = i
			break	
	return oppPt,index
#---------------------------------------------------------------------------------------------


#find the closest point from a point-------------------------------------------------------------------------------------	
def closestPoint(ptA,ptList):
	shortLen	=	100000000000000 # set as a really high value
	index		=	0
	for i in range(len(ptList)):
		vec				= 	Vector.ByTwoPoints(ptA,ptList[i])
		vecLen			=	vec.Length
		if ( vecLen &lt; shortLen ):
			shortLen	=	vecLen
			index		=	i
	# returns the closest point to ptA from the list
	return ptList[index]
#------------------------------------------------------------------------------------------------------------------------




#func to split the type3 polygon to regular rect and l shape rect-----------------------------
def multiRecMaker():
	oppPt = oppPointFinder(polygon,closPt)[0]
	id = oppPointFinder(polygon,closPt)[1]-3
	siz = len(polyPts)
	
	lin = Line.ByStartPointEndPoint(closPt,polyPts[id+4])
	lin = lin.Extend(300,lin.StartPoint)
	
	crvsPoly = polygon.Curves()
	for crvs in crvsPoly:		
		pt = Geometry.Intersect(lin,crvs)
		if pt != None:
			break
	ptListA = [polyPts[0],pt[0],polyPts[id+4],polyPts[id+5]]
	ptListB = [pt[0],polyPts[id-1],polyPts[id],polyPts[id+1],polyPts[id+2],polyPts[id+3]]
	polyA = Polygon.ByPoints(ptListA)	
	polyB = Polygon.ByPoints(ptListB)
	polyNew = recMakers(polyB)
	#return lin,oppPt,polyPts[id],crvsPoly,pt,polyA,polyB
	return polyA,polyNew[0],polyNew[1]
#----------------------------------------------------------------------------------------------	
	
	
def recFromType4():
	poly1 = polygon[0]
	poly2 = polygon[1]
	polyPts1 = poly1.Points
	polyPts2 = poly2.Points
	pt=[]
	
	lin1 = Line.ByStartPointEndPoint(polyPts2[0],polyPts2[1])
	lin1 = lin1.Extend(300,lin1.StartPoint)
	lin1 = lin1.Extend(300,lin1.EndPoint)
	
	lin2 = Line.ByStartPointEndPoint(polyPts2[2],polyPts2[3])
	lin2 = lin2.Extend(300,lin2.StartPoint)
	lin2 = lin2.Extend(300,lin2.EndPoint)
	
	crvsPoly1 = poly1.Curves()
	for crvs in crvsPoly1:
		ptInt = Geometry.Intersect(lin1,crvs)
		if len(ptInt) == 0:	continue
		else: pt.append(ptInt[0])
		
	ptList1 = [pt[0],pt[1],polyPts1[0],polyPts1[1]]
	polyA = Polygon.ByPoints(ptList1)	
	for crvs in crvsPoly1:		
		ptInt = Geometry.Intersect(lin2,crvs)
		if len(ptInt) == 0:	continue
		else: pt.append(ptInt[0])	
		
	ptList2 = [pt[3],pt[2],polyPts1[2],polyPts1[3]]
	polyB = Polygon.ByPoints(ptList2)
	
	ptList3 = [pt[2],pt[0],polyPts2[1],polyPts2[2]]
	polyC = Polygon.ByPoints(ptList3)
	
	ptList4 = [pt[3],pt[1],polyPts2[0],polyPts2[3]]
	polyD = Polygon.ByPoints(ptList4)
	return polyA,polyB,polyC,polyD
	
	
	
	
#func to convert polygon to a rectangle---------------------------------------------------
def polytoRect(poly):
	crvs = poly.Curves()
	polyPts = poly.Points
	polyCen = poly.Center()
	wid = Line.ByStartPointEndPoint(polyPts[0],polyPts[1]).Length
	ht = Line.ByStartPointEndPoint(polyPts[0],polyPts[3]).Length
	
	cs = CoordinateSystem.ByOrigin(polyCen)
	#rec = Rectangle.ByWidthHeight(cs,wid,ht)
	
	ptList=[]
	for i in range(len(crvs)-1):
		pt = crvs[i].StartPoint
		ptList.append(pt)	
	rec = Rectangle.ByCornerPoints(ptList)
	return rec
#-----------------------------------------------------------------------------------------

#makes two polygons for two places in the l shape---------------------------------------------
def recMakers(poly):
	#poly = multiRecMaker()[1]
	polyPts = poly.Points
	polyCen = poly.Center()
	
	closPt = closestPoint(polyCen,polyPts)
	 
	oppPt = oppPointFinder(poly,closPt)[0]
	id = oppPointFinder(poly,closPt)[1]-3
	line1 = Line.ByStartPointEndPoint(polyPts[id],polyPts[id+1])
	line2 = Line.ByStartPointEndPoint(polyPts[id-1],polyPts[id-2])
	dist = line2.Length	
	ptNew = line1.PointAtParameter(dist/line1.Length)
	
	ptListA = [polyPts[id],polyPts[id-1],polyPts[id-2],ptNew]
	ptListB = [ptNew,polyPts[id-3],polyPts[id-4],polyPts[id-5]]
	
	polyA = Polygon.ByPoints(ptListA)
	polyB = Polygon.ByPoints(ptListB)
	
	return polyA,polyB
#---------------------------------------------------------------------------------------------

if type==1: out = [polygon]
if type==2: out = recMakers(polygon)
if type==3: out = multiRecMaker()
if type==4: out = recFromType4()

recListFinal = [polytoRect(out[i]) for i in range(len(out)) ]
#Assign your output to the OUT variable
OUT = recListFinal
#OUT = recMakers()</Script>
    </DSIronPythonNode.PythonNode>
    <DSIronPythonNode.PythonNode guid="92f0d8e8-7994-4e62-87b0-54dd6a24f525" type="DSIronPythonNode.PythonNode" nickname="Floor Maker" x="1442.48687973166" y="-425.369737206316" isVisible="false" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" inputcount="3">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
import sys
sys.path.append("C:\Program Files (x86)\IronPython 2.7\Lib")
import random
#The inputs to this node will be stored as a list in the IN variable.
dataEnteringNode = IN

recList=IN[0]
floorHeights = IN[1]

#makes variable length floor height list-------------------------------------------------------------------------------------------
def variableFloorHeight(flrHtList):
	newFlrHtList = []
	for i in range(len(recList)):
		y = len(flrHtList)
		x = y/2
		a = int(random.uniform(x,y))
		flrTest = flrHtList[:a]
		newFlrHtList.append(flrTest)
	return newFlrHtList
#----------------------------------------------------------------------------------------------------------------------------------




#makes floors translate to given height list---------------------------------------------------------------------------------------
def floorTranslator(recList,flrHtList):
	newRecList = []
	ptA = Point.ByCoordinates(0,0,0)
	ptB = Point.ByCoordinates(0,0,100)
	vec = Vector.ByTwoPoints(ptA,ptB)
	for i in range(len(recList)):
		rec = recList[i]
		recNList=[]
		flrHeights = flrHtList[i]
		for j in range(len(flrHeights)):
			dist = flrHeights[j]
			newRec = rec.Translate(vec,dist)
			recNList.append(newRec)
		newRecList.append(recNList)
	return newRecList
#---------------------------------------------------------------------------------------------------------------------------------


flrNewHeights = variableFloorHeight(floorHeights)
out = floorTranslator(recList,flrNewHeights)

#Assign your output to the OUT variable
OUT = out</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.CodeBlockNodeModel guid="d2053ff0-991b-4328-a266-f1c1658982cc" type="Dynamo.Nodes.CodeBlockNodeModel" nickname="Code Block" x="979.848219453823" y="819.593300263347" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" CodeText="list[0];&#xA;list[1];" ShouldFocus="false" />
    <DSIronPythonNode.PythonNode guid="8aa817bf-2902-44c6-a25f-94b337648685" type="DSIronPythonNode.PythonNode" nickname="getSolidDifference" x="1339.13737606799" y="702.428633783962" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" inputcount="1">
      <Script>import clr
clr.AddReference('ProtoGeometry')
from Autodesk.DesignScript.Geometry import *
#The inputs to this node will be stored as a list in the IN variables.
dataEnteringNode = IN

solidList = IN[0]

if len(solidList)&gt;1:
	outerSolid = solidList[0]
	for i in range(1, len(solidList)):
		result = Solid.Difference(outerSolid, solidList[i])
		outerSolid = result
		OUT = [outerSolid]
else:
	OUT = solidList


</Script>
    </DSIronPythonNode.PythonNode>
    <Dynamo.Nodes.Watch guid="06ffb940-c1aa-454c-b771-c48bdb3ebd8b" type="Dynamo.Nodes.Watch" nickname="adjusted shell height" x="1332.99775529764" y="924.682905670695" isVisible="true" isUpstreamVisible="true" lacing="Disabled" isSelectedInput="False" />
  </Elements>
  <Connectors>
    <Dynamo.Models.ConnectorModel start="ad3592c6-0d37-4aee-ac8c-65034e25d578" start_index="0" end="d2053ff0-991b-4328-a266-f1c1658982cc" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="57df710f-ce14-48a9-9c6f-c609ca32090c" start_index="0" end="794bfc76-1ecf-4457-84e7-d5dda7ff123b" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="bac481de-0358-47d9-8fb5-25e02a10216a" start_index="0" end="57df710f-ce14-48a9-9c6f-c609ca32090c" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="5be180f4-026d-4892-82c4-67718ab91630" start_index="0" end="57df710f-ce14-48a9-9c6f-c609ca32090c" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="70e3dca9-3731-4168-8952-b8a16b3b7888" start_index="0" end="57df710f-ce14-48a9-9c6f-c609ca32090c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="e0a396a4-216b-48bf-8e6f-906317937665" start_index="0" end="ad3592c6-0d37-4aee-ac8c-65034e25d578" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="e0a396a4-216b-48bf-8e6f-906317937665" start_index="0" end="e59c2d4a-e903-41b8-b931-14ce5aa625c7" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="e0a396a4-216b-48bf-8e6f-906317937665" start_index="1" end="ad3592c6-0d37-4aee-ac8c-65034e25d578" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="e0a396a4-216b-48bf-8e6f-906317937665" start_index="2" end="ad3592c6-0d37-4aee-ac8c-65034e25d578" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="e0a396a4-216b-48bf-8e6f-906317937665" start_index="3" end="ad3592c6-0d37-4aee-ac8c-65034e25d578" end_index="4" portType="0" />
    <Dynamo.Models.ConnectorModel start="1c469abf-7c6c-452f-abd9-f8208716be6a" start_index="0" end="e59c2d4a-e903-41b8-b931-14ce5aa625c7" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="e59c2d4a-e903-41b8-b931-14ce5aa625c7" start_index="0" end="ad3592c6-0d37-4aee-ac8c-65034e25d578" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8219e2c4-7592-4fcd-b294-d1f5d8224cd0" start_index="0" end="e59c2d4a-e903-41b8-b931-14ce5aa625c7" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="8219e2c4-7592-4fcd-b294-d1f5d8224cd0" start_index="0" end="57df710f-ce14-48a9-9c6f-c609ca32090c" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="0def3b5c-c62c-403a-810c-132967c3eb8a" start_index="0" end="e59c2d4a-e903-41b8-b931-14ce5aa625c7" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="0def3b5c-c62c-403a-810c-132967c3eb8a" start_index="0" end="57df710f-ce14-48a9-9c6f-c609ca32090c" end_index="3" portType="0" />
    <Dynamo.Models.ConnectorModel start="0c96b696-128e-4afd-9fc1-a1528d9a4f0c" start_index="0" end="8aa817bf-2902-44c6-a25f-94b337648685" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="794bfc76-1ecf-4457-84e7-d5dda7ff123b" start_index="0" end="0c96b696-128e-4afd-9fc1-a1528d9a4f0c" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="794bfc76-1ecf-4457-84e7-d5dda7ff123b" start_index="0" end="0d59e559-86a5-4ed3-8512-8927ca1a3974" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="b2af0b4e-3c7b-4b93-830a-82739c84ddb8" start_index="0" end="65cb9412-3dde-465a-ad54-d3bd33e90e69" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="10bf8d65-92d3-4413-9f00-b3d4c93b37c8" start_index="0" end="92f0d8e8-7994-4e62-87b0-54dd6a24f525" end_index="2" portType="0" />
    <Dynamo.Models.ConnectorModel start="65cb9412-3dde-465a-ad54-d3bd33e90e69" start_index="0" end="92f0d8e8-7994-4e62-87b0-54dd6a24f525" end_index="0" portType="0" />
    <Dynamo.Models.ConnectorModel start="d2053ff0-991b-4328-a266-f1c1658982cc" start_index="0" end="0d59e559-86a5-4ed3-8512-8927ca1a3974" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="d2053ff0-991b-4328-a266-f1c1658982cc" start_index="1" end="0c96b696-128e-4afd-9fc1-a1528d9a4f0c" end_index="1" portType="0" />
    <Dynamo.Models.ConnectorModel start="d2053ff0-991b-4328-a266-f1c1658982cc" start_index="1" end="06ffb940-c1aa-454c-b771-c48bdb3ebd8b" end_index="0" portType="0" />
  </Connectors>
  <Notes />
  <Annotations>
    <Dynamo.Models.AnnotationModel guid="f540f00d-eacc-4efb-a17e-81081143ba5e" annotationText="SHELL POSITION" left="83.6714118618327" top="321.628577896228" width="325.768109939026" height="154.79419144045" fontSize="14" InitialTop="351.628577896228" InitialHeight="154.79419144045" TextblockHeight="20" backgrouund="#FFC1D676">
      <Models ModelGuid="5be180f4-026d-4892-82c4-67718ab91630" />
      <Models ModelGuid="70e3dca9-3731-4168-8952-b8a16b3b7888" />
    </Dynamo.Models.AnnotationModel>
    <Dynamo.Models.AnnotationModel guid="2fc9a71e-eeec-4e04-9ef8-f1d3d5c1e785" annotationText="FOOTPRINT DIMENSIONS" left="81.2407764149455" top="707.103622406821" width="326.82531240252" height="159.595126873759" fontSize="14" InitialTop="737.103622406821" InitialHeight="159.595126873759" TextblockHeight="20" backgrouund="#FFC1D676">
      <Models ModelGuid="8219e2c4-7592-4fcd-b294-d1f5d8224cd0" />
      <Models ModelGuid="0def3b5c-c62c-403a-810c-132967c3eb8a" />
    </Dynamo.Models.AnnotationModel>
    <Dynamo.Models.AnnotationModel guid="58275eab-4c1f-4aae-9ff5-ec7aac56e617" annotationText="1: Rectangular &#xD;&#xA;2: L-Shape&#xD;&#xA;3: U-Shape&#xD;&#xA;4: O-Shape" left="84.58081193718" top="493.33505177466" width="325.6" height="145" fontSize="14" InitialTop="570.53505177466" InitialHeight="97.8" TextblockHeight="67.2" backgrouund="#FFC1D676">
      <Models ModelGuid="bac481de-0358-47d9-8fb5-25e02a10216a" />
    </Dynamo.Models.AnnotationModel>
    <Dynamo.Models.AnnotationModel guid="d1cdd682-eee6-4f97-9854-c0709f5bd142" annotationText="RESULT" left="1329.13737606799" top="672.428633783962" width="146.157064614421" height="235.025568670525" fontSize="14" InitialTop="702.428633783962" InitialHeight="235.025568670525" TextblockHeight="20" backgrouund="#FFC1D676">
      <Models ModelGuid="0d59e559-86a5-4ed3-8512-8927ca1a3974" />
      <Models ModelGuid="8aa817bf-2902-44c6-a25f-94b337648685" />
    </Dynamo.Models.AnnotationModel>
  </Annotations>
  <Presets />
  <Cameras>
    <Camera Name="background_preview" eyeX="-158.646108317868" eyeY="333.329770855599" eyeZ="90.040395108931" lookX="272.353033530363" lookY="-201.303224255799" lookZ="-161.069146008732" />
  </Cameras>
</Workspace>